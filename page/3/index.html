<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.11.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Hi, welcome to Hexo Coder!">
<meta property="og:type" content="website">
<meta property="og:title" content="Zyc Blog">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Zyc Blog">
<meta property="og:description" content="Hi, welcome to Hexo Coder!">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="YeChang Zhang">
<meta property="article:tag" content="Blog,Hexo,Theme,Coder,YeChang Zhang">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Zyc Blog</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Zyc Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">YeChang Zhang</p>
  <div class="site-description" itemprop="description">Hi, welcome to Hexo Coder!</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/05/22/HTML5-%E6%96%B0%E5%A2%9E%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="YeChang Zhang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zyc Blog">
      <meta itemprop="description" content="Hi, welcome to Hexo Coder!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zyc Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/05/22/HTML5-%E6%96%B0%E5%A2%9E%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE/" class="post-title-link" itemprop="url">HTML5 新增语义化标签</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-05-22 11:16:00" itemprop="dateCreated datePublished" datetime="2018-05-22T11:16:00+08:00">2018-05-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="HTML5-新增语义化标签"><a href="#HTML5-新增语义化标签" class="headerlink" title="HTML5 新增语义化标签"></a>HTML5 新增语义化标签</h1><p>这种语义化标签主要是针对搜索引擎的<br>这些新标签页面中可以使用多次</p>
<ul>
<li>header 头部标签</li>
<li>nav 导航标签</li>
<li>content 内容标签</li>
<li>section 定义文档某个区域</li>
<li>aside 侧边栏标签</li>
<li>footer 尾部标签</li>
<li>video 视频标签</li>
<li>audio 音频标签</li>
<li>user-select:none;禁止鼠标移动选择文字</li>
<li>background-image:liner-gradient(to right,red,green); 设置背景颜色渐变</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/05/14/%E6%B5%8F%E8%A7%88%E5%99%A8BOM%E5%92%8CJS%E4%B8%AD%E7%9A%84DOM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="YeChang Zhang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zyc Blog">
      <meta itemprop="description" content="Hi, welcome to Hexo Coder!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zyc Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/05/14/%E6%B5%8F%E8%A7%88%E5%99%A8BOM%E5%92%8CJS%E4%B8%AD%E7%9A%84DOM/" class="post-title-link" itemprop="url">浏览器BOM和JS中的DOM</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-05-14 10:09:35" itemprop="dateCreated datePublished" datetime="2018-05-14T10:09:35+08:00">2018-05-14</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>JavaScript是一种运行在客户端的脚本语言 （Script 是脚本的意思）,它有三部分组成 ：ECMAScript 语法 ， DOM(页面文档对象模型) ，BOM(浏览器对象模型)而Web API则包含了DOM和BOM</p>
<h1 id="什么是BOM"><a href="#什么是BOM" class="headerlink" title="什么是BOM"></a>什么是BOM</h1><p>BOM（Browser Object Model）即浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是 window。</p>
<p>BOM 由一系列相关的对象构成，并且每个对象都提供了很多方法与属性 ，但是BOM 缺乏标准，JavaScript 语法的标准化组织是 ECMA，DOM 的标准化组织是 W3C，BOM 最初是Netscape 浏览器标准的一部分。</p>
<h1 id="BOM的构成部分"><a href="#BOM的构成部分" class="headerlink" title="BOM的构成部分"></a>BOM的构成部分</h1><p>是window顶级对象 ，也是JS访问浏览器窗口的一个接口。<br>其中包含： document location navigator screen history</p>
<h1 id="window对象的常见的事件"><a href="#window对象的常见的事件" class="headerlink" title="window对象的常见的事件"></a>window对象的常见的事件</h1><ul>
<li>窗口加载事件 window.onload 当文档内容完全加载完成会触发该事件(包括图像、脚本文件、CSS 文件等), 就调用的处理函数。(JS代码都写在加载事件里面)</li>
<li>调整窗口大小的事件 window.onresize window.innerWidth 获取当前屏幕的宽度</li>
<li>window.setTimeout(调用函数， [延迟的毫秒数]) window.clearTimeout(timeoutID) setInterval clearInterval</li>
</ul>
<h1 id="什么是-DOM"><a href="#什么是-DOM" class="headerlink" title="什么是 DOM"></a>什么是 DOM</h1><p>DOM 英文全称“Document Object Model”，译为“文档对象模型”。<br>DOM 是一个与平台和编程语言无关的接口，通过这个接口程序和脚本可以动态的访问和修改文档的内容、结构和样式。</p>
<h1 id="DOM-的组成"><a href="#DOM-的组成" class="headerlink" title="DOM 的组成"></a>DOM 的组成</h1><p>核心DOM - 针对任何结构化文档的标准模型。<br>XML DOM - 针对 XML 文档的标准模型。<br>HTML DOM - 针对 HTML 文档的标准模型。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/05/12/JS%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="YeChang Zhang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zyc Blog">
      <meta itemprop="description" content="Hi, welcome to Hexo Coder!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zyc Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/05/12/JS%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">JS浏览器事件循环机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-05-12 09:48:14" itemprop="dateCreated datePublished" datetime="2018-05-12T09:48:14+08:00">2018-05-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="JavaScript-单线程-非阻塞"><a href="#JavaScript-单线程-非阻塞" class="headerlink" title="JavaScript 单线程 非阻塞"></a>JavaScript 单线程 非阻塞</h1><p>定义：单线程（代码执行时只有一个主线程来处理所有任务），非阻塞（当代码需要进行一项异步任务时不会等待，主线程会挂起这个任务，在异步任务返回结果时再执行相应的回调）的脚本语言<br>用途：与浏览器交互</p>
<h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><p>用途：js引擎（网页浏览器中专门处理js脚本的虚拟机）实现非阻塞</p>
<h1 id="浏览器环境下js引擎的事件循环机制"><a href="#浏览器环境下js引擎的事件循环机制" class="headerlink" title="浏览器环境下js引擎的事件循环机制"></a>浏览器环境下js引擎的事件循环机制</h1><p>js代码执行时将不同变量存于内存中的不同位置<br>堆：放对象 栈：基础类型变量，对象指针</p>
<h1 id="执行栈：存放执行环境并依次调用执行的地方"><a href="#执行栈：存放执行环境并依次调用执行的地方" class="headerlink" title="执行栈：存放执行环境并依次调用执行的地方"></a>执行栈：存放执行环境并依次调用执行的地方</h1><p>当调用一个方法时，js会生成一个与这个方法对应的执行环境（也叫执行上下文，存放这个方法的私有作用域，上层作用域指向，参数，变量，this对象）。这些方法都被存放在执行栈中，依次调用</p>
<h1 id="执行栈执行同步代码"><a href="#执行栈执行同步代码" class="headerlink" title="执行栈执行同步代码"></a>执行栈执行同步代码</h1><p>按照执行顺序将执行环境依次加入执行栈中并进入环境执行代码，若有调用，在执行栈中再添加一个执行环境（往上垒），执行环境中的代码执行完毕并返回结果后，js会退出这个执行环境并将其销毁，回到上一个方法的执行环境。反复进行，直到代码全部执行完毕</p>
<h3 id="执行栈执行异步代码（如发送ajax请求数据）事件队列–实现非阻塞"><a href="#执行栈执行异步代码（如发送ajax请求数据）事件队列–实现非阻塞" class="headerlink" title="执行栈执行异步代码（如发送ajax请求数据）事件队列–实现非阻塞"></a>执行栈执行异步代码（如发送ajax请求数据）事件队列–实现非阻塞</h3><h3 id="js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕，-主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码…，如此反复，这样就形成了一个无限的循环"><a href="#js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕，-主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码…，如此反复，这样就形成了一个无限的循环" class="headerlink" title="js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码…，如此反复，这样就形成了一个无限的循环"></a>js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码…，如此反复，这样就形成了一个无限的循环</h3><h3 id="因为形成了无限循环，所以这个过程被叫做事件循环"><a href="#因为形成了无限循环，所以这个过程被叫做事件循环" class="headerlink" title="因为形成了无限循环，所以这个过程被叫做事件循环"></a>因为形成了无限循环，所以这个过程被叫做<code>事件循环</code></h3><h3 id="不同的异步任务依据执行优先级被分为两类：微任务（micro-task）和宏任务（macro-task）"><a href="#不同的异步任务依据执行优先级被分为两类：微任务（micro-task）和宏任务（macro-task）" class="headerlink" title="不同的异步任务依据执行优先级被分为两类：微任务（micro task）和宏任务（macro task）"></a>不同的异步任务依据执行优先级被分为两类：微任务（micro task）和宏任务（macro task）</h3><ul>
<li>宏任务：setInterval() setTimeout()</li>
<li>微任务：new Promise() new MutaionObserver()</li>
</ul>
<h3 id="当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行（先微再宏）"><a href="#当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行（先微再宏）" class="headerlink" title="当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行（先微再宏）"></a>当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行（先微再宏）</h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/04/20/JS%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E4%B8%8E%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="YeChang Zhang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zyc Blog">
      <meta itemprop="description" content="Hi, welcome to Hexo Coder!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zyc Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/04/20/JS%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E4%B8%8E%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">JS事件机制与相关问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-20 22:45:27" itemprop="dateCreated datePublished" datetime="2018-04-20T22:45:27+08:00">2018-04-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="什么是事件代理-x2F-事件委托？"><a href="#什么是事件代理-x2F-事件委托？" class="headerlink" title="什么是事件代理&#x2F;事件委托？"></a>什么是事件代理&#x2F;事件委托？</h2><h4 id="事件代理-x2F-事件委托是利用事件冒泡的特性，将本应该绑定在多个元素上的事件绑定在他们的祖先元素上，尤其在动态添加子元素的时候，可以非常方便的提高程序性能，减小内存空间。"><a href="#事件代理-x2F-事件委托是利用事件冒泡的特性，将本应该绑定在多个元素上的事件绑定在他们的祖先元素上，尤其在动态添加子元素的时候，可以非常方便的提高程序性能，减小内存空间。" class="headerlink" title="事件代理&#x2F;事件委托是利用事件冒泡的特性，将本应该绑定在多个元素上的事件绑定在他们的祖先元素上，尤其在动态添加子元素的时候，可以非常方便的提高程序性能，减小内存空间。"></a>事件代理&#x2F;事件委托是利用事件冒泡的特性，将本应该绑定在多个元素上的事件绑定在他们的祖先元素上，尤其在动态添加子元素的时候，可以非常方便的提高程序性能，减小内存空间。</h4><h2 id="什么是事件冒泡？什么是事件捕获？"><a href="#什么是事件冒泡？什么是事件捕获？" class="headerlink" title="什么是事件冒泡？什么是事件捕获？"></a>什么是事件冒泡？什么是事件捕获？</h2><ul>
<li>冒泡型事件：事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。</li>
<li>捕获型事件：事件从最不精确的对象(document 对象)开始触发，然后到最精确(也可以在窗口级别捕获事件，不过必须由开发人员特别指定)。</li>
</ul>
<h4 id="在添加事件时用addEventListener-event-fn-useCapture-方法，基中第3个参数useCapture是一个Boolean值，用来设置事件是在事件捕获时执行，还是事件冒泡时执行-Vue-中-click默认是冒泡的"><a href="#在添加事件时用addEventListener-event-fn-useCapture-方法，基中第3个参数useCapture是一个Boolean值，用来设置事件是在事件捕获时执行，还是事件冒泡时执行-Vue-中-click默认是冒泡的" class="headerlink" title="在添加事件时用addEventListener(event,fn,useCapture)方法，基中第3个参数useCapture是一个Boolean值，用来设置事件是在事件捕获时执行，还是事件冒泡时执行 Vue 中 @click默认是冒泡的"></a>在添加事件时用addEventListener(event,fn,useCapture)方法，基中第3个参数useCapture是一个Boolean值，用来设置事件是在事件捕获时执行，还是事件冒泡时执行 Vue 中 @click默认是冒泡的</h4><h4 id="e-stopPropagation-阻止事件冒泡"><a href="#e-stopPropagation-阻止事件冒泡" class="headerlink" title="e.stopPropagation() 阻止事件冒泡"></a>e.stopPropagation() 阻止事件冒泡</h4><h2 id="DOM-事件有哪些阶段？谈谈对事件代理的理解"><a href="#DOM-事件有哪些阶段？谈谈对事件代理的理解" class="headerlink" title="DOM 事件有哪些阶段？谈谈对事件代理的理解"></a>DOM 事件有哪些阶段？谈谈对事件代理的理解</h2><h4 id="分为三大阶段：捕获阶段–目标阶段–冒泡阶段"><a href="#分为三大阶段：捕获阶段–目标阶段–冒泡阶段" class="headerlink" title="分为三大阶段：捕获阶段–目标阶段–冒泡阶段"></a>分为三大阶段：捕获阶段–目标阶段–冒泡阶段</h4><h4 id="事件代理简单说就是：事件不直接绑定到某元素上，而是绑定到该元素的父元素上，进行触发事件操作时-例如’click’-，再通过条件判断，执行事件触发后的语句-例如’alert-e-target-innerhtml-’"><a href="#事件代理简单说就是：事件不直接绑定到某元素上，而是绑定到该元素的父元素上，进行触发事件操作时-例如’click’-，再通过条件判断，执行事件触发后的语句-例如’alert-e-target-innerhtml-’" class="headerlink" title="事件代理简单说就是：事件不直接绑定到某元素上，而是绑定到该元素的父元素上，进行触发事件操作时(例如’click’)，再通过条件判断，执行事件触发后的语句(例如’alert(e.target.innerhtml)’)"></a>事件代理简单说就是：事件不直接绑定到某元素上，而是绑定到该元素的父元素上，进行触发事件操作时(例如’click’)，再通过条件判断，执行事件触发后的语句(例如’alert(e.target.innerhtml)’)</h4><h2 id="闭包的概念？优缺点？使用场景？"><a href="#闭包的概念？优缺点？使用场景？" class="headerlink" title="闭包的概念？优缺点？使用场景？"></a>闭包的概念？优缺点？使用场景？</h2><h4 id="闭包的概念：闭包就是能读取其他函数内部变量的函数。"><a href="#闭包的概念：闭包就是能读取其他函数内部变量的函数。" class="headerlink" title="闭包的概念：闭包就是能读取其他函数内部变量的函数。"></a>闭包的概念：闭包就是能读取其他函数内部变量的函数。</h4><h4 id="优点：-避免全局变量的污染，希望一个变量长期存储在内存中（缓存变量）"><a href="#优点：-避免全局变量的污染，希望一个变量长期存储在内存中（缓存变量）" class="headerlink" title="优点： 避免全局变量的污染，希望一个变量长期存储在内存中（缓存变量）"></a>优点： 避免全局变量的污染，希望一个变量长期存储在内存中（缓存变量）</h4><h4 id="缺点：-内存泄露（消耗），常驻内存，增加内存使用量"><a href="#缺点：-内存泄露（消耗），常驻内存，增加内存使用量" class="headerlink" title="缺点： 内存泄露（消耗），常驻内存，增加内存使用量"></a>缺点： 内存泄露（消耗），常驻内存，增加内存使用量</h4><h4 id="使用场景：封装功能时-需要使用私有的属性和方法-，函数防抖、函数节流、函数柯里化、给元素伪数组添加事件需要使用元素的索引值。"><a href="#使用场景：封装功能时-需要使用私有的属性和方法-，函数防抖、函数节流、函数柯里化、给元素伪数组添加事件需要使用元素的索引值。" class="headerlink" title="使用场景：封装功能时(需要使用私有的属性和方法)，函数防抖、函数节流、函数柯里化、给元素伪数组添加事件需要使用元素的索引值。"></a>使用场景：封装功能时(需要使用私有的属性和方法)，函数防抖、函数节流、函数柯里化、给元素伪数组添加事件需要使用元素的索引值。</h4><h2 id="new操作符具体干了什么呢"><a href="#new操作符具体干了什么呢" class="headerlink" title="new操作符具体干了什么呢?"></a>new操作符具体干了什么呢?</h2><ul>
<li>1.创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。</li>
<li>2.属性和方法被加入到 this 引用的对象中。</li>
<li>3.新创建的对象由 this 所引用，并且最后隐式的返回 this 。</li>
</ul>
<h2 id="javascript中this的指向"><a href="#javascript中this的指向" class="headerlink" title="javascript中this的指向"></a>javascript中this的指向</h2><h4 id="this永远指向函数运行时所在的对象，而不是函数被创建时所在的对象。"><a href="#this永远指向函数运行时所在的对象，而不是函数被创建时所在的对象。" class="headerlink" title="this永远指向函数运行时所在的对象，而不是函数被创建时所在的对象。"></a>this永远指向函数运行时所在的对象，而不是函数被创建时所在的对象。</h4><h4 id="普通的函数调用，函数被谁调用，this就是谁"><a href="#普通的函数调用，函数被谁调用，this就是谁" class="headerlink" title="普通的函数调用，函数被谁调用，this就是谁"></a>普通的函数调用，函数被谁调用，this就是谁</h4><h4 id="构造函数的话，如果不用new操作符而直接调用，那即this指向window。用new操作符生成对象实例后，this就指向了新生成的对象。"><a href="#构造函数的话，如果不用new操作符而直接调用，那即this指向window。用new操作符生成对象实例后，this就指向了新生成的对象。" class="headerlink" title="构造函数的话，如果不用new操作符而直接调用，那即this指向window。用new操作符生成对象实例后，this就指向了新生成的对象。"></a>构造函数的话，如果不用new操作符而直接调用，那即this指向window。用new操作符生成对象实例后，this就指向了新生成的对象。</h4><h4 id="匿名函数或不处于任何对象中的函数指向window"><a href="#匿名函数或不处于任何对象中的函数指向window" class="headerlink" title="匿名函数或不处于任何对象中的函数指向window"></a>匿名函数或不处于任何对象中的函数指向window</h4><h4 id="如果是call，apply等，指定的this是谁，就是谁。"><a href="#如果是call，apply等，指定的this是谁，就是谁。" class="headerlink" title="如果是call，apply等，指定的this是谁，就是谁。"></a>如果是call，apply等，指定的this是谁，就是谁。</h4><h2 id="Javascript作用链域"><a href="#Javascript作用链域" class="headerlink" title="Javascript作用链域"></a>Javascript作用链域</h2><h4 id="作用域链的原理和原型链很类似，如果这个变量在自己的作用域中没有，那么它会寻找父级的，直到最顶层。"><a href="#作用域链的原理和原型链很类似，如果这个变量在自己的作用域中没有，那么它会寻找父级的，直到最顶层。" class="headerlink" title="作用域链的原理和原型链很类似，如果这个变量在自己的作用域中没有，那么它会寻找父级的，直到最顶层。"></a>作用域链的原理和原型链很类似，如果这个变量在自己的作用域中没有，那么它会寻找父级的，直到最顶层。</h4><h2 id="js如何处理防抖和节流"><a href="#js如何处理防抖和节流" class="headerlink" title="js如何处理防抖和节流"></a>js如何处理防抖和节流</h2><h4 id="在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。"><a href="#在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。" class="headerlink" title="在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。"></a>在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数防抖（debounce）：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。如下，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> debounce(fn, <span class="built_in">wait</span>) &#123; </span><br><span class="line">  var <span class="built_in">timeout</span> = null; </span><br><span class="line">  <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>() &#123; </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">timeout</span> !== null) clearTimeout(<span class="built_in">timeout</span>);</span><br><span class="line">    <span class="built_in">timeout</span> = setTimeout(fn, <span class="built_in">wait</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line">// 处理函数 </span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">handle</span></span>() &#123; console.log(Math.random()); &#125; // 滚动事件</span><br><span class="line">window.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, debounce(handle, 1000)); 函数节流函数节流（throttle）：</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当持续触发事件时，保证一定时间段内只调用一次事件处理函数。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。如下，持续触发scroll事件时，并不立即执行handle函数，每隔1000毫秒才会执行一次handle函数。</span></span><br><span class="line">var throttle = <span class="keyword">function</span>(func, delay) &#123; </span><br><span class="line">  var prev = Date.now(); </span><br><span class="line">  <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    var context = this;</span><br><span class="line">    var args = arguments; </span><br><span class="line">    var now = Date.now(); </span><br><span class="line">    <span class="keyword">if</span> (now - prev &gt;= delay) &#123; </span><br><span class="line">      func.apply(context, args);</span><br><span class="line">      prev = Date.now(); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">handle</span></span>() &#123; console.log(Math.random()); &#125; </span><br><span class="line">window.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, throttle(handle, 1000));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="JS里垃圾回收机制是什么，常用的是哪种，怎么处理的？"><a href="#JS里垃圾回收机制是什么，常用的是哪种，怎么处理的？" class="headerlink" title="JS里垃圾回收机制是什么，常用的是哪种，怎么处理的？"></a>JS里垃圾回收机制是什么，常用的是哪种，怎么处理的？</h2><h4 id="JS的垃圾回收机制是为了以防内存泄漏，内存泄漏的含义就是当已经不需要某块内存时这块内存还存在着，垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向的内存。JS中最常见的垃圾回收方式是标记清除。工作原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。"><a href="#JS的垃圾回收机制是为了以防内存泄漏，内存泄漏的含义就是当已经不需要某块内存时这块内存还存在着，垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向的内存。JS中最常见的垃圾回收方式是标记清除。工作原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。" class="headerlink" title="JS的垃圾回收机制是为了以防内存泄漏，内存泄漏的含义就是当已经不需要某块内存时这块内存还存在着，垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向的内存。JS中最常见的垃圾回收方式是标记清除。工作原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。"></a>JS的垃圾回收机制是为了以防内存泄漏，内存泄漏的含义就是当已经不需要某块内存时这块内存还存在着，垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向的内存。JS中最常见的垃圾回收方式是标记清除。工作原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。</h4><h4 id="那些操作会造成内存泄漏"><a href="#那些操作会造成内存泄漏" class="headerlink" title="那些操作会造成内存泄漏"></a>那些操作会造成内存泄漏</h4><h4 id="全局变量、闭包、DOM清空或删除时，事件未清除、子元素存在引用"><a href="#全局变量、闭包、DOM清空或删除时，事件未清除、子元素存在引用" class="headerlink" title="全局变量、闭包、DOM清空或删除时，事件未清除、子元素存在引用"></a>全局变量、闭包、DOM清空或删除时，事件未清除、子元素存在引用</h4><h2 id="什么是虚拟DOM"><a href="#什么是虚拟DOM" class="headerlink" title="什么是虚拟DOM"></a>什么是虚拟DOM</h2><h4 id="文档对象模型或-DOM-定义了一个接口，该接口允许-JavaScript-之类的语言访问和操作-HTML-文档。元素由树中的节点表示，并且接口允许我们操纵它们。但是此接口需要付出代价，大量非常频繁的-DOM-操作会使页面速度变慢。为了减少重排和重绘，虚拟dom应运而生。"><a href="#文档对象模型或-DOM-定义了一个接口，该接口允许-JavaScript-之类的语言访问和操作-HTML-文档。元素由树中的节点表示，并且接口允许我们操纵它们。但是此接口需要付出代价，大量非常频繁的-DOM-操作会使页面速度变慢。为了减少重排和重绘，虚拟dom应运而生。" class="headerlink" title="文档对象模型或 DOM 定义了一个接口，该接口允许 JavaScript 之类的语言访问和操作 HTML 文档。元素由树中的节点表示，并且接口允许我们操纵它们。但是此接口需要付出代价，大量非常频繁的 DOM 操作会使页面速度变慢。为了减少重排和重绘，虚拟dom应运而生。"></a>文档对象模型或 DOM 定义了一个接口，该接口允许 JavaScript 之类的语言访问和操作 HTML 文档。元素由树中的节点表示，并且接口允许我们操纵它们。但是此接口需要付出代价，大量非常频繁的 DOM 操作会使页面速度变慢。为了减少重排和重绘，虚拟dom应运而生。</h4><h3 id="JS延迟加载的方式有哪些？"><a href="#JS延迟加载的方式有哪些？" class="headerlink" title="JS延迟加载的方式有哪些？"></a>JS延迟加载的方式有哪些？</h3><h4 id="defer和async、动态创建DOM方式（用得最多）、按需异步载入JS"><a href="#defer和async、动态创建DOM方式（用得最多）、按需异步载入JS" class="headerlink" title="defer和async、动态创建DOM方式（用得最多）、按需异步载入JS"></a>defer和async、动态创建DOM方式（用得最多）、按需异步载入JS</h4><ul>
<li>defer：延迟脚本。立即下载，但延迟执行（延迟到整个页面都解析完毕后再运行），按照脚本出现的先后顺序执行。</li>
<li>async：异步脚本。下载完立即执行，但不保证按照脚本出现的先后顺序执行。</li>
</ul>
<h2 id="JS为什么要区分微任务和宏任务"><a href="#JS为什么要区分微任务和宏任务" class="headerlink" title="JS为什么要区分微任务和宏任务"></a>JS为什么要区分微任务和宏任务</h2><ul>
<li>（1）js是单线程的，但是分同步异步</li>
<li>（2）微任务和宏任务皆为异步任务，它们都属于一个队列</li>
<li>（3）宏任务一般是：script，setTimeout，setInterval、setImmediate</li>
<li>（4）微任务：原生Promise</li>
<li>（5）遇到微任务，先执行微任务，执行完后如果没有微任务，就执行下一个宏任务，如果有微任务，就按顺序一个一个执行微任务</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/04/18/JS%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="YeChang Zhang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zyc Blog">
      <meta itemprop="description" content="Hi, welcome to Hexo Coder!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zyc Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/04/18/JS%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">JS经典问题指南</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-18 22:09:19" itemprop="dateCreated datePublished" datetime="2018-04-18T22:09:19+08:00">2018-04-18</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="JavaScript的数据类型"><a href="#JavaScript的数据类型" class="headerlink" title="JavaScript的数据类型"></a>JavaScript的数据类型</h2><ul>
<li>值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol（独一无二的值</li>
<li>引用数据类型：对象(Object)、数组(Array)、函数(Function)。</li>
</ul>
<h2 id="基本数据类型与引用类型在存储上有什么区别"><a href="#基本数据类型与引用类型在存储上有什么区别" class="headerlink" title="基本数据类型与引用类型在存储上有什么区别?"></a>基本数据类型与引用类型在存储上有什么区别?</h2><h3 id="1-存储位置不同"><a href="#1-存储位置不同" class="headerlink" title="1.存储位置不同:"></a>1.存储位置不同:</h3><ul>
<li>基本数据类型：以栈的形式存储, 保存与赋值指向数据本身, 用typeof 来判断类型</li>
<li>引用类型：以堆的形式存储, 保存于赋值指向对象的一个指针, 用instanceof 来判断类型</li>
</ul>
<h3 id="2-传值方式不同："><a href="#2-传值方式不同：" class="headerlink" title="2.传值方式不同："></a>2.传值方式不同：</h3><ul>
<li>基本数据类型按值传递，无法改变一个基本数据类型的值</li>
<li>引用类型按引用传递，应用类型值可以改变</li>
</ul>
<h2 id="判断-js-类型的方式"><a href="#判断-js-类型的方式" class="headerlink" title="判断 js 类型的方式"></a>判断 js 类型的方式</h2><ul>
<li><ol>
<li>typeof<h3 id="可以判断出’string’-’number’-’boolean’-’undefined’-’symbol’但判断-typeof-null-时值为-‘object’-判断数组和对象时值均为-‘object’"><a href="#可以判断出’string’-’number’-’boolean’-’undefined’-’symbol’但判断-typeof-null-时值为-‘object’-判断数组和对象时值均为-‘object’" class="headerlink" title="可以判断出’string’,’number’,’boolean’,’undefined’,’symbol’但判断 typeof(null) 时值为 ‘object’; 判断数组和对象时值均为 ‘object’"></a>可以判断出’string’,’number’,’boolean’,’undefined’,’symbol’但判断 typeof(null) 时值为 ‘object’; 判断数组和对象时值均为 ‘object’</h3></li>
</ol>
</li>
<li><ol start="2">
<li>instanceof<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">functionA</span></span>() &#123;&#125;</span><br><span class="line"><span class="built_in">let</span> a = new A();</span><br><span class="line">a instanceof A //true</span><br><span class="line">// 因为 Object.getPrototypeOf(a) === A.prototype;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="3">
<li>Object.prototype.toString.call() 可以判断所有类型<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call(null)//<span class="string">&quot;[object Null]&quot;</span></span><br><span class="line">Object.prototype.toString.call(undefined)//<span class="string">&quot;[object Undefined]&quot;</span></span><br><span class="line">Object.prototype.toString.call(Object)//<span class="string">&quot;[object Function]&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="描述以下变量的区别：null，undefined或undeclared"><a href="#描述以下变量的区别：null，undefined或undeclared" class="headerlink" title="描述以下变量的区别：null，undefined或undeclared"></a>描述以下变量的区别：null，undefined或undeclared</h2><ul>
<li>null 表示”没有对象”</li>
<li>undefined 表示”缺少值”，就是此处应该有一个值，但是还没有定义</li>
</ul>
<h4 id="变量被声明了，但没有赋值时，就等于undefined。"><a href="#变量被声明了，但没有赋值时，就等于undefined。" class="headerlink" title="变量被声明了，但没有赋值时，就等于undefined。"></a>变量被声明了，但没有赋值时，就等于undefined。</h4><h4 id="调用函数时，应该提供的参数没有提供，该参数等于undefined。"><a href="#调用函数时，应该提供的参数没有提供，该参数等于undefined。" class="headerlink" title="调用函数时，应该提供的参数没有提供，该参数等于undefined。"></a>调用函数时，应该提供的参数没有提供，该参数等于undefined。</h4><h4 id="对象没有赋值的属性，该属性的值为undefined。"><a href="#对象没有赋值的属性，该属性的值为undefined。" class="headerlink" title="对象没有赋值的属性，该属性的值为undefined。"></a>对象没有赋值的属性，该属性的值为undefined。</h4><h4 id="函数没有返回值时，默认返回undefined。"><a href="#函数没有返回值时，默认返回undefined。" class="headerlink" title="函数没有返回值时，默认返回undefined。"></a>函数没有返回值时，默认返回undefined。</h4><ul>
<li>undeclared :js语法错误，没有申明直接使用，js无法找到对应的上下文。</li>
</ul>
<h2 id="for-in-和-object-keys的区别"><a href="#for-in-和-object-keys的区别" class="headerlink" title="for..in 和 object.keys的区别"></a>for..in 和 object.keys的区别</h2><ul>
<li>Object.keys不会遍历继承的原型属性</li>
<li>for…in 会遍历继承的原型属性</li>
</ul>
<h2 id="JS-中的函数提升"><a href="#JS-中的函数提升" class="headerlink" title="JS 中的函数提升"></a>JS 中的函数提升</h2><h4 id="JS允许将声明移动到顶部的默认行为称为提升。JS中创建函数的两种方法是函数声明和函数表达式。"><a href="#JS允许将声明移动到顶部的默认行为称为提升。JS中创建函数的两种方法是函数声明和函数表达式。" class="headerlink" title="JS允许将声明移动到顶部的默认行为称为提升。JS中创建函数的两种方法是函数声明和函数表达式。"></a>JS允许将声明移动到顶部的默认行为称为提升。JS中创建函数的两种方法是函数声明和函数表达式。</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数声明</span></span><br><span class="line">hoisted();</span><br><span class="line">// logs <span class="string">&quot;foo&quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">hoisted</span></span>() &#123;console.log(<span class="string">&#x27;foo&#x27;</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数表达式</span></span><br><span class="line">notHoisted(); </span><br><span class="line"><span class="comment">#TypeError: notHoisted is not a function</span></span><br><span class="line">var notHoisted = <span class="function"><span class="title">function</span></span>() &#123;console.log(<span class="string">&#x27;bar&#x27;</span>);&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Js隐式转换"><a href="#Js隐式转换" class="headerlink" title="Js隐式转换"></a>Js隐式转换</h2><h4 id="在js中，当运算符在运算时，如果两边数据不统一，CPU就无法计算，这时我们编译器会自动将运算符两边的数据做一个数据类型转换，转成一样的数据类型再计算"><a href="#在js中，当运算符在运算时，如果两边数据不统一，CPU就无法计算，这时我们编译器会自动将运算符两边的数据做一个数据类型转换，转成一样的数据类型再计算" class="headerlink" title="在js中，当运算符在运算时，如果两边数据不统一，CPU就无法计算，这时我们编译器会自动将运算符两边的数据做一个数据类型转换，转成一样的数据类型再计算"></a>在js中，当运算符在运算时，如果两边数据不统一，CPU就无法计算，这时我们编译器会自动将运算符两边的数据做一个数据类型转换，转成一样的数据类型再计算</h4><h4 id="这种无需程序员手动转换，而由编译器自动转换的方式就称为隐式转换"><a href="#这种无需程序员手动转换，而由编译器自动转换的方式就称为隐式转换" class="headerlink" title="这种无需程序员手动转换，而由编译器自动转换的方式就称为隐式转换"></a>这种无需程序员手动转换，而由编译器自动转换的方式就称为隐式转换</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 隐式转换规则：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 转成string类型： +（字符串连接符） 2..转成number类型：++/--(自增自减运算符) + - * / %(算术运算符) &gt; &lt; &gt;= &lt;= == != === !=== (关系运算符)</span></span><br><span class="line"><span class="comment"># 2. 转成boolean类型：!（逻辑非运算符）</span></span><br><span class="line">console.log([] == []) // <span class="literal">false</span> </span><br><span class="line">console.log([] == ![]) // <span class="literal">true</span></span><br><span class="line">console.log([] !== []) // <span class="literal">true</span></span><br><span class="line">console.log(NaN != NaN) // <span class="literal">true</span></span><br><span class="line">console.log(null == undefined) // <span class="literal">true</span></span><br><span class="line">console.log(null === undefined) // <span class="literal">false</span></span><br><span class="line">console.log(1 == <span class="literal">true</span>) // <span class="literal">true</span></span><br><span class="line">console.log(null &gt; 0) // <span class="literal">false</span></span><br><span class="line">console.log(<span class="literal">true</span> + 1) // 2</span><br><span class="line">console.log(undefined + 1) // NaN</span><br><span class="line">console.log(&#123;&#125; + 1) // [object Object]1</span><br><span class="line">console.log([] + &#123;&#125;) // [object Object]</span><br><span class="line">console.log([2,3] + [1,2]) // 2,31,2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="JS-中-x3D-x3D-和-x3D-x3D-x3D-区别是什么？"><a href="#JS-中-x3D-x3D-和-x3D-x3D-x3D-区别是什么？" class="headerlink" title="JS 中 &#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; 区别是什么？"></a>JS 中 &#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; 区别是什么？</h2><ul>
<li>两等号判等，会在比较时进行类型转换；</li>
<li>三等号判等(判断严格)，比较时不进行隐式类型转换，(类 型不同则会返回false)；</li>
</ul>
<h2 id="ES5-和-ES6-分别几种方式声明变量"><a href="#ES5-和-ES6-分别几种方式声明变量" class="headerlink" title="ES5 和 ES6 分别几种方式声明变量"></a>ES5 和 ES6 分别几种方式声明变量</h2><ul>
<li>ES5 有俩种：var 和 function</li>
<li>ES6 有六种：增加四种，let、const、class 和 import</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/04/16/CSS%E7%BB%8F%E5%85%B8%E8%A7%84%E5%88%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="YeChang Zhang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zyc Blog">
      <meta itemprop="description" content="Hi, welcome to Hexo Coder!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zyc Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/04/16/CSS%E7%BB%8F%E5%85%B8%E8%A7%84%E5%88%99/" class="post-title-link" itemprop="url">CSS经典规则</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-16 21:13:34" itemprop="dateCreated datePublished" datetime="2018-04-16T21:13:34+08:00">2018-04-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="CSS经典规则"><a href="#CSS经典规则" class="headerlink" title="CSS经典规则"></a>CSS经典规则</h1><h3 id="使用方式-及-权重"><a href="#使用方式-及-权重" class="headerlink" title="使用方式 及 权重"></a>使用方式 及 权重</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.内联：直接在HTML元素上使用</span><br><span class="line">&lt;p style=<span class="string">&quot;color: red&quot;</span>&gt;&lt;/p&gt;</span><br><span class="line">2.外部:在工作空间中创建单独的CSS文件，然后在创建的每个web页面中链接它们</span><br><span class="line">&lt;<span class="built_in">head</span>&gt;</span><br><span class="line">&lt;<span class="built_in">link</span> rel=<span class="string">&quot;text/css&quot;</span> href=<span class="string">&quot;url&quot;</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">3. web 页面的 <span class="built_in">head</span> 元素在其中实现了内部 CSS。</span><br><span class="line">&lt;<span class="built_in">head</span>&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">p&#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 权重优先级 !important -&gt; 内联 -&gt; 最后读取的</span></span><br></pre></td></tr></table></figure>

<h3 id="伪类和伪元素是什么？如何区分？"><a href="#伪类和伪元素是什么？如何区分？" class="headerlink" title="伪类和伪元素是什么？如何区分？"></a>伪类和伪元素是什么？如何区分？</h3><ul>
<li>伪类是用来定义元素特殊状态的，他可以用来设置鼠标悬停样式、元素获取焦点样式、设置链接样式等。如常见的 hover、active、link 等都是伪类</li>
<li>伪元素也称为伪对象，它不存在于 DOM 文档中、是一个虚拟的元素。它可以用来代表某个元素的子元素，但是这个子元素并不存在于文档树中。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 伪类和伪元素的根本区别在于：是否创造了新的元素。</span></span><br><span class="line"><span class="comment"># html </span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;p class=<span class="string">&quot;one&quot;</span>&gt;红色&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;黑色&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="comment">#css 伪类</span></span><br><span class="line">p:first-child&#123;</span><br><span class="line">  color:red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># css 伪元素</span></span><br><span class="line">.one &#123;</span><br><span class="line">  color:red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="BFC-规范（块级格式化上下文：block-formatting-context）"><a href="#BFC-规范（块级格式化上下文：block-formatting-context）" class="headerlink" title="BFC 规范（块级格式化上下文：block formatting context）"></a>BFC 规范（块级格式化上下文：block formatting context）</h3><h4 id="BFC指的是块级格式化上下文，一个元素形成了BFC之后，那么它内部元素产生的布局不会影响到外部元素，外部元素的布局也不会影响到BFC中的内部元素。一个BFC就像是一个隔离区域，和其他区域互不影响。"><a href="#BFC指的是块级格式化上下文，一个元素形成了BFC之后，那么它内部元素产生的布局不会影响到外部元素，外部元素的布局也不会影响到BFC中的内部元素。一个BFC就像是一个隔离区域，和其他区域互不影响。" class="headerlink" title="BFC指的是块级格式化上下文，一个元素形成了BFC之后，那么它内部元素产生的布局不会影响到外部元素，外部元素的布局也不会影响到BFC中的内部元素。一个BFC就像是一个隔离区域，和其他区域互不影响。"></a>BFC指的是块级格式化上下文，一个元素形成了BFC之后，那么它内部元素产生的布局不会影响到外部元素，外部元素的布局也不会影响到BFC中的内部元素。一个BFC就像是一个隔离区域，和其他区域互不影响。</h4><h4 id="使得当前bfc区域内的元素都变为行内元素（块级格式化上下文）"><a href="#使得当前bfc区域内的元素都变为行内元素（块级格式化上下文）" class="headerlink" title="使得当前bfc区域内的元素都变为行内元素（块级格式化上下文）"></a>使得当前bfc区域内的元素都变为行内元素（块级格式化上下文）</h4><ul>
<li>1.浮动元素不为none；</li>
<li>2.position不为static；</li>
<li>3.display:inline-block；display:table-cell；display:table-caption；</li>
<li>4.overflow 计算值(Computed)不为 visible 的块元素</li>
<li>5.display:inline-flex;</li>
</ul>
<h3 id="IFC指的是行级格式化上下文，它有这样的一些布局规则："><a href="#IFC指的是行级格式化上下文，它有这样的一些布局规则：" class="headerlink" title="IFC指的是行级格式化上下文，它有这样的一些布局规则："></a>IFC指的是行级格式化上下文，它有这样的一些布局规则：</h3><ul>
<li>（1）行级上下文内部的盒子会在水平方向，一个接一个地放置。</li>
<li>（2）当一行不够的时候会自动切换到下一行。</li>
<li>（3）行级上下文的高度由内部最高的内联盒子的高度决定。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/04/15/CSS%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="YeChang Zhang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zyc Blog">
      <meta itemprop="description" content="Hi, welcome to Hexo Coder!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zyc Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/04/15/CSS%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80/" class="post-title-link" itemprop="url">CSS常用垂直居中布局</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-15 20:59:07" itemprop="dateCreated datePublished" datetime="2018-04-15T20:59:07+08:00">2018-04-15</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="CSS垂直居中布局"><a href="#CSS垂直居中布局" class="headerlink" title="CSS垂直居中布局"></a>CSS垂直居中布局</h1><h3 id="line-height-text-align-文字垂直居中"><a href="#line-height-text-align-文字垂直居中" class="headerlink" title="line-height + text-align 文字垂直居中"></a>line-height + text-align 文字垂直居中</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># html</span></span><br><span class="line">&lt;div class=<span class="string">&quot;example&quot;</span>&gt;Lorem ipsam.&lt;/div&gt;</span><br><span class="line"><span class="comment">#css</span></span><br><span class="line">.example&#123;</span><br><span class="line">  width: 400px;</span><br><span class="line">  background: <span class="comment">#afddf3;</span></span><br><span class="line">  line-height: 50px;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="absolute-margin"><a href="#absolute-margin" class="headerlink" title="absolute + margin"></a>absolute + margin</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># html</span></span><br><span class="line">&lt;div class=<span class="string">&quot;parant&quot;</span>&gt;</span><br><span class="line">  &lt;div class=<span class="string">&quot;child&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="comment">#css</span></span><br><span class="line">.parant &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 0;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  left: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  margin: auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#  原理：当元素设置为绝对定位后，假设它是抓不到整体可运用的空间范围，所以margin: auto会失效，但当你设置了top:0;bottom:0;时，绝对定位元素就抓到了可运用的空间了，这时你的margin:auto就生效了。</span></span><br></pre></td></tr></table></figure>

<h3 id="absolute-translate"><a href="#absolute-translate" class="headerlink" title="absolute + translate"></a>absolute + translate</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># html</span></span><br><span class="line">&lt;div class=<span class="string">&quot;parant&quot;</span>&gt;</span><br><span class="line">  &lt;div class=<span class="string">&quot;child&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="comment">#css</span></span><br><span class="line">.parant &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  left: 50%;</span><br><span class="line">  top: 50%;</span><br><span class="line">  transform: translate(-50%, -50%);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 原理：利用绝对定位时的top 与right设置元素的上方跟左方各为50%，再利用transform: translate(-50%, -50%);位移居中元素自身宽与高的50%就能达成居中的目的了。</span></span><br></pre></td></tr></table></figure>

<h3 id="Flex-align-items"><a href="#Flex-align-items" class="headerlink" title="Flex + align-items"></a>Flex + align-items</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># html</span></span><br><span class="line">&lt;div class=<span class="string">&quot;parant&quot;</span>&gt;</span><br><span class="line">  &lt;div class=<span class="string">&quot;child&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="comment">#css</span></span><br><span class="line">.parant &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  justify-content: center;</span><br><span class="line">  align-item: center</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/04/14/JS%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="YeChang Zhang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zyc Blog">
      <meta itemprop="description" content="Hi, welcome to Hexo Coder!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zyc Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/04/14/JS%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">JS字符串常用的操作方法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-14 16:04:43" itemprop="dateCreated datePublished" datetime="2018-04-14T16:04:43+08:00">2018-04-14</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="JS字符串常用的操作方法"><a href="#JS字符串常用的操作方法" class="headerlink" title="JS字符串常用的操作方法"></a>JS字符串常用的操作方法</h1><ul>
<li>str.charAt(index) 返回指定index下标的字符 下标从0开始</li>
<li>str.includes(str1) 方法用于判断str1是否包含在str中，根据情况返回 true 或 false。</li>
<li>str.indexOf(str1) 方法用于判断str1是否包含在str中，返回存在的下标，无则-1</li>
<li>str.replace(regx,str) 按照regx的规则，将符合的替换成str</li>
<li>str.split(‘分隔符’) 将str按照分隔符转化成数组</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">var anyString = <span class="string">&quot;Brave new world&quot;</span>;</span><br><span class="line">console.log(<span class="string">&quot;The character at index 0   is &#x27;&quot;</span> + anyString.charAt(0)   + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">// The character at index 0 is <span class="string">&#x27;B&#x27;</span></span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">// str.includes(str1) 方法用于判断str1是否包含在str中，根据情况返回 <span class="literal">true</span> 或 <span class="literal">false</span>。 区分大小写</span><br><span class="line"><span class="string">&#x27;Blue Whale&#x27;</span>.includes(<span class="string">&#x27;blue&#x27;</span>); // returns <span class="literal">false</span></span><br><span class="line"><span class="string">&#x27;Blue Whale&#x27;</span>.includes(<span class="string">&#x27;Blue&#x27;</span>); // returns <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">//str.indexOf(str1) 方法用于判断str1是否包含在str中，返回存在的下标，无则-1</span><br><span class="line">const paragraph = <span class="string">&#x27;The quick brown fox jumps over the lazy dog. If the dog barked, was it really lazy?&#x27;</span>;</span><br><span class="line"></span><br><span class="line">const searchTerm = <span class="string">&#x27;dog&#x27;</span>;</span><br><span class="line">const indexOfFirst = paragraph.indexOf(searchTerm);</span><br><span class="line">console.log(indexOfFirst); // expected output: <span class="string">&quot;40&quot;</span></span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">// str.replace(regx,str) 按照regx的规则，将符合的替换成str</span><br><span class="line">const p = <span class="string">&#x27;The quick brown fox jumps over the lazy dog. If the dog reacted, was it really lazy?&#x27;</span>;</span><br><span class="line"></span><br><span class="line">console.log(p.replace(<span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;monkey&#x27;</span>));</span><br><span class="line">// expected output: <span class="string">&quot;The quick brown fox jumps over the lazy monkey. If the dog reacted, was it really lazy?&quot;</span></span><br><span class="line">const regex = /Dog/i;</span><br><span class="line">console.log(p.replace(regex, <span class="string">&#x27;ferret&#x27;</span>));</span><br><span class="line">// expected output: <span class="string">&quot;The quick brown fox jumps over the lazy ferret. If the dog reacted, was it really lazy?&quot;</span></span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">//str.split(<span class="string">&#x27;分隔符&#x27;</span>) 将str按照分隔符转化成数组</span><br><span class="line">const str = <span class="string">&#x27;The quick brown fox jumps over the lazy dog.&#x27;</span>;</span><br><span class="line">const words = str.split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">console.log(words[3]);// expected output: <span class="string">&quot;fox&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/04/13/JS%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="YeChang Zhang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zyc Blog">
      <meta itemprop="description" content="Hi, welcome to Hexo Coder!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zyc Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/04/13/JS%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">JS数组常用的操作方法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-13 11:38:05" itemprop="dateCreated datePublished" datetime="2018-04-13T11:38:05+08:00">2018-04-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="JS数组常用的操作方法"><a href="#JS数组常用的操作方法" class="headerlink" title="JS数组常用的操作方法"></a>JS数组常用的操作方法</h2><ul>
<li>Array.length 获取数组长度</li>
<li>Array.shift() Array.unshift()  Array.push() Array.pop()</li>
<li>Array.concat(a1,a2….) 数组合并</li>
<li>Array.reverse() 数组元素颠倒</li>
<li>Array.join(‘拼接字符’) 数组转字符串</li>
<li>Array.indexOf(item) ||  Array.includes(item) 判断Item 是否存在数组里面 </li>
<li>Array.fill(填充val，下标1，下标2) 数组填充</li>
<li>[…new Set(arr)]数组去重 || Array.from(new Set(arr))</li>
<li>Array.slice(begin,end) 这一对象是一个由 begin 和 end 决定的原数组的浅拷贝</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">// Array.length 获取数组长度</span><br><span class="line">const clothing = [<span class="string">&#x27;shoes&#x27;</span>, <span class="string">&#x27;shirts&#x27;</span>, <span class="string">&#x27;socks&#x27;</span>, <span class="string">&#x27;sweaters&#x27;</span>];</span><br><span class="line">console.log(clothing.length); // 4</span><br><span class="line"></span><br><span class="line">// ---------------------------------------</span><br><span class="line"></span><br><span class="line">// Array.<span class="built_in">shift</span>() Array.unshift()  Array.push() Array.pop()</span><br><span class="line">const array1 = [1, 2, 3];</span><br><span class="line">// 往头部插入</span><br><span class="line">array1.unshift(4, 5); </span><br><span class="line">// array1: [4,5,1,2,3] </span><br><span class="line">// 往头部删除</span><br><span class="line">array1.shift() </span><br><span class="line">// array1: [5,1,2,3] </span><br><span class="line">// 往尾部插入</span><br><span class="line">array1.push(4)</span><br><span class="line">//  array1: [5,1,2,3,4] </span><br><span class="line">// 往尾部删除</span><br><span class="line">array1.pop()</span><br><span class="line">// array1: [5,1,2,3]</span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------</span><br><span class="line"></span><br><span class="line">//Array.reverse() 数组元素颠倒</span><br><span class="line">const array1 = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>];</span><br><span class="line">array1.reverse() // [<span class="string">&quot;three&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;one&quot;</span>]</span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------</span><br><span class="line"></span><br><span class="line">// Array.<span class="built_in">join</span>(<span class="string">&#x27;拼接字符&#x27;</span>) 数组转字符串</span><br><span class="line">const elements = [<span class="string">&#x27;Fire&#x27;</span>, <span class="string">&#x27;Air&#x27;</span>, <span class="string">&#x27;Water&#x27;</span>];</span><br><span class="line">console.log(elements.join());</span><br><span class="line">// expected output: <span class="string">&quot;Fire,Air,Water&quot;</span></span><br><span class="line"></span><br><span class="line">console.log(elements.join(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line">// expected output: <span class="string">&quot;FireAirWater&quot;</span></span><br><span class="line"></span><br><span class="line">console.log(elements.join(<span class="string">&#x27;-&#x27;</span>));</span><br><span class="line">// expected output: <span class="string">&quot;Fire-Air-Water&quot;</span></span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------</span><br><span class="line"></span><br><span class="line">// Array.indexOf(item) ||  Array.includes(item) 判断Item 是否存在数组里面</span><br><span class="line">const beasts = [<span class="string">&#x27;ant&#x27;</span>, <span class="string">&#x27;bison&#x27;</span>, <span class="string">&#x27;camel&#x27;</span>, <span class="string">&#x27;duck&#x27;</span>, <span class="string">&#x27;bison&#x27;</span>];</span><br><span class="line"></span><br><span class="line">console.log(beasts.indexOf(<span class="string">&#x27;bison&#x27;</span>));// expected output: 1</span><br><span class="line">console.log(beasts.includes(<span class="string">&#x27;bison&#x27;</span>));// expected output: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------</span><br><span class="line"></span><br><span class="line">// Array.concat(a1,a2....) 数组合并</span><br><span class="line">const array1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">const array2 = [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>];</span><br><span class="line">const array3 = array1.concat(array2);</span><br><span class="line"></span><br><span class="line">console.log(array3);// [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>]</span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------</span><br><span class="line"></span><br><span class="line">// Array.fill(填充val，下标1，下标2) 数组填充</span><br><span class="line">const array1 = [1, 2, 3, 4];</span><br><span class="line">console.log(array1.fill(0, 2, 4)); // [1, 2, 0, 0]</span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------</span><br><span class="line"></span><br><span class="line">//*[...new Set(arr)]数组去重 || Array.from(new Set(arr))</span><br><span class="line"><span class="keyword">function</span> unique (arr) &#123;</span><br><span class="line">  <span class="built_in">return</span> Array.from(new Set(arr))</span><br><span class="line">&#125;</span><br><span class="line">var arr = [1,1,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,15,15,<span class="literal">false</span>,<span class="literal">false</span>, undefined,undefined, null,null, NaN, NaN,<span class="string">&#x27;NaN&#x27;</span>, 0, 0, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line">console.log(unique(arr)) //[1, <span class="string">&quot;true&quot;</span>, <span class="literal">true</span>, 15, <span class="literal">false</span>, undefined, null, NaN, <span class="string">&quot;NaN&quot;</span>, 0, <span class="string">&quot;a&quot;</span>, &#123;&#125;, &#123;&#125;]</span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------</span><br><span class="line"></span><br><span class="line">// Array.slice(begin,end) 这一对象是一个由 begin 和 end 决定的原数组的浅拷贝</span><br><span class="line">const animals = [<span class="string">&#x27;ant&#x27;</span>, <span class="string">&#x27;bison&#x27;</span>, <span class="string">&#x27;camel&#x27;</span>, <span class="string">&#x27;duck&#x27;</span>, <span class="string">&#x27;elephant&#x27;</span>];</span><br><span class="line"></span><br><span class="line">console.log(animals.slice(2));</span><br><span class="line">// expected output: Array [<span class="string">&quot;camel&quot;</span>, <span class="string">&quot;duck&quot;</span>, <span class="string">&quot;elephant&quot;</span>]</span><br><span class="line"></span><br><span class="line">console.log(animals.slice(2, 4));</span><br><span class="line">// expected output: Array [<span class="string">&quot;camel&quot;</span>, <span class="string">&quot;duck&quot;</span>]</span><br><span class="line"></span><br><span class="line">console.log(animals.slice(1, 5));</span><br><span class="line">// expected output: Array [<span class="string">&quot;bison&quot;</span>, <span class="string">&quot;camel&quot;</span>, <span class="string">&quot;duck&quot;</span>, <span class="string">&quot;elephant&quot;</span>]</span><br><span class="line"></span><br><span class="line">console.log(animals.slice(-2));</span><br><span class="line">// expected output: Array [<span class="string">&quot;duck&quot;</span>, <span class="string">&quot;elephant&quot;</span>]</span><br><span class="line"></span><br><span class="line">console.log(animals.slice(2, -1));</span><br><span class="line">// expected output: Array [<span class="string">&quot;camel&quot;</span>, <span class="string">&quot;duck&quot;</span>]</span><br><span class="line"></span><br><span class="line">console.log(animals.slice());</span><br><span class="line">// expected output: Array [<span class="string">&quot;ant&quot;</span>, <span class="string">&quot;bison&quot;</span>, <span class="string">&quot;camel&quot;</span>, <span class="string">&quot;duck&quot;</span>, <span class="string">&quot;elephant&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/04/12/Http-Description/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="YeChang Zhang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zyc Blog">
      <meta itemprop="description" content="Hi, welcome to Hexo Coder!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zyc Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/04/12/Http-Description/" class="post-title-link" itemprop="url">Http版本区别与用户认证</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-12 13:49:53" itemprop="dateCreated datePublished" datetime="2018-04-12T13:49:53+08:00">2018-04-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Http版本区别与用户认证"><a href="#Http版本区别与用户认证" class="headerlink" title="Http版本区别与用户认证"></a><a href="">Http版本区别与用户认证</a></h1><p>HTTP协议(HyperTextTransferProtocol超文本传输协议)基于TCP&#x2F;IP通信协议来传递数据</p>
<h1 id="内容摘要："><a href="#内容摘要：" class="headerlink" title="内容摘要："></a>内容摘要：</h1><ul>
<li>Http版本</li>
<li>Session Cookie</li>
<li>Token</li>
<li>单点登陆</li>
<li>浏览器的缓存机制</li>
</ul>
<h2 id="Http版本"><a href="#Http版本" class="headerlink" title="Http版本"></a><strong>Http版本</strong></h2><h3 id="HTTP-x2F-1-0"><a href="#HTTP-x2F-1-0" class="headerlink" title="HTTP&#x2F;1.0"></a>HTTP&#x2F;1.0</h3><h4 id="每次请求都会打开一个新的TCP链接，收到响应后立即断开"><a href="#每次请求都会打开一个新的TCP链接，收到响应后立即断开" class="headerlink" title="每次请求都会打开一个新的TCP链接，收到响应后立即断开"></a>每次请求都会打开一个新的TCP链接，收到响应后立即断开</h4><h3 id="HTTP-x2F-1-1（增加了缓存控制策略）"><a href="#HTTP-x2F-1-1（增加了缓存控制策略）" class="headerlink" title="HTTP&#x2F;1.1（增加了缓存控制策略）"></a>HTTP&#x2F;1.1（增加了缓存控制策略）</h3><h4 id="1-0主要用Last-Modified和Expires做缓存判断，1-1引入了更多，如-Etag-Cache-Control-keep-alive"><a href="#1-0主要用Last-Modified和Expires做缓存判断，1-1引入了更多，如-Etag-Cache-Control-keep-alive" class="headerlink" title="1.0主要用Last-Modified和Expires做缓存判断，1.1引入了更多，如:Etag Cache-Control keep-alive"></a>1.0主要用Last-Modified和Expires做缓存判断，1.1引入了更多，如:Etag Cache-Control keep-alive</h4><h4 id="1-1默认开启持久连接（同一个TCP连接发送和接受多个http请求-x2F-应答），1-0需要手动开启connection-true"><a href="#1-1默认开启持久连接（同一个TCP连接发送和接受多个http请求-x2F-应答），1-0需要手动开启connection-true" class="headerlink" title="1.1默认开启持久连接（同一个TCP连接发送和接受多个http请求&#x2F;应答），1.0需要手动开启connection:true"></a>1.1默认开启持久连接（同一个TCP连接发送和接受多个http请求&#x2F;应答），1.0需要手动开启connection:true</h4><h4 id="http-pipeline-管道化-，允许在持久连接上可选地使用请求管道。在响应到达之前，可以将多条请求放入队列。当第一条请求通过网络流向服务器时，第二、第三条请求也可以开始发送。在高时延网络条件下，可以减低网络的环回时间提高性能"><a href="#http-pipeline-管道化-，允许在持久连接上可选地使用请求管道。在响应到达之前，可以将多条请求放入队列。当第一条请求通过网络流向服务器时，第二、第三条请求也可以开始发送。在高时延网络条件下，可以减低网络的环回时间提高性能" class="headerlink" title="http pipeline(管道化)，允许在持久连接上可选地使用请求管道。在响应到达之前，可以将多条请求放入队列。当第一条请求通过网络流向服务器时，第二、第三条请求也可以开始发送。在高时延网络条件下，可以减低网络的环回时间提高性能"></a>http pipeline(管道化)，允许在持久连接上可选地使用请求管道。在响应到达之前，可以将多条请求放入队列。当第一条请求通过网络流向服务器时，第二、第三条请求也可以开始发送。在高时延网络条件下，可以减低网络的环回时间提高性能</h4><h4 id="致命缺点-目前大部分浏览器和Web服务器，都关闭了管道化，采用非管道化模式"><a href="#致命缺点-目前大部分浏览器和Web服务器，都关闭了管道化，采用非管道化模式" class="headerlink" title="致命缺点(目前大部分浏览器和Web服务器，都关闭了管道化，采用非管道化模式)"></a>致命缺点(目前大部分浏览器和Web服务器，都关闭了管道化，采用非管道化模式)</h4><h4 id="造成队头阻塞，前一个响应未及时返回，后面的响应会被阻塞"><a href="#造成队头阻塞，前一个响应未及时返回，后面的响应会被阻塞" class="headerlink" title="造成队头阻塞，前一个响应未及时返回，后面的响应会被阻塞"></a><strong>造成队头阻塞，前一个响应未及时返回，后面的响应会被阻塞</strong></h4><h4 id="非管道化-完全串行执行，后一个请求必须在前一个响应之后发送，阻塞发生在客户端，http请求阻塞"><a href="#非管道化-完全串行执行，后一个请求必须在前一个响应之后发送，阻塞发生在客户端，http请求阻塞" class="headerlink" title="非管道化:完全串行执行，后一个请求必须在前一个响应之后发送，阻塞发生在客户端，http请求阻塞"></a>非管道化:完全串行执行，后一个请求必须在前一个响应之后发送，阻塞发生在客户端，http请求阻塞</h4><h4 id="管道化-请求可以并行发出，但响应必须串行返回。后一个响应必须在前一个响应之后。因没有序号表明顺序，只能串行接受。阻塞发生在服务端，http响应阻塞"><a href="#管道化-请求可以并行发出，但响应必须串行返回。后一个响应必须在前一个响应之后。因没有序号表明顺序，只能串行接受。阻塞发生在服务端，http响应阻塞" class="headerlink" title="管道化:请求可以并行发出，但响应必须串行返回。后一个响应必须在前一个响应之后。因没有序号表明顺序，只能串行接受。阻塞发生在服务端，http响应阻塞"></a>管道化:请求可以并行发出，但响应必须串行返回。后一个响应必须在前一个响应之后。因没有序号表明顺序，只能串行接受。阻塞发生在服务端，http响应阻塞</h4><h4 id="管道化的限制。只有幂等的请求比如-GET、HEAD-才能使用-pipelining"><a href="#管道化的限制。只有幂等的请求比如-GET、HEAD-才能使用-pipelining" class="headerlink" title="管道化的限制。只有幂等的请求比如 GET、HEAD 才能使用 pipelining"></a>管道化的限制。只有幂等的请求比如 GET、HEAD 才能使用 pipelining</h4><h3 id="解决"><a href="#解决" class="headerlink" title="解决:"></a><strong>解决:</strong></h3><h4 id="并发TCP连接-浏览器一个域名采用6-8个TCP链接，并发卜请求-一般中小型网站基本用不上，一个页面最多就2-3个接口"><a href="#并发TCP连接-浏览器一个域名采用6-8个TCP链接，并发卜请求-一般中小型网站基本用不上，一个页面最多就2-3个接口" class="headerlink" title="并发TCP连接(浏览器一个域名采用6-8个TCP链接，并发卜请求) 一般中小型网站基本用不上，一个页面最多就2-3个接口"></a>并发TCP连接(浏览器一个域名采用6-8个TCP链接，并发卜请求) 一般中小型网站基本用不上，一个页面最多就2-3个接口</h4><h4 id="域名分片-多个域名，可以建立更多的TCP链接，从而提高LTT请求的并发"><a href="#域名分片-多个域名，可以建立更多的TCP链接，从而提高LTT请求的并发" class="headerlink" title="域名分片(多个域名，可以建立更多的TCP链接，从而提高LTT请求的并发)"></a>域名分片(多个域名，可以建立更多的TCP链接，从而提高LTT请求的并发)</h4><h3 id="Http2-0-（引入帧和流）"><a href="#Http2-0-（引入帧和流）" class="headerlink" title="Http2.0 （引入帧和流）"></a>Http2.0 （引入帧和流）</h3><h4 id="新的二进制格式。-1-x基于文本"><a href="#新的二进制格式。-1-x基于文本" class="headerlink" title="新的二进制格式。 1.x基于文本"></a>新的二进制格式。 1.x基于文本</h4><h4 id="2-0方式-多路复用特性-将多个请求复用同一个tcp通道中，通过二进制分帧并且给每个帧打上流的-ID-去避免依次响应的问题，对方接收到帧之后根据-ID-拼接出流，这样就可以做到乱序响应从而避免请求时的队首阻塞问题"><a href="#2-0方式-多路复用特性-将多个请求复用同一个tcp通道中，通过二进制分帧并且给每个帧打上流的-ID-去避免依次响应的问题，对方接收到帧之后根据-ID-拼接出流，这样就可以做到乱序响应从而避免请求时的队首阻塞问题" class="headerlink" title="2.0方式(多路复用特性) 将多个请求复用同一个tcp通道中，通过二进制分帧并且给每个帧打上流的 ID 去避免依次响应的问题，对方接收到帧之后根据 ID 拼接出流，这样就可以做到乱序响应从而避免请求时的队首阻塞问题"></a>2.0方式(多路复用特性) 将多个请求复用同一个tcp通道中，通过二进制分帧并且给每个帧打上流的 ID 去避免依次响应的问题，对方接收到帧之后根据 ID 拼接出流，这样就可以做到乱序响应从而避免请求时的队首阻塞问题</h4><h4 id="头部压缩-使用encoder压缩"><a href="#头部压缩-使用encoder压缩" class="headerlink" title="头部压缩 使用encoder压缩"></a>头部压缩 使用encoder压缩</h4><h4 id="服务端推送，把客户端index-html需要的资源推送到浏览器并存在缓存中，等index加载时直接会优先读取缓存，而不用向服务器发起请求了"><a href="#服务端推送，把客户端index-html需要的资源推送到浏览器并存在缓存中，等index加载时直接会优先读取缓存，而不用向服务器发起请求了" class="headerlink" title="服务端推送，把客户端index.html需要的资源推送到浏览器并存在缓存中，等index加载时直接会优先读取缓存，而不用向服务器发起请求了"></a>服务端推送，把客户端index.html需要的资源推送到浏览器并存在缓存中，等index加载时直接会优先读取缓存，而不用向服务器发起请求了</h4><h4 id="缺陷：-为了向下兼容，服务端需要确认客户端是http1-x还是2-0，多做了一次TLS链接"><a href="#缺陷：-为了向下兼容，服务端需要确认客户端是http1-x还是2-0，多做了一次TLS链接" class="headerlink" title="缺陷： 为了向下兼容，服务端需要确认客户端是http1.x还是2.0，多做了一次TLS链接"></a><strong>缺陷：</strong> 为了向下兼容，服务端需要确认客户端是http1.x还是2.0，多做了一次TLS链接</h4><h4 id="多个请求是在同一个-TCP-管道中，这样当-HTTP-2-0-出现丢包时，整个-TCP-都要开始等待重传，那么就会阻塞该-TCP。连接中的所有请求。"><a href="#多个请求是在同一个-TCP-管道中，这样当-HTTP-2-0-出现丢包时，整个-TCP-都要开始等待重传，那么就会阻塞该-TCP。连接中的所有请求。" class="headerlink" title="多个请求是在同一个 TCP 管道中，这样当 HTTP 2.0 出现丢包时，整个 TCP 都要开始等待重传，那么就会阻塞该 TCP。连接中的所有请求。"></a>多个请求是在同一个 TCP 管道中，这样当 HTTP 2.0 出现丢包时，整个 TCP 都要开始等待重传，那么就会阻塞该 TCP。连接中的所有请求。</h4><h2 id="Session-Cookie"><a href="#Session-Cookie" class="headerlink" title="Session Cookie"></a><strong>Session Cookie</strong></h2><h4 id="Session-是存储在服务器端的文件里面，借助请求的响应在cookie上携带sessionId，服务器存在有一个sessionId与userId的映射表"><a href="#Session-是存储在服务器端的文件里面，借助请求的响应在cookie上携带sessionId，服务器存在有一个sessionId与userId的映射表" class="headerlink" title="Session 是存储在服务器端的文件里面，借助请求的响应在cookie上携带sessionId，服务器存在有一个sessionId与userId的映射表"></a>Session 是存储在服务器端的文件里面，借助请求的响应在cookie上携带sessionId，服务器存在有一个sessionId与userId的映射表</h4><h4 id="在多机部署的情况下，可用redies做中间层，缓存session，缺点是所有请求都要去redis获取session，为保障redies高可用性，必须做集群"><a href="#在多机部署的情况下，可用redies做中间层，缓存session，缺点是所有请求都要去redis获取session，为保障redies高可用性，必须做集群" class="headerlink" title="在多机部署的情况下，可用redies做中间层，缓存session，缺点是所有请求都要去redis获取session，为保障redies高可用性，必须做集群"></a>在多机部署的情况下，可用redies做中间层，缓存session，缺点是所有请求都要去redis获取session，为保障redies高可用性，必须做集群</h4><h4 id="Cookie-在发起请求和响应请求都会携带已存在的数据往返"><a href="#Cookie-在发起请求和响应请求都会携带已存在的数据往返" class="headerlink" title="Cookie 在发起请求和响应请求都会携带已存在的数据往返"></a>Cookie 在发起请求和响应请求都会携带已存在的数据往返</h4><h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a><strong>Token</strong></h2><h4 id="Token是由前端缓存在浏览器一段密文，一般通过设置请求头传递给后端，后端经过JWT去认证"><a href="#Token是由前端缓存在浏览器一段密文，一般通过设置请求头传递给后端，后端经过JWT去认证" class="headerlink" title="Token是由前端缓存在浏览器一段密文，一般通过设置请求头传递给后端，后端经过JWT去认证"></a>Token是由前端缓存在浏览器一段密文，一般通过设置请求头传递给后端，后端经过JWT去认证</h4><h2 id="单点登陆"><a href="#单点登陆" class="headerlink" title="单点登陆"></a><strong>单点登陆</strong></h2><h4 id="简称SSO，一般定义在多个应用系统中，用户只需登陆一次就可以访问所有互相信任的应用系统"><a href="#简称SSO，一般定义在多个应用系统中，用户只需登陆一次就可以访问所有互相信任的应用系统" class="headerlink" title="简称SSO，一般定义在多个应用系统中，用户只需登陆一次就可以访问所有互相信任的应用系统"></a>简称SSO，一般定义在多个应用系统中，用户只需登陆一次就可以访问所有互相信任的应用系统</h4><h4 id="一般是由登陆中间层应用去控制用户的登陆，一旦登陆成功，以后其它系统携带该用户信息访问进来时重定向并携带该用户的token返回去，再用当前应用系统验证token，向客户端响应当前用户信息"><a href="#一般是由登陆中间层应用去控制用户的登陆，一旦登陆成功，以后其它系统携带该用户信息访问进来时重定向并携带该用户的token返回去，再用当前应用系统验证token，向客户端响应当前用户信息" class="headerlink" title="一般是由登陆中间层应用去控制用户的登陆，一旦登陆成功，以后其它系统携带该用户信息访问进来时重定向并携带该用户的token返回去，再用当前应用系统验证token，向客户端响应当前用户信息"></a>一般是由登陆中间层应用去控制用户的登陆，一旦登陆成功，以后其它系统携带该用户信息访问进来时重定向并携带该用户的token返回去，再用当前应用系统验证token，向客户端响应当前用户信息</h4><h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a><strong>浏览器缓存</strong></h2><h4 id="Web-缓存大致可以分为：数据库缓存、服务器端缓存（代理服务器缓存、CDN-缓存）、浏览器缓存。"><a href="#Web-缓存大致可以分为：数据库缓存、服务器端缓存（代理服务器缓存、CDN-缓存）、浏览器缓存。" class="headerlink" title="Web 缓存大致可以分为：数据库缓存、服务器端缓存（代理服务器缓存、CDN 缓存）、浏览器缓存。"></a>Web 缓存大致可以分为：数据库缓存、服务器端缓存（代理服务器缓存、CDN 缓存）、浏览器缓存。</h4><h4 id="浏览器缓存也包含很多内容：-HTTP-缓存、indexDB、cookie、localstorage-等等。这里我们只讨论-HTTP-缓存相关内容"><a href="#浏览器缓存也包含很多内容：-HTTP-缓存、indexDB、cookie、localstorage-等等。这里我们只讨论-HTTP-缓存相关内容" class="headerlink" title="浏览器缓存也包含很多内容： HTTP 缓存、indexDB、cookie、localstorage 等等。这里我们只讨论 HTTP 缓存相关内容"></a>浏览器缓存也包含很多内容： HTTP 缓存、indexDB、cookie、localstorage 等等。这里我们只讨论 HTTP 缓存相关内容</h4><h4 id="HTTP-缓存术语："><a href="#HTTP-缓存术语：" class="headerlink" title="HTTP 缓存术语："></a>HTTP 缓存术语：</h4><h4 id="缓存命中率：从缓存中得到数据的请求数与所有请求数的比率。理想状态是越高越好。"><a href="#缓存命中率：从缓存中得到数据的请求数与所有请求数的比率。理想状态是越高越好。" class="headerlink" title="* 缓存命中率：从缓存中得到数据的请求数与所有请求数的比率。理想状态是越高越好。"></a>* 缓存命中率：从缓存中得到数据的请求数与所有请求数的比率。理想状态是越高越好。</h4><h4 id="过期内容：超过设置的有效时间，被标记为“陈旧”的内容。通常过期内容不能用于回复客户端的请求，必须重新向源服务器请求新的内容或者验证缓存的内容是否仍然准备。"><a href="#过期内容：超过设置的有效时间，被标记为“陈旧”的内容。通常过期内容不能用于回复客户端的请求，必须重新向源服务器请求新的内容或者验证缓存的内容是否仍然准备。" class="headerlink" title="* 过期内容：超过设置的有效时间，被标记为“陈旧”的内容。通常过期内容不能用于回复客户端的请求，必须重新向源服务器请求新的内容或者验证缓存的内容是否仍然准备。"></a>* 过期内容：超过设置的有效时间，被标记为“陈旧”的内容。通常过期内容不能用于回复客户端的请求，必须重新向源服务器请求新的内容或者验证缓存的内容是否仍然准备。</h4><h4 id="验证：验证缓存中的过期内容是否仍然有效，验证通过的话刷新过期时间。"><a href="#验证：验证缓存中的过期内容是否仍然有效，验证通过的话刷新过期时间。" class="headerlink" title="* 验证：验证缓存中的过期内容是否仍然有效，验证通过的话刷新过期时间。"></a>* 验证：验证缓存中的过期内容是否仍然有效，验证通过的话刷新过期时间。</h4><h4 id="失效：失效就是把内容从缓存中移除。当内容发生改变时就必须移除失效的内容。"><a href="#失效：失效就是把内容从缓存中移除。当内容发生改变时就必须移除失效的内容。" class="headerlink" title="* 失效：失效就是把内容从缓存中移除。当内容发生改变时就必须移除失效的内容。"></a>* 失效：失效就是把内容从缓存中移除。当内容发生改变时就必须移除失效的内容。</h4><h4 id="浏览器缓存主要是-HTTP-协议定义的缓存机制。HTML-meta-标签，例如"><a href="#浏览器缓存主要是-HTTP-协议定义的缓存机制。HTML-meta-标签，例如" class="headerlink" title="浏览器缓存主要是 HTTP 协议定义的缓存机制。HTML meta 标签，例如"></a>浏览器缓存主要是 HTTP 协议定义的缓存机制。HTML meta 标签，例如</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;META HTTP-EQUIV=<span class="string">&quot;Pragma&quot;</span> CONTENT=<span class="string">&quot;no-store&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<h4 id="含义是让浏览器不缓存当前页面。但是代理服务器不解析-HTML-内容，一般应用广泛的是用-HTTP-头信息控制缓存"><a href="#含义是让浏览器不缓存当前页面。但是代理服务器不解析-HTML-内容，一般应用广泛的是用-HTTP-头信息控制缓存" class="headerlink" title="含义是让浏览器不缓存当前页面。但是代理服务器不解析 HTML 内容，一般应用广泛的是用 HTTP 头信息控制缓存"></a>含义是让浏览器不缓存当前页面。但是代理服务器不解析 HTML 内容，一般应用广泛的是用 HTTP 头信息控制缓存</h4><h4 id="浏览器缓存分为强缓存和协商缓存，浏览器加载一个页面的简单流程如下："><a href="#浏览器缓存分为强缓存和协商缓存，浏览器加载一个页面的简单流程如下：" class="headerlink" title="浏览器缓存分为强缓存和协商缓存，浏览器加载一个页面的简单流程如下："></a>浏览器缓存分为强缓存和协商缓存，浏览器加载一个页面的简单流程如下：</h4><h4 id="1-浏览器先根据这个资源的http头信息来判断是否命中强缓存。如果命中则直接加在缓存中的资源，并不会将请求发送到服务器。（强缓存）"><a href="#1-浏览器先根据这个资源的http头信息来判断是否命中强缓存。如果命中则直接加在缓存中的资源，并不会将请求发送到服务器。（强缓存）" class="headerlink" title="1. 浏览器先根据这个资源的http头信息来判断是否命中强缓存。如果命中则直接加在缓存中的资源，并不会将请求发送到服务器。（强缓存）"></a>1. 浏览器先根据这个资源的http头信息来判断是否命中强缓存。如果命中则直接加在缓存中的资源，并不会将请求发送到服务器。（强缓存）</h4><h4 id="2-如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。服务器来判断浏览器本地缓存是否失效。若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源。（协商缓存）"><a href="#2-如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。服务器来判断浏览器本地缓存是否失效。若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源。（协商缓存）" class="headerlink" title="2. 如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。服务器来判断浏览器本地缓存是否失效。若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源。（协商缓存）"></a>2. 如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。服务器来判断浏览器本地缓存是否失效。若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源。（协商缓存）</h4><h4 id="3-如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。（新的请求）"><a href="#3-如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。（新的请求）" class="headerlink" title="3. 如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。（新的请求）"></a>3. 如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。（新的请求）</h4><h4 id="命中强缓存时，浏览器并不会将请求发送给服务器。在Chrome的开发者工具中看到http的返回码是200，但是在Size列会显示为-from-cache-。"><a href="#命中强缓存时，浏览器并不会将请求发送给服务器。在Chrome的开发者工具中看到http的返回码是200，但是在Size列会显示为-from-cache-。" class="headerlink" title="命中强缓存时，浏览器并不会将请求发送给服务器。在Chrome的开发者工具中看到http的返回码是200，但是在Size列会显示为(from cache)。"></a>命中强缓存时，浏览器并不会将请求发送给服务器。在Chrome的开发者工具中看到http的返回码是200，但是在Size列会显示为(from cache)。</h4><h4 id="疑问解答"><a href="#疑问解答" class="headerlink" title="疑问解答"></a><strong>疑问解答</strong></h4><h4 id="为什么我更新我更新前端资源文件，从新打开链接需要刷新一下才能生效呢？"><a href="#为什么我更新我更新前端资源文件，从新打开链接需要刷新一下才能生效呢？" class="headerlink" title="为什么我更新我更新前端资源文件，从新打开链接需要刷新一下才能生效呢？"></a>为什么我更新我更新前端资源文件，从新打开链接需要刷新一下才能生效呢？</h4><h4 id="因为这时候由于你客户端近期在你更新之前是已经访问过该链接，而且缓存过期时间还没失效，这时候命中的是强缓存，当刷新网页时，跳过强缓存，但是会检查协商缓存；浏览器会将资源加载请求发送到服务器，服务器检测到当前加载资源已更新，则将完整的资源返回给浏览器。"><a href="#因为这时候由于你客户端近期在你更新之前是已经访问过该链接，而且缓存过期时间还没失效，这时候命中的是强缓存，当刷新网页时，跳过强缓存，但是会检查协商缓存；浏览器会将资源加载请求发送到服务器，服务器检测到当前加载资源已更新，则将完整的资源返回给浏览器。" class="headerlink" title="因为这时候由于你客户端近期在你更新之前是已经访问过该链接，而且缓存过期时间还没失效，这时候命中的是强缓存，当刷新网页时，跳过强缓存，但是会检查协商缓存；浏览器会将资源加载请求发送到服务器，服务器检测到当前加载资源已更新，则将完整的资源返回给浏览器。"></a>因为这时候由于你客户端近期在你更新之前是已经访问过该链接，而且缓存过期时间还没失效，这时候命中的是强缓存，当刷新网页时，跳过强缓存，但是会检查协商缓存；浏览器会将资源加载请求发送到服务器，服务器检测到当前加载资源已更新，则将完整的资源返回给浏览器。</h4><h4 id="强制刷新页面，浏览器会直接忽略本地的缓存（有缓存也会认为本地没有缓存），在请求中加上字段：Cache-Control-no-cache（或-Pragma-no-cache），发包向服务重新拉取文件。"><a href="#强制刷新页面，浏览器会直接忽略本地的缓存（有缓存也会认为本地没有缓存），在请求中加上字段：Cache-Control-no-cache（或-Pragma-no-cache），发包向服务重新拉取文件。" class="headerlink" title="强制刷新页面，浏览器会直接忽略本地的缓存（有缓存也会认为本地没有缓存），在请求中加上字段：Cache-Control:no-cache（或 Pragma:no-cache），发包向服务重新拉取文件。"></a>强制刷新页面，浏览器会直接忽略本地的缓存（有缓存也会认为本地没有缓存），在请求中加上字段：Cache-Control:no-cache（或 Pragma:no-cache），发包向服务重新拉取文件。</h4><h4 id="Dom-Storage-存储机制"><a href="#Dom-Storage-存储机制" class="headerlink" title="Dom Storage 存储机制"></a>Dom Storage 存储机制</h4><h4 id="sessionStorage浏览器缓存（浏览器关闭则移除）-和-localStorage本地存储（不清楚则永久存在）（5M）"><a href="#sessionStorage浏览器缓存（浏览器关闭则移除）-和-localStorage本地存储（不清楚则永久存在）（5M）" class="headerlink" title="sessionStorage浏览器缓存（浏览器关闭则移除） 和 localStorage本地存储（不清楚则永久存在）（5M）"></a>sessionStorage浏览器缓存（浏览器关闭则移除） 和 localStorage本地存储（不清楚则永久存在）（5M）</h4><h4 id="应用场景：-页面意外关闭的数据恢复"><a href="#应用场景：-页面意外关闭的数据恢复" class="headerlink" title="应用场景： 页面意外关闭的数据恢复"></a>应用场景： 页面意外关闭的数据恢复</h4><h4 id="Application-Cache-机制"><a href="#Application-Cache-机制" class="headerlink" title="Application Cache 机制"></a>Application Cache 机制</h4><h4 id="浏览器在首次加载-HTML-文件时，会解析-manifest-属性，-lt-html-manifest-quot-demo-html-appcache-quot-gt-并读取-manifest-文件，获取-Section：CACHE-MANIFEST-下要缓存的文件列表，再对文件缓存。（一般游戏的应用的比较多）"><a href="#浏览器在首次加载-HTML-文件时，会解析-manifest-属性，-lt-html-manifest-quot-demo-html-appcache-quot-gt-并读取-manifest-文件，获取-Section：CACHE-MANIFEST-下要缓存的文件列表，再对文件缓存。（一般游戏的应用的比较多）" class="headerlink" title="浏览器在首次加载 HTML 文件时，会解析 manifest 属性，&lt;html manifest=&quot;demo_html.appcache&quot;&gt; 并读取 manifest 文件，获取 Section：CACHE MANIFEST 下要缓存的文件列表，再对文件缓存。（一般游戏的应用的比较多）"></a>浏览器在首次加载 HTML 文件时，会解析 manifest 属性，<code>&lt;html manifest=&quot;demo_html.appcache&quot;&gt;</code> 并读取 manifest 文件，获取 Section：CACHE MANIFEST 下要缓存的文件列表，再对文件缓存。（一般游戏的应用的比较多）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line"><span class="comment"># 2012-02-21 v1.0.0</span></span><br><span class="line">/theme.css</span><br><span class="line">/logo.gif</span><br><span class="line">/main.js</span><br><span class="line"> </span><br><span class="line">NETWORK:</span><br><span class="line">login.asp</span><br><span class="line"> </span><br><span class="line">FALLBACK:</span><br><span class="line">/html/ /offline.html </span><br></pre></td></tr></table></figure>
<h4 id="AppCache-在首次加载生成后，也有更新机制。被缓存的文件如果要更新，需要更新-manifest-文件。因为浏览器在下次加载时，除了会默认使用缓存外，还会在后台检查-manifest-文件有没有修改（byte-by-byte-。发现有修改，就会重新获取-manifest-文件，对-Section：CACHE-MANIFEST-下文件列表检查更新。manifest-文件与缓存文件的检查更新也遵守浏览器缓存机制。"><a href="#AppCache-在首次加载生成后，也有更新机制。被缓存的文件如果要更新，需要更新-manifest-文件。因为浏览器在下次加载时，除了会默认使用缓存外，还会在后台检查-manifest-文件有没有修改（byte-by-byte-。发现有修改，就会重新获取-manifest-文件，对-Section：CACHE-MANIFEST-下文件列表检查更新。manifest-文件与缓存文件的检查更新也遵守浏览器缓存机制。" class="headerlink" title="AppCache 在首次加载生成后，也有更新机制。被缓存的文件如果要更新，需要更新 manifest 文件。因为浏览器在下次加载时，除了会默认使用缓存外，还会在后台检查 manifest 文件有没有修改（byte by byte)。发现有修改，就会重新获取 manifest 文件，对 Section：CACHE MANIFEST 下文件列表检查更新。manifest 文件与缓存文件的检查更新也遵守浏览器缓存机制。"></a>AppCache 在首次加载生成后，也有更新机制。被缓存的文件如果要更新，需要更新 manifest 文件。因为浏览器在下次加载时，除了会默认使用缓存外，还会在后台检查 manifest 文件有没有修改（byte by byte)。发现有修改，就会重新获取 manifest 文件，对 Section：CACHE MANIFEST 下文件列表检查更新。manifest 文件与缓存文件的检查更新也遵守浏览器缓存机制。</h4><h3 id="移动端-Web-加载性能（缓存）优化"><a href="#移动端-Web-加载性能（缓存）优化" class="headerlink" title="移动端 Web 加载性能（缓存）优化"></a><strong>移动端 Web 加载性能（缓存）优化</strong></h3><h4 id="通过对一些-H5页面进行调试及抓包发现，每次加载一个-H5页面，都会有较多的请求。除了-HTML-主-URL-自身的请求外，HTML外部引用的-JS、CSS、字体文件、图片都是一个独立的-HTTP-请求，每一个请求都串行的（可能有连接复用）。这么多请求串起来，再加上浏览器解析、渲染的时间，Web-整体的加载时间变得较长；请求文件越多，消耗的流量也会越多。我们可综合使用上面说到几种缓存机制，来帮助我们优化-Web-的加载性能。"><a href="#通过对一些-H5页面进行调试及抓包发现，每次加载一个-H5页面，都会有较多的请求。除了-HTML-主-URL-自身的请求外，HTML外部引用的-JS、CSS、字体文件、图片都是一个独立的-HTTP-请求，每一个请求都串行的（可能有连接复用）。这么多请求串起来，再加上浏览器解析、渲染的时间，Web-整体的加载时间变得较长；请求文件越多，消耗的流量也会越多。我们可综合使用上面说到几种缓存机制，来帮助我们优化-Web-的加载性能。" class="headerlink" title="通过对一些 H5页面进行调试及抓包发现，每次加载一个 H5页面，都会有较多的请求。除了 HTML 主 URL 自身的请求外，HTML外部引用的 JS、CSS、字体文件、图片都是一个独立的 HTTP 请求，每一个请求都串行的（可能有连接复用）。这么多请求串起来，再加上浏览器解析、渲染的时间，Web 整体的加载时间变得较长；请求文件越多，消耗的流量也会越多。我们可综合使用上面说到几种缓存机制，来帮助我们优化 Web 的加载性能。"></a>通过对一些 H5页面进行调试及抓包发现，每次加载一个 H5页面，都会有较多的请求。除了 HTML 主 URL 自身的请求外，HTML外部引用的 JS、CSS、字体文件、图片都是一个独立的 HTTP 请求，每一个请求都串行的（可能有连接复用）。这么多请求串起来，再加上浏览器解析、渲染的时间，Web 整体的加载时间变得较长；请求文件越多，消耗的流量也会越多。我们可综合使用上面说到几种缓存机制，来帮助我们优化 Web 的加载性能。</h4>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YeChang Zhang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
