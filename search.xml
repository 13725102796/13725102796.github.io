<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue 组件通讯的方法</title>
      <link href="/2021/03/13/Vue-%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2021/03/13/Vue-%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue-组件通讯的方法"><a href="#Vue-组件通讯的方法" class="headerlink" title="Vue 组件通讯的方法"></a>Vue 组件通讯的方法</h1><ul><li>props和$emit</li><li>$on&#x2F;$emit</li><li>$parent&#x2F;$childen &amp; ref</li><li>Vuex</li></ul><h2 id="props和-emit"><a href="#props和-emit" class="headerlink" title="props和$emit"></a>props和$emit</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=<span class="string">&quot;home&quot;</span>&gt;</span><br><span class="line">    &lt;div&gt;我是父组件&lt;/div&gt;</span><br><span class="line">    &lt;Child :msg=<span class="string">&quot;msg&quot;</span> v-on:changed=<span class="string">&quot;changed&quot;</span>/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Child from <span class="string">&#x27;@/components/Child.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  name: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Child</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">data</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      msg: <span class="string">&#x27;child&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changed(e) &#123;</span><br><span class="line">      this.msg = e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ------- child component-------------</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p @click=<span class="string">&quot;change&quot;</span>&gt;</span><br><span class="line">          我是子组件:传递来的消息是：&#123;&#123;msg&#125;&#125;</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  name: <span class="string">&#x27;Child&#x27;</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    msg: &#123;</span><br><span class="line">      <span class="built_in">type</span>: String,</span><br><span class="line">      default: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">change</span></span>() &#123;</span><br><span class="line">      this.<span class="variable">$emit</span>(<span class="string">&#x27;changed&#x27;</span>,<span class="string">&#x27;向父组件传值&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="on-x2F-emit"><a href="#on-x2F-emit" class="headerlink" title="$on&#x2F;$emit"></a>$on&#x2F;$emit</h2><p>通过一个空的vue实例作为中央事件总线，用它来触发和监听事件，跨级组件之间的通讯</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ------  bus --------------</span></span><br><span class="line">import Vue from <span class="string">&#x27;vue&#x27;</span></span><br><span class="line">var Event = new Vue()</span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> <span class="function"><span class="title">sendSDKLoadend</span></span> () &#123;</span><br><span class="line">  Event.<span class="variable">$emit</span>(<span class="string">&#x27;loadendSDK&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> monitorSDKLoadend(callback) &#123;</span><br><span class="line">  Event.<span class="variable">$on</span>(<span class="string">&#x27;loadendSDK&#x27;</span>, callback)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 当某个页面触发了sendSDKLoadend()时，绑定了monitorSDKLoadend(fn) 的地方，fn会执行</span></span><br></pre></td></tr></table></figure><h2 id="parent-x2F-childen，访问父-x2F-子实例-和-ref获取组件实例"><a href="#parent-x2F-childen，访问父-x2F-子实例-和-ref获取组件实例" class="headerlink" title="$parent&#x2F;$childen，访问父&#x2F;子实例 和 ref获取组件实例"></a>$parent&#x2F;$childen，访问父&#x2F;子实例 和 ref获取组件实例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在组件上绑定 ref</span></span><br><span class="line">&lt;Child ref=<span class="string">&quot;child&quot;</span> /&gt;</span><br><span class="line"><span class="comment"># 通过 this.$refs.child 获取子组件的实例</span></span><br><span class="line">this.<span class="variable">$refs</span>.child</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子组件通过 $parent 获取父组件的实例</span></span><br><span class="line">this.<span class="variable">$parent</span></span><br></pre></td></tr></table></figure><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p>通过 this.$store.dispatch(‘actionName’,params) 触发Action去通知Mutation更新State的值。所有引用改State的值的组件都会更新</p>]]></content>
      
      
      
        <tags>
            
            <tag> Vue 组件通讯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP 详解</title>
      <link href="/2020/04/14/TCP-IP-%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/04/14/TCP-IP-%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-TCP-和-UDP"><a href="#1-TCP-和-UDP" class="headerlink" title="1. TCP 和 UDP"></a>1. TCP 和 UDP</h1><h3 id="用户数据报协议-UDP"><a href="#用户数据报协议-UDP" class="headerlink" title="用户数据报协议 UDP"></a>用户数据报协议 UDP</h3><ul><li>UDP 在传送数据之前不需要先建立连接，远程主机在收到 UDP 报文后，不需要给出任何确认。</li><li>虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如：QQ 语音、 QQ 视频 、直播等等</li></ul><h1 id="2-传输控制协议-TCP"><a href="#2-传输控制协议-TCP" class="headerlink" title="2.传输控制协议 TCP"></a>2.传输控制协议 TCP</h1><ul><li>TCP 提供 面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。</li><li>TCP 不提供广播或多播服务。由于 TCP 要提供 可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、流量控制、拥塞控制机制，在数据传完后，还会四次挥手断开连接用来节约系统资源），这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源</li><li>TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</li></ul><h1 id="TCP-三次握手建立连接"><a href="#TCP-三次握手建立连接" class="headerlink" title="TCP 三次握手建立连接"></a>TCP 三次握手建立连接</h1><ul><li><ol><li>第一次握手：客户端向服务端发送一个 SYN 报文（SYN &#x3D; 1），此时客户端处于 SYN_Send 状态（在发送连接请求后等待匹配的连接请求）。</li></ol></li><li><ol start="2"><li>第二次握手：服务器收到客户端的 SYN 报文之后，会发送 ACK 通知客户端我已收到。 此时服务器处于 SYN_REVD 的状态（收到和发送一个连接请求后等待对连接请求的确认）。</li></ol></li><li><ol start="3"><li>客户端收到服务器端响应的 ACK 报文之后，会发送一个 ack 报文，，表示已经收到了服务端发来的通知，此时客户端处于 Establised 状态。服务器收到 ack 报文之后，也处于 Establised 状态（代表一个打开的连接，数据可以传送给用户），至此，双方建立起了 TCP 连接。</li></ol></li></ul><h1 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h1><p>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</p><h1 id="三次握手过程中可以携带数据吗"><a href="#三次握手过程中可以携带数据吗" class="headerlink" title="三次握手过程中可以携带数据吗"></a>三次握手过程中可以携带数据吗</h1><p>第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手绝对不可以携带数据假如第一次握手可以携带数据的话，容易被攻击。<br>SYN 洪泛攻击<br>就是 Client 在短时间内伪造大量不存在的 IP 地址，并向 Server 不断地发送 SYN 包，Server 则回复确认包，并等待 Client 确认，由于源地址不存在，因此 Server 需要不断重发直至超时，这些伪造的 SYN 包将长时间占用半连接队列，导致正常的 SYN 请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。</p><h1 id="TCP-四次挥手释放连接"><a href="#TCP-四次挥手释放连接" class="headerlink" title="TCP 四次挥手释放连接"></a>TCP 四次挥手释放连接</h1><p>建立一个 TCP 连接需要三次握手，而终止一个 TCP 连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这是由于 TCP 的半关闭（half-close）特性造成的，TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p><ul><li>第一次挥手：客户端发送一个 FIN 报文主动关闭 TCP 连接。此时客户端处于 FIN_WAIT1 状态（等待远程TCP的连接中断请求，或先前的连接中断请求的确认；），等待服务端的确认。</li><li>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态（等待从本地用户发来的连接中断请求）。</li></ul><h2 id="此时的-TCP-处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN-WAIT2（终止等待-2）状态，等待服务端发出的连接释放报文段。"><a href="#此时的-TCP-处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN-WAIT2（终止等待-2）状态，等待服务端发出的连接释放报文段。" class="headerlink" title="此时的 TCP 处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待 2）状态，等待服务端发出的连接释放报文段。"></a>此时的 TCP 处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待 2）状态，等待服务端发出的连接释放报文段。</h2><ul><li>第三次挥手：如果服务端也想断开连接了（没有要向客户端发出的数据），和客户端的第一次挥手一样，发送 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态，等待客户端的确认</li><li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答（ack &#x3D; w+1），且把服务端的序列值 +1 作为自己 ACK 报文的序号值（seq&#x3D;u+1），此时客户端处于 TIME_WAIT（时间等待）状态。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>三次握手，为了测试双方能够正常发送，接收<br>第一次握手： 客户端发送SYN服务器 ，服务器正常接受   客户端发送正常 服务器接收正常<br>第二次握手： 服务器发送ACK到客户端，客户端正常接受  服务器发送正常 客户端接收正常<br>第三次握手： 客户端向服务器发送正式链接，至此，双方建立起了 TCP 连接</p><p>四次挥手，因为TCP半关闭的特性<br>TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。<br>A 和 B 打电话，通话即将结束后，A 说 “我没啥要说的了”，B 回答 “我知道了”，于是 A 向 B 的连接释放了。但是 B 可能还会有要说的话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，于是 B 向 A 的连接释放了，</p>]]></content>
      
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue v-model的实践</title>
      <link href="/2020/04/13/Vue-v-model%E7%9A%84%E5%AE%9E%E8%B7%B5/"/>
      <url>/2020/04/13/Vue-v-model%E7%9A%84%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue-v-model的实践"><a href="#Vue-v-model的实践" class="headerlink" title="Vue v-model的实践"></a>Vue v-model的实践</h1><p>v-model 只是语法糖，主要是通过input事件来触发input标签value值来实现我们说的“双向数据绑定”,其实它还是单向数据流。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;value&quot;</span> /&gt;</span><br><span class="line"><span class="comment">#等价于</span></span><br><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">&quot;text&quot;</span> :value=<span class="string">&quot;value&quot;</span> @input=v=&gt;<span class="variable">$emit</span>(<span class="string">&#x27;input&#x27;</span>, v)/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义组件实现v-model</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">&quot;text&quot;</span> :value=<span class="string">&quot;value&quot;</span> @input=<span class="string">&quot;handleInput&quot;</span> :placeholder=<span class="string">&quot;placehodler&quot;</span> /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="built_in">export</span> default &#123;</span><br><span class="line">    name: <span class="string">&#x27;kInput&#x27;</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">        value: [<span class="string">&#x27;String&#x27;</span>, <span class="string">&#x27;Number&#x27;</span>],</span><br><span class="line">        placeholder: String</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        handleInput(<span class="variable">$event</span>) &#123;</span><br><span class="line">            // 通过input标签的原生事件input将值emit出去，以达到值得改变实现双向绑定</span><br><span class="line">            this.<span class="variable">$emit</span>(<span class="string">&#x27;input&#x27;</span>, <span class="variable">$event</span>.target.value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Vue v-model </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS微任务和宏任务的执行顺序</title>
      <link href="/2019/06/14/JS%E5%BE%AE%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%AE%8F%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
      <url>/2019/06/14/JS%E5%BE%AE%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%AE%8F%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>浏览器是多线程的，JS是单线程的（浏览器只分配一个线程来执行JS）意味着js每次只能执行一个任务，那么，遇到异步任务首先会放到任务队列中（执行栈），先执行主线程中的任务，当主线程中的任务被执行完后，在回过来依次将执行任务队列中任务放入主线程去执行。</p><p>js中的任务分为：同步任务和异步任务，而异步任务又可以分为微任务和宏任务</p><p>宏任务：macro task</p><ul><li>定时器(setTimeout,setInterval,setImmediate)</li><li>事件绑定(onClick)</li><li>ajax</li><li>回调函数    </li><li>nodejs中的fs I&#x2F;O操作</li></ul><p>微任务: micro task</p><ul><li>Promsie(async&#x2F;await)</li><li>process.nextTick</li><li>MutationObserver</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">asy1</span></span>()&#123;</span><br><span class="line">  await console.log(<span class="string">&#x27;asy1&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">console.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">  console.log(<span class="string">&#x27;time out&#x27;</span>)</span><br><span class="line">&#125;,0)</span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">  setTimeout(()=&gt;&#123;</span><br><span class="line">    console.log(<span class="string">&#x27;宏任务中的宏任务&#x27;</span>)</span><br><span class="line">  &#125;,0)</span><br><span class="line">  Promise.resolve().<span class="keyword">then</span>(()=&gt;&#123;</span><br><span class="line">    console.log(<span class="string">&#x27;timeOut+promise1&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  console.log(<span class="string">&#x27;timeOut+promise1之前还是之后&#x27;</span>)</span><br><span class="line">&#125;,0)</span><br><span class="line"></span><br><span class="line">asy1()</span><br><span class="line">Promise.resolve().<span class="keyword">then</span>(()=&gt;&#123;</span><br><span class="line">  console.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">&#125;).<span class="keyword">then</span>(()=&gt;&#123;</span><br><span class="line">  Promise.resolve().<span class="keyword">then</span>(()=&gt;&#123;</span><br><span class="line">    console.log(<span class="string">&#x27;promise1+promise1&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  setTimeout(()=&gt;&#123;</span><br><span class="line">    console.log(<span class="string">&#x27;promise time out&#x27;</span>)</span><br><span class="line">  &#125;,0)</span><br><span class="line">  console.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># script start</span></span><br><span class="line"><span class="comment"># asy1</span></span><br><span class="line"><span class="comment"># script end</span></span><br><span class="line"><span class="comment"># promise1</span></span><br><span class="line"><span class="comment"># promise2</span></span><br><span class="line"><span class="comment"># promise1+promise1</span></span><br><span class="line"><span class="comment"># time out</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先执行微任务，执行完所有微任务之后（微任务中产生的微任务也要执行完），再执行宏任务，（宏任务中产生的微任务要优先执行）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 微任务 宏任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器重排和重绘</title>
      <link href="/2019/05/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8D%E6%8E%92%E5%92%8C%E9%87%8D%E7%BB%98/"/>
      <url>/2019/05/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8D%E6%8E%92%E5%92%8C%E9%87%8D%E7%BB%98/</url>
      
        <content type="html"><![CDATA[<h1 id="重排和重绘区别"><a href="#重排和重绘区别" class="headerlink" title="重排和重绘区别"></a>重排和重绘区别</h1><p>重排顾名思义就是重新排列，意味着重新计算文档中元素的位置和几何信息（元素的位置、大小），会影响部分或整个页面的布局。元素的重排将导致DOM中所有子元素和其他兄弟元素重新排列。<br>重绘是更改元素的可见性，但是不影响元素的布局。例如可见性、背景色、轮廓等。</p><h1 id="什么会触发重排和重绘？"><a href="#什么会触发重排和重绘？" class="headerlink" title="什么会触发重排和重绘？"></a>什么会触发重排和重绘？</h1><ul><li>添加、删除、更新DOM节点都会触发重排</li><li>使用 display: none 隐藏元素会触发重排和重绘</li><li>使用 visibility:hidden 只会引起重绘，因为没有布局和位置的变更</li><li>移动节点、添加动画都会触发重排和重绘</li><li>改变浏览器窗口大小会触发重排</li><li>更改元素字体大小会触发重排</li><li>添加或者删除样式会触发重排和重绘</li><li>操作 DOM 脚本是昂贵的操作，因为每次 document 或者 document的部分改变时，它们都会重新计算</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var bodyStyle = document.body.style; // cache</span><br><span class="line"></span><br><span class="line">bodyStyle.padding = <span class="string">&quot;20px&quot;</span>; // reflow, repaint</span><br><span class="line">bodyStyle.border = <span class="string">&quot;10px solid red&quot;</span>; // reflow, repaint</span><br><span class="line"></span><br><span class="line">bodyStyle.color = <span class="string">&quot;blue&quot;</span>; // repaint only, no dimensions changed</span><br><span class="line">bstyle.backgroundColor = <span class="string">&quot;#cc0000&quot;</span>; // repaint</span><br><span class="line"></span><br><span class="line">bodyStyle.fontSize = <span class="string">&quot;2em&quot;</span>; // reflow, repaint</span><br><span class="line"></span><br><span class="line">// new DOM element - reflow, repaint</span><br><span class="line">document.body.appendChild(document.createTextNode(<span class="string">&#x27;Hello!&#x27;</span>));</span><br></pre></td></tr></table></figure><h1 id="重排一定触发重绘，重绘不一定触发重排"><a href="#重排一定触发重绘，重绘不一定触发重排" class="headerlink" title="重排一定触发重绘，重绘不一定触发重排"></a>重排一定触发重绘，重绘不一定触发重排</h1><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><ul><li>尽量批次改变元素css属性</li><li>将动画的元素设置position属性为absolute或fixed，这样使元素脱离文本流，不会影响渲染树。</li><li>当多个添加DOM元素时，使用文本碎片fragment（隐藏的元素不再渲染树中，）只触发一次重排重绘</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 重排 重绘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 与 CSS 是否阻塞 DOM</title>
      <link href="/2019/04/14/JS-%E4%B8%8E-CSS-%E6%98%AF%E5%90%A6%E9%98%BB%E5%A1%9E-DOM/"/>
      <url>/2019/04/14/JS-%E4%B8%8E-CSS-%E6%98%AF%E5%90%A6%E9%98%BB%E5%A1%9E-DOM/</url>
      
        <content type="html"><![CDATA[<p>浏览器的解析渲染过程，解析DOM生成DOM Tree，解析CSS生成CSSOM Tree，两者结合生成render tree渲染树，最后浏览器根据渲染树渲染至页面。</p><h1 id="所以CSS不会阻塞DOM的解析，因为两者是并行解析的。"><a href="#所以CSS不会阻塞DOM的解析，因为两者是并行解析的。" class="headerlink" title="所以CSS不会阻塞DOM的解析，因为两者是并行解析的。"></a>所以CSS不会阻塞DOM的解析，因为两者是并行解析的。</h1><p>但是由于render tree的生成是依赖DOM Tree和CSSOM Tree的，因此CSS必然会阻塞DOM的渲染。<br>最终生成页面依赖的渲染数 是由DOM Tree和CSSOM Tree组成的，如果CSSOM Tree阻塞了，那么DOM的渲染也就没那么快完成</p><h1 id="JS-会阻塞-DOM-解析"><a href="#JS-会阻塞-DOM-解析" class="headerlink" title="JS 会阻塞 DOM 解析"></a>JS 会阻塞 DOM 解析</h1><p>首先浏览器无法知晓JS的具体内容，倘若先解析DOM，万一JS内部全部删除掉DOM，那么浏览器就白忙活了，所以就干脆暂停解析DOM，等到JS执行完成再继续解析。<br>开发者可以优先考虑使用defer的方式，其次是async方式让页面的JS进行异步执行，</p><ul><li>defer 异步加载， 加载完后会等待Html标签全部解析完才去执行<br>比如第三方sdk 不影响页面形式的js 都可以延时解析</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> CSS JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器缓存机制</title>
      <link href="/2019/04/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/04/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h1><h3 id="浏览器缓存分为强缓存和协商缓存，浏览器加载一个页面的简单流程如下："><a href="#浏览器缓存分为强缓存和协商缓存，浏览器加载一个页面的简单流程如下：" class="headerlink" title="浏览器缓存分为强缓存和协商缓存，浏览器加载一个页面的简单流程如下："></a>浏览器缓存分为强缓存和协商缓存，浏览器加载一个页面的简单流程如下：</h3><ul><li>浏览器先根据这个资源的http头信息来判断是否命中强缓存。如果命中则直接加在缓存中的资源，并不会将请求发送到服务器。（强缓存）</li><li>如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。服务器来判断浏览器本地缓存是否失效。若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源。（协商缓存）</li><li>如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。（新的请求）</li></ul><h3 id="命中强缓存时，浏览器并不会将请求发送给服务器。code-200-Size：from-cache"><a href="#命中强缓存时，浏览器并不会将请求发送给服务器。code-200-Size：from-cache" class="headerlink" title="命中强缓存时，浏览器并不会将请求发送给服务器。code: 200 Size：from cache"></a>命中强缓存时，浏览器并不会将请求发送给服务器。code: 200 Size：from cache</h3><h3 id="利用http的返回头中的Expires或者Cache-Control两个字段来控制的缓存的过期时间"><a href="#利用http的返回头中的Expires或者Cache-Control两个字段来控制的缓存的过期时间" class="headerlink" title="利用http的返回头中的Expires或者Cache-Control两个字段来控制的缓存的过期时间"></a>利用http的返回头中的Expires或者Cache-Control两个字段来控制的缓存的过期时间</h3><h3 id="若未命中强缓存，则浏览器会将请求发送至服务器。服务器根据http头信息中的Last-Modify-x2F-If-Modify-Since或Etag-x2F-If-None-Match来判断是否命中协商缓存。如果命中，则http返回码为304，浏览器从缓存中加载资源。"><a href="#若未命中强缓存，则浏览器会将请求发送至服务器。服务器根据http头信息中的Last-Modify-x2F-If-Modify-Since或Etag-x2F-If-None-Match来判断是否命中协商缓存。如果命中，则http返回码为304，浏览器从缓存中加载资源。" class="headerlink" title="若未命中强缓存，则浏览器会将请求发送至服务器。服务器根据http头信息中的Last-Modify&#x2F;If-Modify-Since或Etag&#x2F;If-None-Match来判断是否命中协商缓存。如果命中，则http返回码为304，浏览器从缓存中加载资源。"></a>若未命中强缓存，则浏览器会将请求发送至服务器。服务器根据http头信息中的Last-Modify&#x2F;If-Modify-Since或Etag&#x2F;If-None-Match来判断是否命中协商缓存。如果命中，则http返回码为304，浏览器从缓存中加载资源。</h3>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强缓存 协商缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 开发一个按钮组件</title>
      <link href="/2019/02/13/Vue-%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E6%8C%89%E9%92%AE%E7%BB%84%E4%BB%B6/"/>
      <url>/2019/02/13/Vue-%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E6%8C%89%E9%92%AE%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue-开发一个按钮组件"><a href="#Vue-开发一个按钮组件" class="headerlink" title="Vue 开发一个按钮组件"></a>Vue 开发一个按钮组件</h1><p>解决思路：<br>通过父子组件通讯（$refs 和 props）<br>props接受参数, $refs调用子组件的方法<br>来达到点击提交改变按钮状态，如果不成功则取消按钮状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;!-- use plane  --&gt;</span><br><span class="line">&lt;!-- 传入bgColor改变按钮背景色 --&gt;</span><br><span class="line">&lt;!-- state切换button的状态 调用cancel()可以切换 --&gt;</span><br><span class="line">&lt;!-- text为按钮文字 --&gt;</span><br><span class="line">  &lt;div class=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">    &lt;button  </span><br><span class="line">      @click=<span class="string">&quot;confirm&quot;</span></span><br><span class="line">      :disabled=<span class="string">&quot;state&quot;</span> </span><br><span class="line">      class=<span class="string">&quot;confirm&quot;</span> </span><br><span class="line">      :style=<span class="string">&quot;&#123;background: btnData.bgColor&#125;&quot;</span></span><br><span class="line">    &gt;&#123;&#123;text&#125;&#125;&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      text: this.btnData.text,</span><br><span class="line">      state: <span class="literal">false</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    btnData: &#123;</span><br><span class="line">      types: Array,</span><br><span class="line">      <span class="function"><span class="title">default</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">          text: <span class="string">&#x27;确认&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">confirm</span></span>()&#123;</span><br><span class="line">      this.text += <span class="string">&#x27;...&#x27;</span></span><br><span class="line">      this.state = <span class="literal">true</span></span><br><span class="line">      //这里是激活父组件的事件，因为子组件是不会冒泡到父组件上的，必须手动调用<span class="variable">$emit</span></span><br><span class="line">      //相对应父组件要在调用该组件的时候，将其挂载到上面</span><br><span class="line">      this.<span class="variable">$emit</span>(<span class="string">&quot;confirm&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">cancel</span></span>()&#123;</span><br><span class="line">      this.text = this.btnData.text</span><br><span class="line">      this.state = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style lang=<span class="string">&quot;less&quot;</span> scoped&gt;</span><br><span class="line">.confirm &#123;</span><br><span class="line">  border: none;</span><br><span class="line">  color: <span class="comment">#fff;</span></span><br><span class="line">  width: 100%;</span><br><span class="line">  padding: 1rem 0;</span><br><span class="line">  border-radius: 4px;</span><br><span class="line">  font-size: 1.6rem;</span><br><span class="line">  background: <span class="comment">#5da1fd;</span></span><br><span class="line">  &amp;:focus &#123;</span><br><span class="line">    outline: none;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>在页面中调用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=<span class="string">&quot;btn-box&quot;</span>&gt;</span><br><span class="line">      &lt;Btn </span><br><span class="line">        :btnData=<span class="string">&quot;&#123;text: &#x27;确认注册&#x27;&#125;&quot;</span></span><br><span class="line">        &lt;!--这里就要挂载<span class="variable">$emit</span>调用的事件 @confirm=<span class="string">&quot;想要调用事件的名字&quot;</span>--&gt;</span><br><span class="line">        @confirm=<span class="string">&quot;confirm&quot;</span></span><br><span class="line">        ref=<span class="string">&quot;btn&quot;</span></span><br><span class="line">      &gt;&lt;/Btn&gt;</span><br><span class="line">    &lt;/div&gt; </span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Btn from <span class="string">&#x27;@/components/button&#x27;</span></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Btn</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">confirm</span></span>()&#123;</span><br><span class="line">      <span class="keyword">if</span>(!this.companyName)&#123;</span><br><span class="line">        this.<span class="variable">$toast</span>(<span class="string">&quot;公司名不能为空&quot;</span>)  </span><br><span class="line">        this.<span class="variable">$refs</span>.btn.cancel()</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在这里，要注意一些细节：</p><ul><li><ol><li>button组件形成之后和其它div元素的间距，如果是在组件内定死是很难复用的。</li></ol></li><li><ol start="2"><li>在复用的时候，在父组件中是改变不了子组件的样式的，如果要强制更改，单独写一个并去掉scoped。</li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Vue button </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端1px像素</title>
      <link href="/2018/05/26/%E7%A7%BB%E5%8A%A8%E7%AB%AF1px%E5%83%8F%E7%B4%A0/"/>
      <url>/2018/05/26/%E7%A7%BB%E5%8A%A8%E7%AB%AF1px%E5%83%8F%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="移动端1px像素起源"><a href="#移动端1px像素起源" class="headerlink" title="移动端1px像素起源"></a>移动端1px像素起源</h1><p>在移动端，css中的1px并不等于移动设备的1px，因为手机屏幕有不同的像素密度。window中的devicePixelRatio就是反应css中像素与真实像素的比例，也就是设备物理像素和设备独立像素的比例，也就是 devicePixelRatio &#x3D; 物理像素 &#x2F; 独立像素。所以造成了通过css设置1px，在移动端屏幕上会变粗。</p><h1 id="解决方案一：使用伪类缩放"><a href="#解决方案一：使用伪类缩放" class="headerlink" title="解决方案一：使用伪类缩放"></a>解决方案一：使用伪类缩放</h1><p>使用伪类缩放需要主要的是：</p><ul><li>设置全边框的时候，box-sizing要设置为border-box，否则伪元素上下左右各会多1px</li><li>需要将父元素设置为relative</li><li>注意 transform 的起点，上边距要用左上角，下边距用左下角</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* 下边框 */</span><br><span class="line">.one-px-border2:after &#123;</span><br><span class="line">  content: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  position: absolute;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  left: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  border-bottom: 1px solid red;</span><br><span class="line">  transform: scaleY(.5);</span><br><span class="line">  transform-origin: left bottom;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 1px </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rem em px详解</title>
      <link href="/2018/05/25/rem-em-px%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/05/25/rem-em-px%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="rem-em-px详解"><a href="#rem-em-px详解" class="headerlink" title="rem em px详解"></a>rem em px详解</h1><ul><li>px相对长度单位，相对于显示器屏幕分辨率来的</li><li>em相对长度单位，相对于当前对象内文本的字体尺寸来的，值不固定，会继承父级元素字体的大小，未经调整浏览器：16px &#x3D; 1em 假如父元素为2em，子元素为2em字体实际大小为4em</li><li>rem是css3新增的相对单位，使用rem为元素设置大小时，是相对大小，相对的是html根元素，修改根元素就可以调整所有字体大小，还可以避免字体大小逐层复合的连锁反应，未经调整浏览器：16px &#x3D; 1rem。</li></ul><h1 id="移动端适配-相关知识储备"><a href="#移动端适配-相关知识储备" class="headerlink" title="移动端适配 相关知识储备"></a>移动端适配 相关知识储备</h1><p>响应式 —— 在css中，针对不同大小的浏览器窗口，用不同的方式相应更新页面的样式。<br>1inch（英寸） &#x3D; 25.4mm（毫米） &#x3D; 6pc（pica，印刷术语，长度为12points） &#x3D; 72pt（点） &#x3D; 96px（像素）</p><p>em —— 基准是 当前元素的字号（font-size）大小，实际值取决于在哪个元素上应用。</p><ul><li>基准是当前元素的font-size</li><li>如果当前元素的字号用的是em，那么当前元素字号的基准是其父元素</li><li>先算出当前元素的font-size的像素值，再计算其他使用em作为单位的属性值大小</li></ul><p>rem —— 是根em的缩写，基准是根元素的字号大小**</p><p>视口viewport —— 浏览器窗口中用来渲染页面的可视区域，不包括浏览器的地址栏、工具栏、状态栏等。<br>相关单位</p><ul><li>vh ——视口高度的1&#x2F;100</li><li>vw——视口宽度的1&#x2F;100</li><li>vmin——视口宽度或者高度较小值的1&#x2F;100</li><li>vmax——视口官渡或者高度较大值的1&#x2F;100（横竖屏时可以用这两个值）</li></ul><p>flexible源码解读</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// 立即执行函数，入参是window和document</span><br><span class="line">(<span class="keyword">function</span> flexible (window, document) &#123;</span><br><span class="line">  var docEl = document.documentElement</span><br><span class="line">  // 文档的root元素</span><br><span class="line">  var dpr = window.devicePixelRatio || 1</span><br><span class="line">  // 获取设备的dpr（返回当前显示设备的物理像素分辨率与css像素分辨率之比），它告诉浏览器应该使用多少屏幕实际像素来绘制单个css像素，</span><br><span class="line"></span><br><span class="line">  // adjust body font size</span><br><span class="line">  // 调整body标签的fontsize，fontsize = (12 * dpr) + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">  // 设置默认字体大小，默认的字体大小继承自body，如果子元素没有设置font-size就继承父元素设置的这个默认字号（这个地方有个疑问，为什么以12位基准，是因为浏览器的最小显示的字号是12吗？）</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">setBodyFontSize</span></span> () &#123;</span><br><span class="line">    <span class="keyword">if</span> (document.body) &#123;</span><br><span class="line">      document.body.style.fontSize = (12 * dpr) + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      document.addEventListener(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, setBodyFontSize)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  setBodyFontSize();</span><br><span class="line"></span><br><span class="line">  // <span class="built_in">set</span> 1rem = viewWidth / 10</span><br><span class="line">  // 设置根元素的fontsize为clientwidth/10（除以10纯粹是为了计算方便）这个地方也可以直接写10vw（表示可视窗口的宽度的十分之一）</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">setRemUnit</span></span> () &#123;</span><br><span class="line">    var rem = docEl.clientWidth / 10</span><br><span class="line">    docEl.style.fontSize = rem + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setRemUnit()</span><br><span class="line"></span><br><span class="line">  // reset rem unit on page resize</span><br><span class="line">  // 当页面展示或重新设置大小的时候，重新对rem的px值进行计算</span><br><span class="line">  window.addEventListener(<span class="string">&#x27;resize&#x27;</span>, setRemUnit)</span><br><span class="line">  window.addEventListener(<span class="string">&#x27;pageshow&#x27;</span>, <span class="keyword">function</span> (e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.persisted) &#123;</span><br><span class="line">      setRemUnit()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  // detect 0.5px supports</span><br><span class="line">  <span class="keyword">if</span> (dpr &gt;= 2) &#123;</span><br><span class="line">    var fakeBody = document.createElement(<span class="string">&#x27;body&#x27;</span>)</span><br><span class="line">    var testElement = document.createElement(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">    testElement.style.border = <span class="string">&#x27;.5px solid transparent&#x27;</span></span><br><span class="line">    fakeBody.appendChild(testElement)</span><br><span class="line">    docEl.appendChild(fakeBody)</span><br><span class="line">    <span class="keyword">if</span> (testElement.offsetHeight === 1) &#123;</span><br><span class="line">      docEl.classList.add(<span class="string">&#x27;hairlines&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    docEl.removeChild(fakeBody)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(window, document))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> rem em px </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS3 新增常用特性</title>
      <link href="/2018/05/23/CSS3-%E6%96%B0%E5%A2%9E%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7/"/>
      <url>/2018/05/23/CSS3-%E6%96%B0%E5%A2%9E%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># border新增border-img, border-radius</span></span><br><span class="line">* border-image-source 用于指定要用于绘制边框的图像的位置</span><br><span class="line">* border-image-slice 图像边界向内偏移</span><br><span class="line">* border-image-width 图像边界的宽度</span><br><span class="line">* border-image-outset 用于指定在边框外部绘制 border-image-area 的量</span><br><span class="line">* border-image-repeat 用于设置图像边界是否应重复（repeat）、拉伸（stretch）或铺满（round）。</span><br><span class="line">border-image: <span class="built_in">source</span> slice width outset repeat|initial|inherit;</span><br><span class="line"></span><br><span class="line"><span class="comment"># box-shadow </span></span><br><span class="line">box-shadow:-10px -10px 20px 20px gold;</span><br><span class="line"><span class="comment"># text-shadow</span></span><br><span class="line">text-shadow: 0 0 5px <span class="comment">#fff;</span></span><br><span class="line"><span class="comment"># background 新增background-image，background-size background-repeat</span></span><br><span class="line"><span class="comment"># 媒体查询 制作响应式设计</span></span><br><span class="line">@media screen and (max-width: 300px) &#123;</span><br><span class="line">    body &#123;</span><br><span class="line">        background-color:lightblue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (min-width: 300px) and (max-width: 500px)&#123;</span><br><span class="line">    <span class="comment">#wrap div&#123;</span></span><br><span class="line">        width: 20%;</span><br><span class="line">    &#125;            </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5 新增语义化标签</title>
      <link href="/2018/05/22/HTML5-%E6%96%B0%E5%A2%9E%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE/"/>
      <url>/2018/05/22/HTML5-%E6%96%B0%E5%A2%9E%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML5-新增语义化标签"><a href="#HTML5-新增语义化标签" class="headerlink" title="HTML5 新增语义化标签"></a>HTML5 新增语义化标签</h1><p>这种语义化标签主要是针对搜索引擎的<br>这些新标签页面中可以使用多次</p><ul><li>header 头部标签</li><li>nav 导航标签</li><li>content 内容标签</li><li>section 定义文档某个区域</li><li>aside 侧边栏标签</li><li>footer 尾部标签</li><li>video 视频标签</li><li>audio 音频标签</li><li>user-select:none;禁止鼠标移动选择文字</li><li>background-image:liner-gradient(to right,red,green); 设置背景颜色渐变</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器BOM和JS中的DOM</title>
      <link href="/2018/05/14/%E6%B5%8F%E8%A7%88%E5%99%A8BOM%E5%92%8CJS%E4%B8%AD%E7%9A%84DOM/"/>
      <url>/2018/05/14/%E6%B5%8F%E8%A7%88%E5%99%A8BOM%E5%92%8CJS%E4%B8%AD%E7%9A%84DOM/</url>
      
        <content type="html"><![CDATA[<p>JavaScript是一种运行在客户端的脚本语言 （Script 是脚本的意思）,它有三部分组成 ：ECMAScript 语法 ， DOM(页面文档对象模型) ，BOM(浏览器对象模型)而Web API则包含了DOM和BOM</p><h1 id="什么是BOM"><a href="#什么是BOM" class="headerlink" title="什么是BOM"></a>什么是BOM</h1><p>BOM（Browser Object Model）即浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是 window。</p><p>BOM 由一系列相关的对象构成，并且每个对象都提供了很多方法与属性 ，但是BOM 缺乏标准，JavaScript 语法的标准化组织是 ECMA，DOM 的标准化组织是 W3C，BOM 最初是Netscape 浏览器标准的一部分。</p><h1 id="BOM的构成部分"><a href="#BOM的构成部分" class="headerlink" title="BOM的构成部分"></a>BOM的构成部分</h1><p>是window顶级对象 ，也是JS访问浏览器窗口的一个接口。<br>其中包含： document location navigator screen history</p><h1 id="window对象的常见的事件"><a href="#window对象的常见的事件" class="headerlink" title="window对象的常见的事件"></a>window对象的常见的事件</h1><ul><li>窗口加载事件 window.onload 当文档内容完全加载完成会触发该事件(包括图像、脚本文件、CSS 文件等), 就调用的处理函数。(JS代码都写在加载事件里面)</li><li>调整窗口大小的事件 window.onresize window.innerWidth 获取当前屏幕的宽度</li><li>window.setTimeout(调用函数， [延迟的毫秒数]) window.clearTimeout(timeoutID) setInterval clearInterval</li></ul><h1 id="什么是-DOM"><a href="#什么是-DOM" class="headerlink" title="什么是 DOM"></a>什么是 DOM</h1><p>DOM 英文全称“Document Object Model”，译为“文档对象模型”。<br>DOM 是一个与平台和编程语言无关的接口，通过这个接口程序和脚本可以动态的访问和修改文档的内容、结构和样式。</p><h1 id="DOM-的组成"><a href="#DOM-的组成" class="headerlink" title="DOM 的组成"></a>DOM 的组成</h1><p>核心DOM - 针对任何结构化文档的标准模型。<br>XML DOM - 针对 XML 文档的标准模型。<br>HTML DOM - 针对 HTML 文档的标准模型。</p>]]></content>
      
      
      
        <tags>
            
            <tag> BOM DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS浏览器事件循环机制</title>
      <link href="/2018/05/12/JS%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/05/12/JS%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript-单线程-非阻塞"><a href="#JavaScript-单线程-非阻塞" class="headerlink" title="JavaScript 单线程 非阻塞"></a>JavaScript 单线程 非阻塞</h1><p>定义：单线程（代码执行时只有一个主线程来处理所有任务），非阻塞（当代码需要进行一项异步任务时不会等待，主线程会挂起这个任务，在异步任务返回结果时再执行相应的回调）的脚本语言<br>用途：与浏览器交互</p><h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><p>用途：js引擎（网页浏览器中专门处理js脚本的虚拟机）实现非阻塞</p><h1 id="浏览器环境下js引擎的事件循环机制"><a href="#浏览器环境下js引擎的事件循环机制" class="headerlink" title="浏览器环境下js引擎的事件循环机制"></a>浏览器环境下js引擎的事件循环机制</h1><p>js代码执行时将不同变量存于内存中的不同位置<br>堆：放对象 栈：基础类型变量，对象指针</p><h1 id="执行栈：存放执行环境并依次调用执行的地方"><a href="#执行栈：存放执行环境并依次调用执行的地方" class="headerlink" title="执行栈：存放执行环境并依次调用执行的地方"></a>执行栈：存放执行环境并依次调用执行的地方</h1><p>当调用一个方法时，js会生成一个与这个方法对应的执行环境（也叫执行上下文，存放这个方法的私有作用域，上层作用域指向，参数，变量，this对象）。这些方法都被存放在执行栈中，依次调用</p><h1 id="执行栈执行同步代码"><a href="#执行栈执行同步代码" class="headerlink" title="执行栈执行同步代码"></a>执行栈执行同步代码</h1><p>按照执行顺序将执行环境依次加入执行栈中并进入环境执行代码，若有调用，在执行栈中再添加一个执行环境（往上垒），执行环境中的代码执行完毕并返回结果后，js会退出这个执行环境并将其销毁，回到上一个方法的执行环境。反复进行，直到代码全部执行完毕</p><h3 id="执行栈执行异步代码（如发送ajax请求数据）事件队列–实现非阻塞"><a href="#执行栈执行异步代码（如发送ajax请求数据）事件队列–实现非阻塞" class="headerlink" title="执行栈执行异步代码（如发送ajax请求数据）事件队列–实现非阻塞"></a>执行栈执行异步代码（如发送ajax请求数据）事件队列–实现非阻塞</h3><h3 id="js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕，-主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码…，如此反复，这样就形成了一个无限的循环"><a href="#js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕，-主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码…，如此反复，这样就形成了一个无限的循环" class="headerlink" title="js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码…，如此反复，这样就形成了一个无限的循环"></a>js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码…，如此反复，这样就形成了一个无限的循环</h3><h3 id="因为形成了无限循环，所以这个过程被叫做事件循环"><a href="#因为形成了无限循环，所以这个过程被叫做事件循环" class="headerlink" title="因为形成了无限循环，所以这个过程被叫做事件循环"></a>因为形成了无限循环，所以这个过程被叫做<code>事件循环</code></h3><h3 id="不同的异步任务依据执行优先级被分为两类：微任务（micro-task）和宏任务（macro-task）"><a href="#不同的异步任务依据执行优先级被分为两类：微任务（micro-task）和宏任务（macro-task）" class="headerlink" title="不同的异步任务依据执行优先级被分为两类：微任务（micro task）和宏任务（macro task）"></a>不同的异步任务依据执行优先级被分为两类：微任务（micro task）和宏任务（macro task）</h3><ul><li>宏任务：setInterval() setTimeout()</li><li>微任务：new Promise() new MutaionObserver()</li></ul><h3 id="当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行（先微再宏）"><a href="#当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行（先微再宏）" class="headerlink" title="当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行（先微再宏）"></a>当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行（先微再宏）</h3>]]></content>
      
      
      
        <tags>
            
            <tag> JS BOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS事件机制与相关问题</title>
      <link href="/2018/04/20/JS%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E4%B8%8E%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2018/04/20/JS%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E4%B8%8E%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是事件代理-x2F-事件委托？"><a href="#什么是事件代理-x2F-事件委托？" class="headerlink" title="什么是事件代理&#x2F;事件委托？"></a>什么是事件代理&#x2F;事件委托？</h2><h4 id="事件代理-x2F-事件委托是利用事件冒泡的特性，将本应该绑定在多个元素上的事件绑定在他们的祖先元素上，尤其在动态添加子元素的时候，可以非常方便的提高程序性能，减小内存空间。"><a href="#事件代理-x2F-事件委托是利用事件冒泡的特性，将本应该绑定在多个元素上的事件绑定在他们的祖先元素上，尤其在动态添加子元素的时候，可以非常方便的提高程序性能，减小内存空间。" class="headerlink" title="事件代理&#x2F;事件委托是利用事件冒泡的特性，将本应该绑定在多个元素上的事件绑定在他们的祖先元素上，尤其在动态添加子元素的时候，可以非常方便的提高程序性能，减小内存空间。"></a>事件代理&#x2F;事件委托是利用事件冒泡的特性，将本应该绑定在多个元素上的事件绑定在他们的祖先元素上，尤其在动态添加子元素的时候，可以非常方便的提高程序性能，减小内存空间。</h4><h2 id="什么是事件冒泡？什么是事件捕获？"><a href="#什么是事件冒泡？什么是事件捕获？" class="headerlink" title="什么是事件冒泡？什么是事件捕获？"></a>什么是事件冒泡？什么是事件捕获？</h2><ul><li>冒泡型事件：事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。</li><li>捕获型事件：事件从最不精确的对象(document 对象)开始触发，然后到最精确(也可以在窗口级别捕获事件，不过必须由开发人员特别指定)。</li></ul><h4 id="在添加事件时用addEventListener-event-fn-useCapture-方法，基中第3个参数useCapture是一个Boolean值，用来设置事件是在事件捕获时执行，还是事件冒泡时执行-Vue-中-click默认是冒泡的"><a href="#在添加事件时用addEventListener-event-fn-useCapture-方法，基中第3个参数useCapture是一个Boolean值，用来设置事件是在事件捕获时执行，还是事件冒泡时执行-Vue-中-click默认是冒泡的" class="headerlink" title="在添加事件时用addEventListener(event,fn,useCapture)方法，基中第3个参数useCapture是一个Boolean值，用来设置事件是在事件捕获时执行，还是事件冒泡时执行 Vue 中 @click默认是冒泡的"></a>在添加事件时用addEventListener(event,fn,useCapture)方法，基中第3个参数useCapture是一个Boolean值，用来设置事件是在事件捕获时执行，还是事件冒泡时执行 Vue 中 @click默认是冒泡的</h4><h4 id="e-stopPropagation-阻止事件冒泡"><a href="#e-stopPropagation-阻止事件冒泡" class="headerlink" title="e.stopPropagation() 阻止事件冒泡"></a>e.stopPropagation() 阻止事件冒泡</h4><h2 id="DOM-事件有哪些阶段？谈谈对事件代理的理解"><a href="#DOM-事件有哪些阶段？谈谈对事件代理的理解" class="headerlink" title="DOM 事件有哪些阶段？谈谈对事件代理的理解"></a>DOM 事件有哪些阶段？谈谈对事件代理的理解</h2><h4 id="分为三大阶段：捕获阶段–目标阶段–冒泡阶段"><a href="#分为三大阶段：捕获阶段–目标阶段–冒泡阶段" class="headerlink" title="分为三大阶段：捕获阶段–目标阶段–冒泡阶段"></a>分为三大阶段：捕获阶段–目标阶段–冒泡阶段</h4><h4 id="事件代理简单说就是：事件不直接绑定到某元素上，而是绑定到该元素的父元素上，进行触发事件操作时-例如’click’-，再通过条件判断，执行事件触发后的语句-例如’alert-e-target-innerhtml-’"><a href="#事件代理简单说就是：事件不直接绑定到某元素上，而是绑定到该元素的父元素上，进行触发事件操作时-例如’click’-，再通过条件判断，执行事件触发后的语句-例如’alert-e-target-innerhtml-’" class="headerlink" title="事件代理简单说就是：事件不直接绑定到某元素上，而是绑定到该元素的父元素上，进行触发事件操作时(例如’click’)，再通过条件判断，执行事件触发后的语句(例如’alert(e.target.innerhtml)’)"></a>事件代理简单说就是：事件不直接绑定到某元素上，而是绑定到该元素的父元素上，进行触发事件操作时(例如’click’)，再通过条件判断，执行事件触发后的语句(例如’alert(e.target.innerhtml)’)</h4><h2 id="闭包的概念？优缺点？使用场景？"><a href="#闭包的概念？优缺点？使用场景？" class="headerlink" title="闭包的概念？优缺点？使用场景？"></a>闭包的概念？优缺点？使用场景？</h2><h4 id="闭包的概念：闭包就是能读取其他函数内部变量的函数。"><a href="#闭包的概念：闭包就是能读取其他函数内部变量的函数。" class="headerlink" title="闭包的概念：闭包就是能读取其他函数内部变量的函数。"></a>闭包的概念：闭包就是能读取其他函数内部变量的函数。</h4><h4 id="优点：-避免全局变量的污染，希望一个变量长期存储在内存中（缓存变量）"><a href="#优点：-避免全局变量的污染，希望一个变量长期存储在内存中（缓存变量）" class="headerlink" title="优点： 避免全局变量的污染，希望一个变量长期存储在内存中（缓存变量）"></a>优点： 避免全局变量的污染，希望一个变量长期存储在内存中（缓存变量）</h4><h4 id="缺点：-内存泄露（消耗），常驻内存，增加内存使用量"><a href="#缺点：-内存泄露（消耗），常驻内存，增加内存使用量" class="headerlink" title="缺点： 内存泄露（消耗），常驻内存，增加内存使用量"></a>缺点： 内存泄露（消耗），常驻内存，增加内存使用量</h4><h4 id="使用场景：封装功能时-需要使用私有的属性和方法-，函数防抖、函数节流、函数柯里化、给元素伪数组添加事件需要使用元素的索引值。"><a href="#使用场景：封装功能时-需要使用私有的属性和方法-，函数防抖、函数节流、函数柯里化、给元素伪数组添加事件需要使用元素的索引值。" class="headerlink" title="使用场景：封装功能时(需要使用私有的属性和方法)，函数防抖、函数节流、函数柯里化、给元素伪数组添加事件需要使用元素的索引值。"></a>使用场景：封装功能时(需要使用私有的属性和方法)，函数防抖、函数节流、函数柯里化、给元素伪数组添加事件需要使用元素的索引值。</h4><h2 id="new操作符具体干了什么呢"><a href="#new操作符具体干了什么呢" class="headerlink" title="new操作符具体干了什么呢?"></a>new操作符具体干了什么呢?</h2><ul><li>1.创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。</li><li>2.属性和方法被加入到 this 引用的对象中。</li><li>3.新创建的对象由 this 所引用，并且最后隐式的返回 this 。</li></ul><h2 id="javascript中this的指向"><a href="#javascript中this的指向" class="headerlink" title="javascript中this的指向"></a>javascript中this的指向</h2><h4 id="this永远指向函数运行时所在的对象，而不是函数被创建时所在的对象。"><a href="#this永远指向函数运行时所在的对象，而不是函数被创建时所在的对象。" class="headerlink" title="this永远指向函数运行时所在的对象，而不是函数被创建时所在的对象。"></a>this永远指向函数运行时所在的对象，而不是函数被创建时所在的对象。</h4><h4 id="普通的函数调用，函数被谁调用，this就是谁"><a href="#普通的函数调用，函数被谁调用，this就是谁" class="headerlink" title="普通的函数调用，函数被谁调用，this就是谁"></a>普通的函数调用，函数被谁调用，this就是谁</h4><h4 id="构造函数的话，如果不用new操作符而直接调用，那即this指向window。用new操作符生成对象实例后，this就指向了新生成的对象。"><a href="#构造函数的话，如果不用new操作符而直接调用，那即this指向window。用new操作符生成对象实例后，this就指向了新生成的对象。" class="headerlink" title="构造函数的话，如果不用new操作符而直接调用，那即this指向window。用new操作符生成对象实例后，this就指向了新生成的对象。"></a>构造函数的话，如果不用new操作符而直接调用，那即this指向window。用new操作符生成对象实例后，this就指向了新生成的对象。</h4><h4 id="匿名函数或不处于任何对象中的函数指向window"><a href="#匿名函数或不处于任何对象中的函数指向window" class="headerlink" title="匿名函数或不处于任何对象中的函数指向window"></a>匿名函数或不处于任何对象中的函数指向window</h4><h4 id="如果是call，apply等，指定的this是谁，就是谁。"><a href="#如果是call，apply等，指定的this是谁，就是谁。" class="headerlink" title="如果是call，apply等，指定的this是谁，就是谁。"></a>如果是call，apply等，指定的this是谁，就是谁。</h4><h2 id="Javascript作用链域"><a href="#Javascript作用链域" class="headerlink" title="Javascript作用链域"></a>Javascript作用链域</h2><h4 id="作用域链的原理和原型链很类似，如果这个变量在自己的作用域中没有，那么它会寻找父级的，直到最顶层。"><a href="#作用域链的原理和原型链很类似，如果这个变量在自己的作用域中没有，那么它会寻找父级的，直到最顶层。" class="headerlink" title="作用域链的原理和原型链很类似，如果这个变量在自己的作用域中没有，那么它会寻找父级的，直到最顶层。"></a>作用域链的原理和原型链很类似，如果这个变量在自己的作用域中没有，那么它会寻找父级的，直到最顶层。</h4><h2 id="js如何处理防抖和节流"><a href="#js如何处理防抖和节流" class="headerlink" title="js如何处理防抖和节流"></a>js如何处理防抖和节流</h2><h4 id="在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。"><a href="#在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。" class="headerlink" title="在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。"></a>在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数防抖（debounce）：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。如下，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> debounce(fn, <span class="built_in">wait</span>) &#123; </span><br><span class="line">  var <span class="built_in">timeout</span> = null; </span><br><span class="line">  <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>() &#123; </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">timeout</span> !== null) clearTimeout(<span class="built_in">timeout</span>);</span><br><span class="line">    <span class="built_in">timeout</span> = setTimeout(fn, <span class="built_in">wait</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line">// 处理函数 </span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">handle</span></span>() &#123; console.log(Math.random()); &#125; // 滚动事件</span><br><span class="line">window.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, debounce(handle, 1000)); 函数节流函数节流（throttle）：</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当持续触发事件时，保证一定时间段内只调用一次事件处理函数。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。如下，持续触发scroll事件时，并不立即执行handle函数，每隔1000毫秒才会执行一次handle函数。</span></span><br><span class="line">var throttle = <span class="keyword">function</span>(func, delay) &#123; </span><br><span class="line">  var prev = Date.now(); </span><br><span class="line">  <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    var context = this;</span><br><span class="line">    var args = arguments; </span><br><span class="line">    var now = Date.now(); </span><br><span class="line">    <span class="keyword">if</span> (now - prev &gt;= delay) &#123; </span><br><span class="line">      func.apply(context, args);</span><br><span class="line">      prev = Date.now(); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">handle</span></span>() &#123; console.log(Math.random()); &#125; </span><br><span class="line">window.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, throttle(handle, 1000));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="JS里垃圾回收机制是什么，常用的是哪种，怎么处理的？"><a href="#JS里垃圾回收机制是什么，常用的是哪种，怎么处理的？" class="headerlink" title="JS里垃圾回收机制是什么，常用的是哪种，怎么处理的？"></a>JS里垃圾回收机制是什么，常用的是哪种，怎么处理的？</h2><h4 id="JS的垃圾回收机制是为了以防内存泄漏，内存泄漏的含义就是当已经不需要某块内存时这块内存还存在着，垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向的内存。JS中最常见的垃圾回收方式是标记清除。工作原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。"><a href="#JS的垃圾回收机制是为了以防内存泄漏，内存泄漏的含义就是当已经不需要某块内存时这块内存还存在着，垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向的内存。JS中最常见的垃圾回收方式是标记清除。工作原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。" class="headerlink" title="JS的垃圾回收机制是为了以防内存泄漏，内存泄漏的含义就是当已经不需要某块内存时这块内存还存在着，垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向的内存。JS中最常见的垃圾回收方式是标记清除。工作原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。"></a>JS的垃圾回收机制是为了以防内存泄漏，内存泄漏的含义就是当已经不需要某块内存时这块内存还存在着，垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向的内存。JS中最常见的垃圾回收方式是标记清除。工作原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。</h4><h4 id="那些操作会造成内存泄漏"><a href="#那些操作会造成内存泄漏" class="headerlink" title="那些操作会造成内存泄漏"></a>那些操作会造成内存泄漏</h4><h4 id="全局变量、闭包、DOM清空或删除时，事件未清除、子元素存在引用"><a href="#全局变量、闭包、DOM清空或删除时，事件未清除、子元素存在引用" class="headerlink" title="全局变量、闭包、DOM清空或删除时，事件未清除、子元素存在引用"></a>全局变量、闭包、DOM清空或删除时，事件未清除、子元素存在引用</h4><h2 id="什么是虚拟DOM"><a href="#什么是虚拟DOM" class="headerlink" title="什么是虚拟DOM"></a>什么是虚拟DOM</h2><h4 id="文档对象模型或-DOM-定义了一个接口，该接口允许-JavaScript-之类的语言访问和操作-HTML-文档。元素由树中的节点表示，并且接口允许我们操纵它们。但是此接口需要付出代价，大量非常频繁的-DOM-操作会使页面速度变慢。为了减少重排和重绘，虚拟dom应运而生。"><a href="#文档对象模型或-DOM-定义了一个接口，该接口允许-JavaScript-之类的语言访问和操作-HTML-文档。元素由树中的节点表示，并且接口允许我们操纵它们。但是此接口需要付出代价，大量非常频繁的-DOM-操作会使页面速度变慢。为了减少重排和重绘，虚拟dom应运而生。" class="headerlink" title="文档对象模型或 DOM 定义了一个接口，该接口允许 JavaScript 之类的语言访问和操作 HTML 文档。元素由树中的节点表示，并且接口允许我们操纵它们。但是此接口需要付出代价，大量非常频繁的 DOM 操作会使页面速度变慢。为了减少重排和重绘，虚拟dom应运而生。"></a>文档对象模型或 DOM 定义了一个接口，该接口允许 JavaScript 之类的语言访问和操作 HTML 文档。元素由树中的节点表示，并且接口允许我们操纵它们。但是此接口需要付出代价，大量非常频繁的 DOM 操作会使页面速度变慢。为了减少重排和重绘，虚拟dom应运而生。</h4><h3 id="JS延迟加载的方式有哪些？"><a href="#JS延迟加载的方式有哪些？" class="headerlink" title="JS延迟加载的方式有哪些？"></a>JS延迟加载的方式有哪些？</h3><h4 id="defer和async、动态创建DOM方式（用得最多）、按需异步载入JS"><a href="#defer和async、动态创建DOM方式（用得最多）、按需异步载入JS" class="headerlink" title="defer和async、动态创建DOM方式（用得最多）、按需异步载入JS"></a>defer和async、动态创建DOM方式（用得最多）、按需异步载入JS</h4><ul><li>defer：延迟脚本。立即下载，但延迟执行（延迟到整个页面都解析完毕后再运行），按照脚本出现的先后顺序执行。</li><li>async：异步脚本。下载完立即执行，但不保证按照脚本出现的先后顺序执行。</li></ul><h2 id="JS为什么要区分微任务和宏任务"><a href="#JS为什么要区分微任务和宏任务" class="headerlink" title="JS为什么要区分微任务和宏任务"></a>JS为什么要区分微任务和宏任务</h2><ul><li>（1）js是单线程的，但是分同步异步</li><li>（2）微任务和宏任务皆为异步任务，它们都属于一个队列</li><li>（3）宏任务一般是：script，setTimeout，setInterval、setImmediate</li><li>（4）微任务：原生Promise</li><li>（5）遇到微任务，先执行微任务，执行完后如果没有微任务，就执行下一个宏任务，如果有微任务，就按顺序一个一个执行微任务</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS经典问题指南</title>
      <link href="/2018/04/18/JS%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E6%8C%87%E5%8D%97/"/>
      <url>/2018/04/18/JS%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript的数据类型"><a href="#JavaScript的数据类型" class="headerlink" title="JavaScript的数据类型"></a>JavaScript的数据类型</h2><ul><li>值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol（独一无二的值</li><li>引用数据类型：对象(Object)、数组(Array)、函数(Function)。</li></ul><h2 id="基本数据类型与引用类型在存储上有什么区别"><a href="#基本数据类型与引用类型在存储上有什么区别" class="headerlink" title="基本数据类型与引用类型在存储上有什么区别?"></a>基本数据类型与引用类型在存储上有什么区别?</h2><h3 id="1-存储位置不同"><a href="#1-存储位置不同" class="headerlink" title="1.存储位置不同:"></a>1.存储位置不同:</h3><ul><li>基本数据类型：以栈的形式存储, 保存与赋值指向数据本身, 用typeof 来判断类型</li><li>引用类型：以堆的形式存储, 保存于赋值指向对象的一个指针, 用instanceof 来判断类型</li></ul><h3 id="2-传值方式不同："><a href="#2-传值方式不同：" class="headerlink" title="2.传值方式不同："></a>2.传值方式不同：</h3><ul><li>基本数据类型按值传递，无法改变一个基本数据类型的值</li><li>引用类型按引用传递，应用类型值可以改变</li></ul><h2 id="判断-js-类型的方式"><a href="#判断-js-类型的方式" class="headerlink" title="判断 js 类型的方式"></a>判断 js 类型的方式</h2><ul><li><ol><li>typeof<h3 id="可以判断出’string’-’number’-’boolean’-’undefined’-’symbol’但判断-typeof-null-时值为-‘object’-判断数组和对象时值均为-‘object’"><a href="#可以判断出’string’-’number’-’boolean’-’undefined’-’symbol’但判断-typeof-null-时值为-‘object’-判断数组和对象时值均为-‘object’" class="headerlink" title="可以判断出’string’,’number’,’boolean’,’undefined’,’symbol’但判断 typeof(null) 时值为 ‘object’; 判断数组和对象时值均为 ‘object’"></a>可以判断出’string’,’number’,’boolean’,’undefined’,’symbol’但判断 typeof(null) 时值为 ‘object’; 判断数组和对象时值均为 ‘object’</h3></li></ol></li><li><ol start="2"><li>instanceof<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">functionA</span></span>() &#123;&#125;</span><br><span class="line"><span class="built_in">let</span> a = new A();</span><br><span class="line">a instanceof A //true</span><br><span class="line">// 因为 Object.getPrototypeOf(a) === A.prototype;</span><br></pre></td></tr></table></figure></li></ol></li><li><ol start="3"><li>Object.prototype.toString.call() 可以判断所有类型<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call(null)//<span class="string">&quot;[object Null]&quot;</span></span><br><span class="line">Object.prototype.toString.call(undefined)//<span class="string">&quot;[object Undefined]&quot;</span></span><br><span class="line">Object.prototype.toString.call(Object)//<span class="string">&quot;[object Function]&quot;</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="描述以下变量的区别：null，undefined或undeclared"><a href="#描述以下变量的区别：null，undefined或undeclared" class="headerlink" title="描述以下变量的区别：null，undefined或undeclared"></a>描述以下变量的区别：null，undefined或undeclared</h2><ul><li>null 表示”没有对象”</li><li>undefined 表示”缺少值”，就是此处应该有一个值，但是还没有定义</li></ul><h4 id="变量被声明了，但没有赋值时，就等于undefined。"><a href="#变量被声明了，但没有赋值时，就等于undefined。" class="headerlink" title="变量被声明了，但没有赋值时，就等于undefined。"></a>变量被声明了，但没有赋值时，就等于undefined。</h4><h4 id="调用函数时，应该提供的参数没有提供，该参数等于undefined。"><a href="#调用函数时，应该提供的参数没有提供，该参数等于undefined。" class="headerlink" title="调用函数时，应该提供的参数没有提供，该参数等于undefined。"></a>调用函数时，应该提供的参数没有提供，该参数等于undefined。</h4><h4 id="对象没有赋值的属性，该属性的值为undefined。"><a href="#对象没有赋值的属性，该属性的值为undefined。" class="headerlink" title="对象没有赋值的属性，该属性的值为undefined。"></a>对象没有赋值的属性，该属性的值为undefined。</h4><h4 id="函数没有返回值时，默认返回undefined。"><a href="#函数没有返回值时，默认返回undefined。" class="headerlink" title="函数没有返回值时，默认返回undefined。"></a>函数没有返回值时，默认返回undefined。</h4><ul><li>undeclared :js语法错误，没有申明直接使用，js无法找到对应的上下文。</li></ul><h2 id="for-in-和-object-keys的区别"><a href="#for-in-和-object-keys的区别" class="headerlink" title="for..in 和 object.keys的区别"></a>for..in 和 object.keys的区别</h2><ul><li>Object.keys不会遍历继承的原型属性</li><li>for…in 会遍历继承的原型属性</li></ul><h2 id="JS-中的函数提升"><a href="#JS-中的函数提升" class="headerlink" title="JS 中的函数提升"></a>JS 中的函数提升</h2><h4 id="JS允许将声明移动到顶部的默认行为称为提升。JS中创建函数的两种方法是函数声明和函数表达式。"><a href="#JS允许将声明移动到顶部的默认行为称为提升。JS中创建函数的两种方法是函数声明和函数表达式。" class="headerlink" title="JS允许将声明移动到顶部的默认行为称为提升。JS中创建函数的两种方法是函数声明和函数表达式。"></a>JS允许将声明移动到顶部的默认行为称为提升。JS中创建函数的两种方法是函数声明和函数表达式。</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数声明</span></span><br><span class="line">hoisted();</span><br><span class="line">// logs <span class="string">&quot;foo&quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">hoisted</span></span>() &#123;console.log(<span class="string">&#x27;foo&#x27;</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数表达式</span></span><br><span class="line">notHoisted(); </span><br><span class="line"><span class="comment">#TypeError: notHoisted is not a function</span></span><br><span class="line">var notHoisted = <span class="function"><span class="title">function</span></span>() &#123;console.log(<span class="string">&#x27;bar&#x27;</span>);&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Js隐式转换"><a href="#Js隐式转换" class="headerlink" title="Js隐式转换"></a>Js隐式转换</h2><h4 id="在js中，当运算符在运算时，如果两边数据不统一，CPU就无法计算，这时我们编译器会自动将运算符两边的数据做一个数据类型转换，转成一样的数据类型再计算"><a href="#在js中，当运算符在运算时，如果两边数据不统一，CPU就无法计算，这时我们编译器会自动将运算符两边的数据做一个数据类型转换，转成一样的数据类型再计算" class="headerlink" title="在js中，当运算符在运算时，如果两边数据不统一，CPU就无法计算，这时我们编译器会自动将运算符两边的数据做一个数据类型转换，转成一样的数据类型再计算"></a>在js中，当运算符在运算时，如果两边数据不统一，CPU就无法计算，这时我们编译器会自动将运算符两边的数据做一个数据类型转换，转成一样的数据类型再计算</h4><h4 id="这种无需程序员手动转换，而由编译器自动转换的方式就称为隐式转换"><a href="#这种无需程序员手动转换，而由编译器自动转换的方式就称为隐式转换" class="headerlink" title="这种无需程序员手动转换，而由编译器自动转换的方式就称为隐式转换"></a>这种无需程序员手动转换，而由编译器自动转换的方式就称为隐式转换</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 隐式转换规则：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 转成string类型： +（字符串连接符） 2..转成number类型：++/--(自增自减运算符) + - * / %(算术运算符) &gt; &lt; &gt;= &lt;= == != === !=== (关系运算符)</span></span><br><span class="line"><span class="comment"># 2. 转成boolean类型：!（逻辑非运算符）</span></span><br><span class="line">console.log([] == []) // <span class="literal">false</span> </span><br><span class="line">console.log([] == ![]) // <span class="literal">true</span></span><br><span class="line">console.log([] !== []) // <span class="literal">true</span></span><br><span class="line">console.log(NaN != NaN) // <span class="literal">true</span></span><br><span class="line">console.log(null == undefined) // <span class="literal">true</span></span><br><span class="line">console.log(null === undefined) // <span class="literal">false</span></span><br><span class="line">console.log(1 == <span class="literal">true</span>) // <span class="literal">true</span></span><br><span class="line">console.log(null &gt; 0) // <span class="literal">false</span></span><br><span class="line">console.log(<span class="literal">true</span> + 1) // 2</span><br><span class="line">console.log(undefined + 1) // NaN</span><br><span class="line">console.log(&#123;&#125; + 1) // [object Object]1</span><br><span class="line">console.log([] + &#123;&#125;) // [object Object]</span><br><span class="line">console.log([2,3] + [1,2]) // 2,31,2</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="JS-中-x3D-x3D-和-x3D-x3D-x3D-区别是什么？"><a href="#JS-中-x3D-x3D-和-x3D-x3D-x3D-区别是什么？" class="headerlink" title="JS 中 &#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; 区别是什么？"></a>JS 中 &#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; 区别是什么？</h2><ul><li>两等号判等，会在比较时进行类型转换；</li><li>三等号判等(判断严格)，比较时不进行隐式类型转换，(类 型不同则会返回false)；</li></ul><h2 id="ES5-和-ES6-分别几种方式声明变量"><a href="#ES5-和-ES6-分别几种方式声明变量" class="headerlink" title="ES5 和 ES6 分别几种方式声明变量"></a>ES5 和 ES6 分别几种方式声明变量</h2><ul><li>ES5 有俩种：var 和 function</li><li>ES6 有六种：增加四种，let、const、class 和 import</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS经典规则</title>
      <link href="/2018/04/16/CSS%E7%BB%8F%E5%85%B8%E8%A7%84%E5%88%99/"/>
      <url>/2018/04/16/CSS%E7%BB%8F%E5%85%B8%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS经典规则"><a href="#CSS经典规则" class="headerlink" title="CSS经典规则"></a>CSS经典规则</h1><h3 id="使用方式-及-权重"><a href="#使用方式-及-权重" class="headerlink" title="使用方式 及 权重"></a>使用方式 及 权重</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.内联：直接在HTML元素上使用</span><br><span class="line">&lt;p style=<span class="string">&quot;color: red&quot;</span>&gt;&lt;/p&gt;</span><br><span class="line">2.外部:在工作空间中创建单独的CSS文件，然后在创建的每个web页面中链接它们</span><br><span class="line">&lt;<span class="built_in">head</span>&gt;</span><br><span class="line">&lt;<span class="built_in">link</span> rel=<span class="string">&quot;text/css&quot;</span> href=<span class="string">&quot;url&quot;</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">3. web 页面的 <span class="built_in">head</span> 元素在其中实现了内部 CSS。</span><br><span class="line">&lt;<span class="built_in">head</span>&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">p&#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 权重优先级 !important -&gt; 内联 -&gt; 最后读取的</span></span><br></pre></td></tr></table></figure><h3 id="伪类和伪元素是什么？如何区分？"><a href="#伪类和伪元素是什么？如何区分？" class="headerlink" title="伪类和伪元素是什么？如何区分？"></a>伪类和伪元素是什么？如何区分？</h3><ul><li>伪类是用来定义元素特殊状态的，他可以用来设置鼠标悬停样式、元素获取焦点样式、设置链接样式等。如常见的 hover、active、link 等都是伪类</li><li>伪元素也称为伪对象，它不存在于 DOM 文档中、是一个虚拟的元素。它可以用来代表某个元素的子元素，但是这个子元素并不存在于文档树中。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 伪类和伪元素的根本区别在于：是否创造了新的元素。</span></span><br><span class="line"><span class="comment"># html </span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;p class=<span class="string">&quot;one&quot;</span>&gt;红色&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;黑色&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="comment">#css 伪类</span></span><br><span class="line">p:first-child&#123;</span><br><span class="line">  color:red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># css 伪元素</span></span><br><span class="line">.one &#123;</span><br><span class="line">  color:red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="BFC-规范（块级格式化上下文：block-formatting-context）"><a href="#BFC-规范（块级格式化上下文：block-formatting-context）" class="headerlink" title="BFC 规范（块级格式化上下文：block formatting context）"></a>BFC 规范（块级格式化上下文：block formatting context）</h3><h4 id="BFC指的是块级格式化上下文，一个元素形成了BFC之后，那么它内部元素产生的布局不会影响到外部元素，外部元素的布局也不会影响到BFC中的内部元素。一个BFC就像是一个隔离区域，和其他区域互不影响。"><a href="#BFC指的是块级格式化上下文，一个元素形成了BFC之后，那么它内部元素产生的布局不会影响到外部元素，外部元素的布局也不会影响到BFC中的内部元素。一个BFC就像是一个隔离区域，和其他区域互不影响。" class="headerlink" title="BFC指的是块级格式化上下文，一个元素形成了BFC之后，那么它内部元素产生的布局不会影响到外部元素，外部元素的布局也不会影响到BFC中的内部元素。一个BFC就像是一个隔离区域，和其他区域互不影响。"></a>BFC指的是块级格式化上下文，一个元素形成了BFC之后，那么它内部元素产生的布局不会影响到外部元素，外部元素的布局也不会影响到BFC中的内部元素。一个BFC就像是一个隔离区域，和其他区域互不影响。</h4><h4 id="使得当前bfc区域内的元素都变为行内元素（块级格式化上下文）"><a href="#使得当前bfc区域内的元素都变为行内元素（块级格式化上下文）" class="headerlink" title="使得当前bfc区域内的元素都变为行内元素（块级格式化上下文）"></a>使得当前bfc区域内的元素都变为行内元素（块级格式化上下文）</h4><ul><li>1.浮动元素不为none；</li><li>2.position不为static；</li><li>3.display:inline-block；display:table-cell；display:table-caption；</li><li>4.overflow 计算值(Computed)不为 visible 的块元素</li><li>5.display:inline-flex;</li></ul><h3 id="IFC指的是行级格式化上下文，它有这样的一些布局规则："><a href="#IFC指的是行级格式化上下文，它有这样的一些布局规则：" class="headerlink" title="IFC指的是行级格式化上下文，它有这样的一些布局规则："></a>IFC指的是行级格式化上下文，它有这样的一些布局规则：</h3><ul><li>（1）行级上下文内部的盒子会在水平方向，一个接一个地放置。</li><li>（2）当一行不够的时候会自动切换到下一行。</li><li>（3）行级上下文的高度由内部最高的内联盒子的高度决定。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS常用垂直居中布局</title>
      <link href="/2018/04/15/CSS%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80/"/>
      <url>/2018/04/15/CSS%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS垂直居中布局"><a href="#CSS垂直居中布局" class="headerlink" title="CSS垂直居中布局"></a>CSS垂直居中布局</h1><h3 id="line-height-text-align-文字垂直居中"><a href="#line-height-text-align-文字垂直居中" class="headerlink" title="line-height + text-align 文字垂直居中"></a>line-height + text-align 文字垂直居中</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># html</span></span><br><span class="line">&lt;div class=<span class="string">&quot;example&quot;</span>&gt;Lorem ipsam.&lt;/div&gt;</span><br><span class="line"><span class="comment">#css</span></span><br><span class="line">.example&#123;</span><br><span class="line">  width: 400px;</span><br><span class="line">  background: <span class="comment">#afddf3;</span></span><br><span class="line">  line-height: 50px;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="absolute-margin"><a href="#absolute-margin" class="headerlink" title="absolute + margin"></a>absolute + margin</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># html</span></span><br><span class="line">&lt;div class=<span class="string">&quot;parant&quot;</span>&gt;</span><br><span class="line">  &lt;div class=<span class="string">&quot;child&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="comment">#css</span></span><br><span class="line">.parant &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 0;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  left: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  margin: auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#  原理：当元素设置为绝对定位后，假设它是抓不到整体可运用的空间范围，所以margin: auto会失效，但当你设置了top:0;bottom:0;时，绝对定位元素就抓到了可运用的空间了，这时你的margin:auto就生效了。</span></span><br></pre></td></tr></table></figure><h3 id="absolute-translate"><a href="#absolute-translate" class="headerlink" title="absolute + translate"></a>absolute + translate</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># html</span></span><br><span class="line">&lt;div class=<span class="string">&quot;parant&quot;</span>&gt;</span><br><span class="line">  &lt;div class=<span class="string">&quot;child&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="comment">#css</span></span><br><span class="line">.parant &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  left: 50%;</span><br><span class="line">  top: 50%;</span><br><span class="line">  transform: translate(-50%, -50%);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 原理：利用绝对定位时的top 与right设置元素的上方跟左方各为50%，再利用transform: translate(-50%, -50%);位移居中元素自身宽与高的50%就能达成居中的目的了。</span></span><br></pre></td></tr></table></figure><h3 id="Flex-align-items"><a href="#Flex-align-items" class="headerlink" title="Flex + align-items"></a>Flex + align-items</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># html</span></span><br><span class="line">&lt;div class=<span class="string">&quot;parant&quot;</span>&gt;</span><br><span class="line">  &lt;div class=<span class="string">&quot;child&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="comment">#css</span></span><br><span class="line">.parant &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  justify-content: center;</span><br><span class="line">  align-item: center</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS字符串常用的操作方法</title>
      <link href="/2018/04/14/JS%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/"/>
      <url>/2018/04/14/JS%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="JS字符串常用的操作方法"><a href="#JS字符串常用的操作方法" class="headerlink" title="JS字符串常用的操作方法"></a>JS字符串常用的操作方法</h1><ul><li>str.charAt(index) 返回指定index下标的字符 下标从0开始</li><li>str.includes(str1) 方法用于判断str1是否包含在str中，根据情况返回 true 或 false。</li><li>str.indexOf(str1) 方法用于判断str1是否包含在str中，返回存在的下标，无则-1</li><li>str.replace(regx,str) 按照regx的规则，将符合的替换成str</li><li>str.split(‘分隔符’) 将str按照分隔符转化成数组</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">var anyString = <span class="string">&quot;Brave new world&quot;</span>;</span><br><span class="line">console.log(<span class="string">&quot;The character at index 0   is &#x27;&quot;</span> + anyString.charAt(0)   + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">// The character at index 0 is <span class="string">&#x27;B&#x27;</span></span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">// str.includes(str1) 方法用于判断str1是否包含在str中，根据情况返回 <span class="literal">true</span> 或 <span class="literal">false</span>。 区分大小写</span><br><span class="line"><span class="string">&#x27;Blue Whale&#x27;</span>.includes(<span class="string">&#x27;blue&#x27;</span>); // returns <span class="literal">false</span></span><br><span class="line"><span class="string">&#x27;Blue Whale&#x27;</span>.includes(<span class="string">&#x27;Blue&#x27;</span>); // returns <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">//str.indexOf(str1) 方法用于判断str1是否包含在str中，返回存在的下标，无则-1</span><br><span class="line">const paragraph = <span class="string">&#x27;The quick brown fox jumps over the lazy dog. If the dog barked, was it really lazy?&#x27;</span>;</span><br><span class="line"></span><br><span class="line">const searchTerm = <span class="string">&#x27;dog&#x27;</span>;</span><br><span class="line">const indexOfFirst = paragraph.indexOf(searchTerm);</span><br><span class="line">console.log(indexOfFirst); // expected output: <span class="string">&quot;40&quot;</span></span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">// str.replace(regx,str) 按照regx的规则，将符合的替换成str</span><br><span class="line">const p = <span class="string">&#x27;The quick brown fox jumps over the lazy dog. If the dog reacted, was it really lazy?&#x27;</span>;</span><br><span class="line"></span><br><span class="line">console.log(p.replace(<span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;monkey&#x27;</span>));</span><br><span class="line">// expected output: <span class="string">&quot;The quick brown fox jumps over the lazy monkey. If the dog reacted, was it really lazy?&quot;</span></span><br><span class="line">const regex = /Dog/i;</span><br><span class="line">console.log(p.replace(regex, <span class="string">&#x27;ferret&#x27;</span>));</span><br><span class="line">// expected output: <span class="string">&quot;The quick brown fox jumps over the lazy ferret. If the dog reacted, was it really lazy?&quot;</span></span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">//str.split(<span class="string">&#x27;分隔符&#x27;</span>) 将str按照分隔符转化成数组</span><br><span class="line">const str = <span class="string">&#x27;The quick brown fox jumps over the lazy dog.&#x27;</span>;</span><br><span class="line">const words = str.split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">console.log(words[3]);// expected output: <span class="string">&quot;fox&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS数组常用的操作方法</title>
      <link href="/2018/04/13/JS%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/"/>
      <url>/2018/04/13/JS%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="JS数组常用的操作方法"><a href="#JS数组常用的操作方法" class="headerlink" title="JS数组常用的操作方法"></a>JS数组常用的操作方法</h2><ul><li>Array.length 获取数组长度</li><li>Array.shift() Array.unshift()  Array.push() Array.pop()</li><li>Array.concat(a1,a2….) 数组合并</li><li>Array.reverse() 数组元素颠倒</li><li>Array.join(‘拼接字符’) 数组转字符串</li><li>Array.indexOf(item) ||  Array.includes(item) 判断Item 是否存在数组里面 </li><li>Array.fill(填充val，下标1，下标2) 数组填充</li><li>[…new Set(arr)]数组去重 || Array.from(new Set(arr))</li><li>Array.slice(begin,end) 这一对象是一个由 begin 和 end 决定的原数组的浅拷贝</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">// Array.length 获取数组长度</span><br><span class="line">const clothing = [<span class="string">&#x27;shoes&#x27;</span>, <span class="string">&#x27;shirts&#x27;</span>, <span class="string">&#x27;socks&#x27;</span>, <span class="string">&#x27;sweaters&#x27;</span>];</span><br><span class="line">console.log(clothing.length); // 4</span><br><span class="line"></span><br><span class="line">// ---------------------------------------</span><br><span class="line"></span><br><span class="line">// Array.<span class="built_in">shift</span>() Array.unshift()  Array.push() Array.pop()</span><br><span class="line">const array1 = [1, 2, 3];</span><br><span class="line">// 往头部插入</span><br><span class="line">array1.unshift(4, 5); </span><br><span class="line">// array1: [4,5,1,2,3] </span><br><span class="line">// 往头部删除</span><br><span class="line">array1.shift() </span><br><span class="line">// array1: [5,1,2,3] </span><br><span class="line">// 往尾部插入</span><br><span class="line">array1.push(4)</span><br><span class="line">//  array1: [5,1,2,3,4] </span><br><span class="line">// 往尾部删除</span><br><span class="line">array1.pop()</span><br><span class="line">// array1: [5,1,2,3]</span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------</span><br><span class="line"></span><br><span class="line">//Array.reverse() 数组元素颠倒</span><br><span class="line">const array1 = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>];</span><br><span class="line">array1.reverse() // [<span class="string">&quot;three&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;one&quot;</span>]</span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------</span><br><span class="line"></span><br><span class="line">// Array.<span class="built_in">join</span>(<span class="string">&#x27;拼接字符&#x27;</span>) 数组转字符串</span><br><span class="line">const elements = [<span class="string">&#x27;Fire&#x27;</span>, <span class="string">&#x27;Air&#x27;</span>, <span class="string">&#x27;Water&#x27;</span>];</span><br><span class="line">console.log(elements.join());</span><br><span class="line">// expected output: <span class="string">&quot;Fire,Air,Water&quot;</span></span><br><span class="line"></span><br><span class="line">console.log(elements.join(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line">// expected output: <span class="string">&quot;FireAirWater&quot;</span></span><br><span class="line"></span><br><span class="line">console.log(elements.join(<span class="string">&#x27;-&#x27;</span>));</span><br><span class="line">// expected output: <span class="string">&quot;Fire-Air-Water&quot;</span></span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------</span><br><span class="line"></span><br><span class="line">// Array.indexOf(item) ||  Array.includes(item) 判断Item 是否存在数组里面</span><br><span class="line">const beasts = [<span class="string">&#x27;ant&#x27;</span>, <span class="string">&#x27;bison&#x27;</span>, <span class="string">&#x27;camel&#x27;</span>, <span class="string">&#x27;duck&#x27;</span>, <span class="string">&#x27;bison&#x27;</span>];</span><br><span class="line"></span><br><span class="line">console.log(beasts.indexOf(<span class="string">&#x27;bison&#x27;</span>));// expected output: 1</span><br><span class="line">console.log(beasts.includes(<span class="string">&#x27;bison&#x27;</span>));// expected output: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------</span><br><span class="line"></span><br><span class="line">// Array.concat(a1,a2....) 数组合并</span><br><span class="line">const array1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">const array2 = [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>];</span><br><span class="line">const array3 = array1.concat(array2);</span><br><span class="line"></span><br><span class="line">console.log(array3);// [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>]</span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------</span><br><span class="line"></span><br><span class="line">// Array.fill(填充val，下标1，下标2) 数组填充</span><br><span class="line">const array1 = [1, 2, 3, 4];</span><br><span class="line">console.log(array1.fill(0, 2, 4)); // [1, 2, 0, 0]</span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------</span><br><span class="line"></span><br><span class="line">//*[...new Set(arr)]数组去重 || Array.from(new Set(arr))</span><br><span class="line"><span class="keyword">function</span> unique (arr) &#123;</span><br><span class="line">  <span class="built_in">return</span> Array.from(new Set(arr))</span><br><span class="line">&#125;</span><br><span class="line">var arr = [1,1,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,15,15,<span class="literal">false</span>,<span class="literal">false</span>, undefined,undefined, null,null, NaN, NaN,<span class="string">&#x27;NaN&#x27;</span>, 0, 0, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line">console.log(unique(arr)) //[1, <span class="string">&quot;true&quot;</span>, <span class="literal">true</span>, 15, <span class="literal">false</span>, undefined, null, NaN, <span class="string">&quot;NaN&quot;</span>, 0, <span class="string">&quot;a&quot;</span>, &#123;&#125;, &#123;&#125;]</span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------</span><br><span class="line"></span><br><span class="line">// Array.slice(begin,end) 这一对象是一个由 begin 和 end 决定的原数组的浅拷贝</span><br><span class="line">const animals = [<span class="string">&#x27;ant&#x27;</span>, <span class="string">&#x27;bison&#x27;</span>, <span class="string">&#x27;camel&#x27;</span>, <span class="string">&#x27;duck&#x27;</span>, <span class="string">&#x27;elephant&#x27;</span>];</span><br><span class="line"></span><br><span class="line">console.log(animals.slice(2));</span><br><span class="line">// expected output: Array [<span class="string">&quot;camel&quot;</span>, <span class="string">&quot;duck&quot;</span>, <span class="string">&quot;elephant&quot;</span>]</span><br><span class="line"></span><br><span class="line">console.log(animals.slice(2, 4));</span><br><span class="line">// expected output: Array [<span class="string">&quot;camel&quot;</span>, <span class="string">&quot;duck&quot;</span>]</span><br><span class="line"></span><br><span class="line">console.log(animals.slice(1, 5));</span><br><span class="line">// expected output: Array [<span class="string">&quot;bison&quot;</span>, <span class="string">&quot;camel&quot;</span>, <span class="string">&quot;duck&quot;</span>, <span class="string">&quot;elephant&quot;</span>]</span><br><span class="line"></span><br><span class="line">console.log(animals.slice(-2));</span><br><span class="line">// expected output: Array [<span class="string">&quot;duck&quot;</span>, <span class="string">&quot;elephant&quot;</span>]</span><br><span class="line"></span><br><span class="line">console.log(animals.slice(2, -1));</span><br><span class="line">// expected output: Array [<span class="string">&quot;camel&quot;</span>, <span class="string">&quot;duck&quot;</span>]</span><br><span class="line"></span><br><span class="line">console.log(animals.slice());</span><br><span class="line">// expected output: Array [<span class="string">&quot;ant&quot;</span>, <span class="string">&quot;bison&quot;</span>, <span class="string">&quot;camel&quot;</span>, <span class="string">&quot;duck&quot;</span>, <span class="string">&quot;elephant&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Http版本区别与用户认证</title>
      <link href="/2018/04/12/Http-Description/"/>
      <url>/2018/04/12/Http-Description/</url>
      
        <content type="html"><![CDATA[<h1 id="Http版本区别与用户认证"><a href="#Http版本区别与用户认证" class="headerlink" title="Http版本区别与用户认证"></a><a href="">Http版本区别与用户认证</a></h1><p>HTTP协议(HyperTextTransferProtocol超文本传输协议)基于TCP&#x2F;IP通信协议来传递数据</p><h1 id="内容摘要："><a href="#内容摘要：" class="headerlink" title="内容摘要："></a>内容摘要：</h1><ul><li>Http版本</li><li>Session Cookie</li><li>Token</li><li>单点登陆</li><li>浏览器的缓存机制</li></ul><h2 id="Http版本"><a href="#Http版本" class="headerlink" title="Http版本"></a><strong>Http版本</strong></h2><h3 id="HTTP-x2F-1-0"><a href="#HTTP-x2F-1-0" class="headerlink" title="HTTP&#x2F;1.0"></a>HTTP&#x2F;1.0</h3><h4 id="每次请求都会打开一个新的TCP链接，收到响应后立即断开"><a href="#每次请求都会打开一个新的TCP链接，收到响应后立即断开" class="headerlink" title="每次请求都会打开一个新的TCP链接，收到响应后立即断开"></a>每次请求都会打开一个新的TCP链接，收到响应后立即断开</h4><h3 id="HTTP-x2F-1-1（增加了缓存控制策略）"><a href="#HTTP-x2F-1-1（增加了缓存控制策略）" class="headerlink" title="HTTP&#x2F;1.1（增加了缓存控制策略）"></a>HTTP&#x2F;1.1（增加了缓存控制策略）</h3><h4 id="1-0主要用Last-Modified和Expires做缓存判断，1-1引入了更多，如-Etag-Cache-Control-keep-alive"><a href="#1-0主要用Last-Modified和Expires做缓存判断，1-1引入了更多，如-Etag-Cache-Control-keep-alive" class="headerlink" title="1.0主要用Last-Modified和Expires做缓存判断，1.1引入了更多，如:Etag Cache-Control keep-alive"></a>1.0主要用Last-Modified和Expires做缓存判断，1.1引入了更多，如:Etag Cache-Control keep-alive</h4><h4 id="1-1默认开启持久连接（同一个TCP连接发送和接受多个http请求-x2F-应答），1-0需要手动开启connection-true"><a href="#1-1默认开启持久连接（同一个TCP连接发送和接受多个http请求-x2F-应答），1-0需要手动开启connection-true" class="headerlink" title="1.1默认开启持久连接（同一个TCP连接发送和接受多个http请求&#x2F;应答），1.0需要手动开启connection:true"></a>1.1默认开启持久连接（同一个TCP连接发送和接受多个http请求&#x2F;应答），1.0需要手动开启connection:true</h4><h4 id="http-pipeline-管道化-，允许在持久连接上可选地使用请求管道。在响应到达之前，可以将多条请求放入队列。当第一条请求通过网络流向服务器时，第二、第三条请求也可以开始发送。在高时延网络条件下，可以减低网络的环回时间提高性能"><a href="#http-pipeline-管道化-，允许在持久连接上可选地使用请求管道。在响应到达之前，可以将多条请求放入队列。当第一条请求通过网络流向服务器时，第二、第三条请求也可以开始发送。在高时延网络条件下，可以减低网络的环回时间提高性能" class="headerlink" title="http pipeline(管道化)，允许在持久连接上可选地使用请求管道。在响应到达之前，可以将多条请求放入队列。当第一条请求通过网络流向服务器时，第二、第三条请求也可以开始发送。在高时延网络条件下，可以减低网络的环回时间提高性能"></a>http pipeline(管道化)，允许在持久连接上可选地使用请求管道。在响应到达之前，可以将多条请求放入队列。当第一条请求通过网络流向服务器时，第二、第三条请求也可以开始发送。在高时延网络条件下，可以减低网络的环回时间提高性能</h4><h4 id="致命缺点-目前大部分浏览器和Web服务器，都关闭了管道化，采用非管道化模式"><a href="#致命缺点-目前大部分浏览器和Web服务器，都关闭了管道化，采用非管道化模式" class="headerlink" title="致命缺点(目前大部分浏览器和Web服务器，都关闭了管道化，采用非管道化模式)"></a>致命缺点(目前大部分浏览器和Web服务器，都关闭了管道化，采用非管道化模式)</h4><h4 id="造成队头阻塞，前一个响应未及时返回，后面的响应会被阻塞"><a href="#造成队头阻塞，前一个响应未及时返回，后面的响应会被阻塞" class="headerlink" title="造成队头阻塞，前一个响应未及时返回，后面的响应会被阻塞"></a><strong>造成队头阻塞，前一个响应未及时返回，后面的响应会被阻塞</strong></h4><h4 id="非管道化-完全串行执行，后一个请求必须在前一个响应之后发送，阻塞发生在客户端，http请求阻塞"><a href="#非管道化-完全串行执行，后一个请求必须在前一个响应之后发送，阻塞发生在客户端，http请求阻塞" class="headerlink" title="非管道化:完全串行执行，后一个请求必须在前一个响应之后发送，阻塞发生在客户端，http请求阻塞"></a>非管道化:完全串行执行，后一个请求必须在前一个响应之后发送，阻塞发生在客户端，http请求阻塞</h4><h4 id="管道化-请求可以并行发出，但响应必须串行返回。后一个响应必须在前一个响应之后。因没有序号表明顺序，只能串行接受。阻塞发生在服务端，http响应阻塞"><a href="#管道化-请求可以并行发出，但响应必须串行返回。后一个响应必须在前一个响应之后。因没有序号表明顺序，只能串行接受。阻塞发生在服务端，http响应阻塞" class="headerlink" title="管道化:请求可以并行发出，但响应必须串行返回。后一个响应必须在前一个响应之后。因没有序号表明顺序，只能串行接受。阻塞发生在服务端，http响应阻塞"></a>管道化:请求可以并行发出，但响应必须串行返回。后一个响应必须在前一个响应之后。因没有序号表明顺序，只能串行接受。阻塞发生在服务端，http响应阻塞</h4><h4 id="管道化的限制。只有幂等的请求比如-GET、HEAD-才能使用-pipelining"><a href="#管道化的限制。只有幂等的请求比如-GET、HEAD-才能使用-pipelining" class="headerlink" title="管道化的限制。只有幂等的请求比如 GET、HEAD 才能使用 pipelining"></a>管道化的限制。只有幂等的请求比如 GET、HEAD 才能使用 pipelining</h4><h3 id="解决"><a href="#解决" class="headerlink" title="解决:"></a><strong>解决:</strong></h3><h4 id="并发TCP连接-浏览器一个域名采用6-8个TCP链接，并发卜请求-一般中小型网站基本用不上，一个页面最多就2-3个接口"><a href="#并发TCP连接-浏览器一个域名采用6-8个TCP链接，并发卜请求-一般中小型网站基本用不上，一个页面最多就2-3个接口" class="headerlink" title="并发TCP连接(浏览器一个域名采用6-8个TCP链接，并发卜请求) 一般中小型网站基本用不上，一个页面最多就2-3个接口"></a>并发TCP连接(浏览器一个域名采用6-8个TCP链接，并发卜请求) 一般中小型网站基本用不上，一个页面最多就2-3个接口</h4><h4 id="域名分片-多个域名，可以建立更多的TCP链接，从而提高LTT请求的并发"><a href="#域名分片-多个域名，可以建立更多的TCP链接，从而提高LTT请求的并发" class="headerlink" title="域名分片(多个域名，可以建立更多的TCP链接，从而提高LTT请求的并发)"></a>域名分片(多个域名，可以建立更多的TCP链接，从而提高LTT请求的并发)</h4><h3 id="Http2-0-（引入帧和流）"><a href="#Http2-0-（引入帧和流）" class="headerlink" title="Http2.0 （引入帧和流）"></a>Http2.0 （引入帧和流）</h3><h4 id="新的二进制格式。-1-x基于文本"><a href="#新的二进制格式。-1-x基于文本" class="headerlink" title="新的二进制格式。 1.x基于文本"></a>新的二进制格式。 1.x基于文本</h4><h4 id="2-0方式-多路复用特性-将多个请求复用同一个tcp通道中，通过二进制分帧并且给每个帧打上流的-ID-去避免依次响应的问题，对方接收到帧之后根据-ID-拼接出流，这样就可以做到乱序响应从而避免请求时的队首阻塞问题"><a href="#2-0方式-多路复用特性-将多个请求复用同一个tcp通道中，通过二进制分帧并且给每个帧打上流的-ID-去避免依次响应的问题，对方接收到帧之后根据-ID-拼接出流，这样就可以做到乱序响应从而避免请求时的队首阻塞问题" class="headerlink" title="2.0方式(多路复用特性) 将多个请求复用同一个tcp通道中，通过二进制分帧并且给每个帧打上流的 ID 去避免依次响应的问题，对方接收到帧之后根据 ID 拼接出流，这样就可以做到乱序响应从而避免请求时的队首阻塞问题"></a>2.0方式(多路复用特性) 将多个请求复用同一个tcp通道中，通过二进制分帧并且给每个帧打上流的 ID 去避免依次响应的问题，对方接收到帧之后根据 ID 拼接出流，这样就可以做到乱序响应从而避免请求时的队首阻塞问题</h4><h4 id="头部压缩-使用encoder压缩"><a href="#头部压缩-使用encoder压缩" class="headerlink" title="头部压缩 使用encoder压缩"></a>头部压缩 使用encoder压缩</h4><h4 id="服务端推送，把客户端index-html需要的资源推送到浏览器并存在缓存中，等index加载时直接会优先读取缓存，而不用向服务器发起请求了"><a href="#服务端推送，把客户端index-html需要的资源推送到浏览器并存在缓存中，等index加载时直接会优先读取缓存，而不用向服务器发起请求了" class="headerlink" title="服务端推送，把客户端index.html需要的资源推送到浏览器并存在缓存中，等index加载时直接会优先读取缓存，而不用向服务器发起请求了"></a>服务端推送，把客户端index.html需要的资源推送到浏览器并存在缓存中，等index加载时直接会优先读取缓存，而不用向服务器发起请求了</h4><h4 id="缺陷：-为了向下兼容，服务端需要确认客户端是http1-x还是2-0，多做了一次TLS链接"><a href="#缺陷：-为了向下兼容，服务端需要确认客户端是http1-x还是2-0，多做了一次TLS链接" class="headerlink" title="缺陷： 为了向下兼容，服务端需要确认客户端是http1.x还是2.0，多做了一次TLS链接"></a><strong>缺陷：</strong> 为了向下兼容，服务端需要确认客户端是http1.x还是2.0，多做了一次TLS链接</h4><h4 id="多个请求是在同一个-TCP-管道中，这样当-HTTP-2-0-出现丢包时，整个-TCP-都要开始等待重传，那么就会阻塞该-TCP。连接中的所有请求。"><a href="#多个请求是在同一个-TCP-管道中，这样当-HTTP-2-0-出现丢包时，整个-TCP-都要开始等待重传，那么就会阻塞该-TCP。连接中的所有请求。" class="headerlink" title="多个请求是在同一个 TCP 管道中，这样当 HTTP 2.0 出现丢包时，整个 TCP 都要开始等待重传，那么就会阻塞该 TCP。连接中的所有请求。"></a>多个请求是在同一个 TCP 管道中，这样当 HTTP 2.0 出现丢包时，整个 TCP 都要开始等待重传，那么就会阻塞该 TCP。连接中的所有请求。</h4><h2 id="Session-Cookie"><a href="#Session-Cookie" class="headerlink" title="Session Cookie"></a><strong>Session Cookie</strong></h2><h4 id="Session-是存储在服务器端的文件里面，借助请求的响应在cookie上携带sessionId，服务器存在有一个sessionId与userId的映射表"><a href="#Session-是存储在服务器端的文件里面，借助请求的响应在cookie上携带sessionId，服务器存在有一个sessionId与userId的映射表" class="headerlink" title="Session 是存储在服务器端的文件里面，借助请求的响应在cookie上携带sessionId，服务器存在有一个sessionId与userId的映射表"></a>Session 是存储在服务器端的文件里面，借助请求的响应在cookie上携带sessionId，服务器存在有一个sessionId与userId的映射表</h4><h4 id="在多机部署的情况下，可用redies做中间层，缓存session，缺点是所有请求都要去redis获取session，为保障redies高可用性，必须做集群"><a href="#在多机部署的情况下，可用redies做中间层，缓存session，缺点是所有请求都要去redis获取session，为保障redies高可用性，必须做集群" class="headerlink" title="在多机部署的情况下，可用redies做中间层，缓存session，缺点是所有请求都要去redis获取session，为保障redies高可用性，必须做集群"></a>在多机部署的情况下，可用redies做中间层，缓存session，缺点是所有请求都要去redis获取session，为保障redies高可用性，必须做集群</h4><h4 id="Cookie-在发起请求和响应请求都会携带已存在的数据往返"><a href="#Cookie-在发起请求和响应请求都会携带已存在的数据往返" class="headerlink" title="Cookie 在发起请求和响应请求都会携带已存在的数据往返"></a>Cookie 在发起请求和响应请求都会携带已存在的数据往返</h4><h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a><strong>Token</strong></h2><h4 id="Token是由前端缓存在浏览器一段密文，一般通过设置请求头传递给后端，后端经过JWT去认证"><a href="#Token是由前端缓存在浏览器一段密文，一般通过设置请求头传递给后端，后端经过JWT去认证" class="headerlink" title="Token是由前端缓存在浏览器一段密文，一般通过设置请求头传递给后端，后端经过JWT去认证"></a>Token是由前端缓存在浏览器一段密文，一般通过设置请求头传递给后端，后端经过JWT去认证</h4><h2 id="单点登陆"><a href="#单点登陆" class="headerlink" title="单点登陆"></a><strong>单点登陆</strong></h2><h4 id="简称SSO，一般定义在多个应用系统中，用户只需登陆一次就可以访问所有互相信任的应用系统"><a href="#简称SSO，一般定义在多个应用系统中，用户只需登陆一次就可以访问所有互相信任的应用系统" class="headerlink" title="简称SSO，一般定义在多个应用系统中，用户只需登陆一次就可以访问所有互相信任的应用系统"></a>简称SSO，一般定义在多个应用系统中，用户只需登陆一次就可以访问所有互相信任的应用系统</h4><h4 id="一般是由登陆中间层应用去控制用户的登陆，一旦登陆成功，以后其它系统携带该用户信息访问进来时重定向并携带该用户的token返回去，再用当前应用系统验证token，向客户端响应当前用户信息"><a href="#一般是由登陆中间层应用去控制用户的登陆，一旦登陆成功，以后其它系统携带该用户信息访问进来时重定向并携带该用户的token返回去，再用当前应用系统验证token，向客户端响应当前用户信息" class="headerlink" title="一般是由登陆中间层应用去控制用户的登陆，一旦登陆成功，以后其它系统携带该用户信息访问进来时重定向并携带该用户的token返回去，再用当前应用系统验证token，向客户端响应当前用户信息"></a>一般是由登陆中间层应用去控制用户的登陆，一旦登陆成功，以后其它系统携带该用户信息访问进来时重定向并携带该用户的token返回去，再用当前应用系统验证token，向客户端响应当前用户信息</h4><h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a><strong>浏览器缓存</strong></h2><h4 id="Web-缓存大致可以分为：数据库缓存、服务器端缓存（代理服务器缓存、CDN-缓存）、浏览器缓存。"><a href="#Web-缓存大致可以分为：数据库缓存、服务器端缓存（代理服务器缓存、CDN-缓存）、浏览器缓存。" class="headerlink" title="Web 缓存大致可以分为：数据库缓存、服务器端缓存（代理服务器缓存、CDN 缓存）、浏览器缓存。"></a>Web 缓存大致可以分为：数据库缓存、服务器端缓存（代理服务器缓存、CDN 缓存）、浏览器缓存。</h4><h4 id="浏览器缓存也包含很多内容：-HTTP-缓存、indexDB、cookie、localstorage-等等。这里我们只讨论-HTTP-缓存相关内容"><a href="#浏览器缓存也包含很多内容：-HTTP-缓存、indexDB、cookie、localstorage-等等。这里我们只讨论-HTTP-缓存相关内容" class="headerlink" title="浏览器缓存也包含很多内容： HTTP 缓存、indexDB、cookie、localstorage 等等。这里我们只讨论 HTTP 缓存相关内容"></a>浏览器缓存也包含很多内容： HTTP 缓存、indexDB、cookie、localstorage 等等。这里我们只讨论 HTTP 缓存相关内容</h4><h4 id="HTTP-缓存术语："><a href="#HTTP-缓存术语：" class="headerlink" title="HTTP 缓存术语："></a>HTTP 缓存术语：</h4><h4 id="缓存命中率：从缓存中得到数据的请求数与所有请求数的比率。理想状态是越高越好。"><a href="#缓存命中率：从缓存中得到数据的请求数与所有请求数的比率。理想状态是越高越好。" class="headerlink" title="* 缓存命中率：从缓存中得到数据的请求数与所有请求数的比率。理想状态是越高越好。"></a>* 缓存命中率：从缓存中得到数据的请求数与所有请求数的比率。理想状态是越高越好。</h4><h4 id="过期内容：超过设置的有效时间，被标记为“陈旧”的内容。通常过期内容不能用于回复客户端的请求，必须重新向源服务器请求新的内容或者验证缓存的内容是否仍然准备。"><a href="#过期内容：超过设置的有效时间，被标记为“陈旧”的内容。通常过期内容不能用于回复客户端的请求，必须重新向源服务器请求新的内容或者验证缓存的内容是否仍然准备。" class="headerlink" title="* 过期内容：超过设置的有效时间，被标记为“陈旧”的内容。通常过期内容不能用于回复客户端的请求，必须重新向源服务器请求新的内容或者验证缓存的内容是否仍然准备。"></a>* 过期内容：超过设置的有效时间，被标记为“陈旧”的内容。通常过期内容不能用于回复客户端的请求，必须重新向源服务器请求新的内容或者验证缓存的内容是否仍然准备。</h4><h4 id="验证：验证缓存中的过期内容是否仍然有效，验证通过的话刷新过期时间。"><a href="#验证：验证缓存中的过期内容是否仍然有效，验证通过的话刷新过期时间。" class="headerlink" title="* 验证：验证缓存中的过期内容是否仍然有效，验证通过的话刷新过期时间。"></a>* 验证：验证缓存中的过期内容是否仍然有效，验证通过的话刷新过期时间。</h4><h4 id="失效：失效就是把内容从缓存中移除。当内容发生改变时就必须移除失效的内容。"><a href="#失效：失效就是把内容从缓存中移除。当内容发生改变时就必须移除失效的内容。" class="headerlink" title="* 失效：失效就是把内容从缓存中移除。当内容发生改变时就必须移除失效的内容。"></a>* 失效：失效就是把内容从缓存中移除。当内容发生改变时就必须移除失效的内容。</h4><h4 id="浏览器缓存主要是-HTTP-协议定义的缓存机制。HTML-meta-标签，例如"><a href="#浏览器缓存主要是-HTTP-协议定义的缓存机制。HTML-meta-标签，例如" class="headerlink" title="浏览器缓存主要是 HTTP 协议定义的缓存机制。HTML meta 标签，例如"></a>浏览器缓存主要是 HTTP 协议定义的缓存机制。HTML meta 标签，例如</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;META HTTP-EQUIV=<span class="string">&quot;Pragma&quot;</span> CONTENT=<span class="string">&quot;no-store&quot;</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="含义是让浏览器不缓存当前页面。但是代理服务器不解析-HTML-内容，一般应用广泛的是用-HTTP-头信息控制缓存"><a href="#含义是让浏览器不缓存当前页面。但是代理服务器不解析-HTML-内容，一般应用广泛的是用-HTTP-头信息控制缓存" class="headerlink" title="含义是让浏览器不缓存当前页面。但是代理服务器不解析 HTML 内容，一般应用广泛的是用 HTTP 头信息控制缓存"></a>含义是让浏览器不缓存当前页面。但是代理服务器不解析 HTML 内容，一般应用广泛的是用 HTTP 头信息控制缓存</h4><h4 id="浏览器缓存分为强缓存和协商缓存，浏览器加载一个页面的简单流程如下："><a href="#浏览器缓存分为强缓存和协商缓存，浏览器加载一个页面的简单流程如下：" class="headerlink" title="浏览器缓存分为强缓存和协商缓存，浏览器加载一个页面的简单流程如下："></a>浏览器缓存分为强缓存和协商缓存，浏览器加载一个页面的简单流程如下：</h4><h4 id="1-浏览器先根据这个资源的http头信息来判断是否命中强缓存。如果命中则直接加在缓存中的资源，并不会将请求发送到服务器。（强缓存）"><a href="#1-浏览器先根据这个资源的http头信息来判断是否命中强缓存。如果命中则直接加在缓存中的资源，并不会将请求发送到服务器。（强缓存）" class="headerlink" title="1. 浏览器先根据这个资源的http头信息来判断是否命中强缓存。如果命中则直接加在缓存中的资源，并不会将请求发送到服务器。（强缓存）"></a>1. 浏览器先根据这个资源的http头信息来判断是否命中强缓存。如果命中则直接加在缓存中的资源，并不会将请求发送到服务器。（强缓存）</h4><h4 id="2-如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。服务器来判断浏览器本地缓存是否失效。若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源。（协商缓存）"><a href="#2-如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。服务器来判断浏览器本地缓存是否失效。若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源。（协商缓存）" class="headerlink" title="2. 如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。服务器来判断浏览器本地缓存是否失效。若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源。（协商缓存）"></a>2. 如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。服务器来判断浏览器本地缓存是否失效。若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源。（协商缓存）</h4><h4 id="3-如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。（新的请求）"><a href="#3-如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。（新的请求）" class="headerlink" title="3. 如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。（新的请求）"></a>3. 如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。（新的请求）</h4><h4 id="命中强缓存时，浏览器并不会将请求发送给服务器。在Chrome的开发者工具中看到http的返回码是200，但是在Size列会显示为-from-cache-。"><a href="#命中强缓存时，浏览器并不会将请求发送给服务器。在Chrome的开发者工具中看到http的返回码是200，但是在Size列会显示为-from-cache-。" class="headerlink" title="命中强缓存时，浏览器并不会将请求发送给服务器。在Chrome的开发者工具中看到http的返回码是200，但是在Size列会显示为(from cache)。"></a>命中强缓存时，浏览器并不会将请求发送给服务器。在Chrome的开发者工具中看到http的返回码是200，但是在Size列会显示为(from cache)。</h4><h4 id="疑问解答"><a href="#疑问解答" class="headerlink" title="疑问解答"></a><strong>疑问解答</strong></h4><h4 id="为什么我更新我更新前端资源文件，从新打开链接需要刷新一下才能生效呢？"><a href="#为什么我更新我更新前端资源文件，从新打开链接需要刷新一下才能生效呢？" class="headerlink" title="为什么我更新我更新前端资源文件，从新打开链接需要刷新一下才能生效呢？"></a>为什么我更新我更新前端资源文件，从新打开链接需要刷新一下才能生效呢？</h4><h4 id="因为这时候由于你客户端近期在你更新之前是已经访问过该链接，而且缓存过期时间还没失效，这时候命中的是强缓存，当刷新网页时，跳过强缓存，但是会检查协商缓存；浏览器会将资源加载请求发送到服务器，服务器检测到当前加载资源已更新，则将完整的资源返回给浏览器。"><a href="#因为这时候由于你客户端近期在你更新之前是已经访问过该链接，而且缓存过期时间还没失效，这时候命中的是强缓存，当刷新网页时，跳过强缓存，但是会检查协商缓存；浏览器会将资源加载请求发送到服务器，服务器检测到当前加载资源已更新，则将完整的资源返回给浏览器。" class="headerlink" title="因为这时候由于你客户端近期在你更新之前是已经访问过该链接，而且缓存过期时间还没失效，这时候命中的是强缓存，当刷新网页时，跳过强缓存，但是会检查协商缓存；浏览器会将资源加载请求发送到服务器，服务器检测到当前加载资源已更新，则将完整的资源返回给浏览器。"></a>因为这时候由于你客户端近期在你更新之前是已经访问过该链接，而且缓存过期时间还没失效，这时候命中的是强缓存，当刷新网页时，跳过强缓存，但是会检查协商缓存；浏览器会将资源加载请求发送到服务器，服务器检测到当前加载资源已更新，则将完整的资源返回给浏览器。</h4><h4 id="强制刷新页面，浏览器会直接忽略本地的缓存（有缓存也会认为本地没有缓存），在请求中加上字段：Cache-Control-no-cache（或-Pragma-no-cache），发包向服务重新拉取文件。"><a href="#强制刷新页面，浏览器会直接忽略本地的缓存（有缓存也会认为本地没有缓存），在请求中加上字段：Cache-Control-no-cache（或-Pragma-no-cache），发包向服务重新拉取文件。" class="headerlink" title="强制刷新页面，浏览器会直接忽略本地的缓存（有缓存也会认为本地没有缓存），在请求中加上字段：Cache-Control:no-cache（或 Pragma:no-cache），发包向服务重新拉取文件。"></a>强制刷新页面，浏览器会直接忽略本地的缓存（有缓存也会认为本地没有缓存），在请求中加上字段：Cache-Control:no-cache（或 Pragma:no-cache），发包向服务重新拉取文件。</h4><h4 id="Dom-Storage-存储机制"><a href="#Dom-Storage-存储机制" class="headerlink" title="Dom Storage 存储机制"></a>Dom Storage 存储机制</h4><h4 id="sessionStorage浏览器缓存（浏览器关闭则移除）-和-localStorage本地存储（不清楚则永久存在）（5M）"><a href="#sessionStorage浏览器缓存（浏览器关闭则移除）-和-localStorage本地存储（不清楚则永久存在）（5M）" class="headerlink" title="sessionStorage浏览器缓存（浏览器关闭则移除） 和 localStorage本地存储（不清楚则永久存在）（5M）"></a>sessionStorage浏览器缓存（浏览器关闭则移除） 和 localStorage本地存储（不清楚则永久存在）（5M）</h4><h4 id="应用场景：-页面意外关闭的数据恢复"><a href="#应用场景：-页面意外关闭的数据恢复" class="headerlink" title="应用场景： 页面意外关闭的数据恢复"></a>应用场景： 页面意外关闭的数据恢复</h4><h4 id="Application-Cache-机制"><a href="#Application-Cache-机制" class="headerlink" title="Application Cache 机制"></a>Application Cache 机制</h4><h4 id="浏览器在首次加载-HTML-文件时，会解析-manifest-属性，-lt-html-manifest-quot-demo-html-appcache-quot-gt-并读取-manifest-文件，获取-Section：CACHE-MANIFEST-下要缓存的文件列表，再对文件缓存。（一般游戏的应用的比较多）"><a href="#浏览器在首次加载-HTML-文件时，会解析-manifest-属性，-lt-html-manifest-quot-demo-html-appcache-quot-gt-并读取-manifest-文件，获取-Section：CACHE-MANIFEST-下要缓存的文件列表，再对文件缓存。（一般游戏的应用的比较多）" class="headerlink" title="浏览器在首次加载 HTML 文件时，会解析 manifest 属性，&lt;html manifest=&quot;demo_html.appcache&quot;&gt; 并读取 manifest 文件，获取 Section：CACHE MANIFEST 下要缓存的文件列表，再对文件缓存。（一般游戏的应用的比较多）"></a>浏览器在首次加载 HTML 文件时，会解析 manifest 属性，<code>&lt;html manifest=&quot;demo_html.appcache&quot;&gt;</code> 并读取 manifest 文件，获取 Section：CACHE MANIFEST 下要缓存的文件列表，再对文件缓存。（一般游戏的应用的比较多）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line"><span class="comment"># 2012-02-21 v1.0.0</span></span><br><span class="line">/theme.css</span><br><span class="line">/logo.gif</span><br><span class="line">/main.js</span><br><span class="line"> </span><br><span class="line">NETWORK:</span><br><span class="line">login.asp</span><br><span class="line"> </span><br><span class="line">FALLBACK:</span><br><span class="line">/html/ /offline.html </span><br></pre></td></tr></table></figure><h4 id="AppCache-在首次加载生成后，也有更新机制。被缓存的文件如果要更新，需要更新-manifest-文件。因为浏览器在下次加载时，除了会默认使用缓存外，还会在后台检查-manifest-文件有没有修改（byte-by-byte-。发现有修改，就会重新获取-manifest-文件，对-Section：CACHE-MANIFEST-下文件列表检查更新。manifest-文件与缓存文件的检查更新也遵守浏览器缓存机制。"><a href="#AppCache-在首次加载生成后，也有更新机制。被缓存的文件如果要更新，需要更新-manifest-文件。因为浏览器在下次加载时，除了会默认使用缓存外，还会在后台检查-manifest-文件有没有修改（byte-by-byte-。发现有修改，就会重新获取-manifest-文件，对-Section：CACHE-MANIFEST-下文件列表检查更新。manifest-文件与缓存文件的检查更新也遵守浏览器缓存机制。" class="headerlink" title="AppCache 在首次加载生成后，也有更新机制。被缓存的文件如果要更新，需要更新 manifest 文件。因为浏览器在下次加载时，除了会默认使用缓存外，还会在后台检查 manifest 文件有没有修改（byte by byte)。发现有修改，就会重新获取 manifest 文件，对 Section：CACHE MANIFEST 下文件列表检查更新。manifest 文件与缓存文件的检查更新也遵守浏览器缓存机制。"></a>AppCache 在首次加载生成后，也有更新机制。被缓存的文件如果要更新，需要更新 manifest 文件。因为浏览器在下次加载时，除了会默认使用缓存外，还会在后台检查 manifest 文件有没有修改（byte by byte)。发现有修改，就会重新获取 manifest 文件，对 Section：CACHE MANIFEST 下文件列表检查更新。manifest 文件与缓存文件的检查更新也遵守浏览器缓存机制。</h4><h3 id="移动端-Web-加载性能（缓存）优化"><a href="#移动端-Web-加载性能（缓存）优化" class="headerlink" title="移动端 Web 加载性能（缓存）优化"></a><strong>移动端 Web 加载性能（缓存）优化</strong></h3><h4 id="通过对一些-H5页面进行调试及抓包发现，每次加载一个-H5页面，都会有较多的请求。除了-HTML-主-URL-自身的请求外，HTML外部引用的-JS、CSS、字体文件、图片都是一个独立的-HTTP-请求，每一个请求都串行的（可能有连接复用）。这么多请求串起来，再加上浏览器解析、渲染的时间，Web-整体的加载时间变得较长；请求文件越多，消耗的流量也会越多。我们可综合使用上面说到几种缓存机制，来帮助我们优化-Web-的加载性能。"><a href="#通过对一些-H5页面进行调试及抓包发现，每次加载一个-H5页面，都会有较多的请求。除了-HTML-主-URL-自身的请求外，HTML外部引用的-JS、CSS、字体文件、图片都是一个独立的-HTTP-请求，每一个请求都串行的（可能有连接复用）。这么多请求串起来，再加上浏览器解析、渲染的时间，Web-整体的加载时间变得较长；请求文件越多，消耗的流量也会越多。我们可综合使用上面说到几种缓存机制，来帮助我们优化-Web-的加载性能。" class="headerlink" title="通过对一些 H5页面进行调试及抓包发现，每次加载一个 H5页面，都会有较多的请求。除了 HTML 主 URL 自身的请求外，HTML外部引用的 JS、CSS、字体文件、图片都是一个独立的 HTTP 请求，每一个请求都串行的（可能有连接复用）。这么多请求串起来，再加上浏览器解析、渲染的时间，Web 整体的加载时间变得较长；请求文件越多，消耗的流量也会越多。我们可综合使用上面说到几种缓存机制，来帮助我们优化 Web 的加载性能。"></a>通过对一些 H5页面进行调试及抓包发现，每次加载一个 H5页面，都会有较多的请求。除了 HTML 主 URL 自身的请求外，HTML外部引用的 JS、CSS、字体文件、图片都是一个独立的 HTTP 请求，每一个请求都串行的（可能有连接复用）。这么多请求串起来，再加上浏览器解析、渲染的时间，Web 整体的加载时间变得较长；请求文件越多，消耗的流量也会越多。我们可综合使用上面说到几种缓存机制，来帮助我们优化 Web 的加载性能。</h4>]]></content>
      
      
      
        <tags>
            
            <tag> Http Https Session Cookie Token </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS对象常用的操作方法</title>
      <link href="/2018/04/11/JS%E5%AF%B9%E8%B1%A1%E5%B8%B8%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/"/>
      <url>/2018/04/11/JS%E5%AF%B9%E8%B1%A1%E5%B8%B8%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="JS对象常用的操作方法"><a href="#JS对象常用的操作方法" class="headerlink" title="JS对象常用的操作方法"></a>JS对象常用的操作方法</h2><ul><li>Object.assign(obj1,obj2) 对象合并，相同key后者替换前者</li><li>JSON.parse(JSON.stringify(obj1))对象深拷贝</li><li>Object.values(obj) 枚举对象属性值的数组 Object.keys(obj) 枚举对象keys的数组</li><li>Object.prototype.toString.call(obj) &#x3D;&#x3D;&#x3D; ‘[object object] 判断对象 || constructor</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 复制一个对象</span><br><span class="line">const obj = &#123; a: 1 &#125;;</span><br><span class="line">const copy = Object.assign(&#123;&#125;, obj);</span><br><span class="line">console.log(copy); // &#123; a: 1 &#125;</span><br><span class="line"></span><br><span class="line">// 对象深拷贝Deep Clone</span><br><span class="line">const  obj1 = &#123; a: 0 , b: &#123; c: 0&#125;&#125;;</span><br><span class="line"><span class="built_in">let</span> obj3 = JSON.parse(JSON.stringify(obj1));</span><br><span class="line">obj1.a = 4;</span><br><span class="line">obj1.b.c = 4;</span><br><span class="line"></span><br><span class="line">//obj3: &#123; a: 0, b: &#123; c: 0&#125;&#125;</span><br><span class="line"></span><br><span class="line">// Object.values(obj) Object.keys(obj)</span><br><span class="line">var obj = &#123; 0: <span class="string">&#x27;a&#x27;</span>, 1: <span class="string">&#x27;b&#x27;</span>, 2: <span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line">console.log(Object.values(obj)); // [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>] </span><br><span class="line">console.log(Object.keys(obj)); // [<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>]</span><br><span class="line"></span><br><span class="line">// Object.prototype.toString.call(obj) === <span class="string">&#x27;[object object]&#x27;</span></span><br><span class="line">var o = &#123;&#125;;</span><br><span class="line">o.constructor === Object; // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">var o = new Object;</span><br><span class="line">o.constructor === Object; // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">var a = [];</span><br><span class="line">a.constructor === Array; // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">var a = new Array;</span><br><span class="line">a.constructor === Array // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">var n = new Number(3);</span><br><span class="line">n.constructor === Number; // <span class="literal">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Object </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS操作DOM的方法与实践</title>
      <link href="/2018/04/11/JS%E6%93%8D%E4%BD%9CDOM%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
      <url>/2018/04/11/JS%E6%93%8D%E4%BD%9CDOM%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="DOM的基本介绍（提纲）"><a href="#DOM的基本介绍（提纲）" class="headerlink" title="DOM的基本介绍（提纲）"></a>DOM的基本介绍（提纲）</h2><h3 id="html文档中的内容以”树形结构”呈现-即大家常说的-文档树"><a href="#html文档中的内容以”树形结构”呈现-即大家常说的-文档树" class="headerlink" title="html文档中的内容以”树形结构”呈现,即大家常说的: 文档树;"></a>html文档中的内容以”树形结构”呈现,即大家常说的: 文档树;</h3><h3 id="文档树中的每个组成部分-称为之”节点”-即-Node类型-文档中的每一个具体的节点-都是一个Node对象-节点对象"><a href="#文档树中的每个组成部分-称为之”节点”-即-Node类型-文档中的每一个具体的节点-都是一个Node对象-节点对象" class="headerlink" title="文档树中的每个组成部分,称为之”节点”, 即 Node类型,文档中的每一个具体的节点,都是一个Node对象:节点对象;"></a>文档树中的每个组成部分,称为之”节点”, 即 Node类型,文档中的每一个具体的节点,都是一个Node对象:节点对象;</h3><h3 id="文档树中-最重要的三类节点是-Document文档节点-Element元素节点-Text文本节点"><a href="#文档树中-最重要的三类节点是-Document文档节点-Element元素节点-Text文本节点" class="headerlink" title="文档树中,最重要的三类节点是: Document文档节点, Element元素节点, Text文本节点"></a>文档树中,最重要的三类节点是: Document文档节点, Element元素节点, Text文本节点</h3><h2 id="选择页面元素的方法"><a href="#选择页面元素的方法" class="headerlink" title="选择页面元素的方法"></a>选择页面元素的方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// html</span><br><span class="line">&lt;h3 <span class="built_in">id</span>=<span class="string">&quot;header&quot;</span> class=<span class="string">&quot;red&quot;</span> style=<span class="string">&quot;color:green;&quot;</span> title=<span class="string">&quot;php.cn&quot;</span>&gt;Text&lt;/h3&gt;</span><br><span class="line">// js</span><br><span class="line">//获取当前ID为header的节点</span><br><span class="line">document.getElementById(<span class="string">&#x27;header&#x27;</span>);</span><br><span class="line">// 获取当前class为red的所有节点，返回一个数组</span><br><span class="line">document.getElementByClassName(<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line"></span><br><span class="line">// 获取当前h3所有节点，返回一个数组</span><br><span class="line">document.getElementByTagName(<span class="string">&#x27;h3&#x27;</span>)</span><br><span class="line">// 获取当前input标签 name为username所有节点，返回一个数组</span><br><span class="line">document.getElementByName(<span class="string">&#x27;username&#x27;</span>);</span><br><span class="line"></span><br><span class="line">document.querySelector(); //返回第一个匹配元素</span><br><span class="line">document.querySelectorAll(); //返回所有匹配元素</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="DOM元素的基本操作"><a href="#DOM元素的基本操作" class="headerlink" title="DOM元素的基本操作"></a>DOM元素的基本操作</h2><ul><li>创建:createElement(‘p’);</li><li>插入:parentNode.appendChild(‘p’);</li><li>删除:removeChild(‘p’);</li><li>更新:replaceChild(‘p’,old);</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;<span class="built_in">head</span>&gt;</span><br><span class="line">&lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;实战热身&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;info&quot;</span>&gt;</span><br><span class="line">&lt;button&gt;提交&lt;/button&gt;</span><br><span class="line">&lt;br&gt;&lt;br&gt;</span><br><span class="line">&lt;ul&gt;&lt;/ul&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">//美化样式</span><br><span class="line">    <span class="built_in">let</span> a = document.getElementsByTagName(<span class="string">&#x27;input&#x27;</span>)[0];</span><br><span class="line">    <span class="built_in">let</span> b = document.getElementsByTagName(<span class="string">&#x27;button&#x27;</span>)[0];</span><br><span class="line">    console.log(a)</span><br><span class="line">    a.setAttribute(<span class="string">&#x27;style&#x27;</span>,<span class="string">&#x27;height: 8px;width: 258px;border: 1px solid #ccc;margin-top: 6px;font-size: 16px;padding: 20px;float: left;&#x27;</span>);</span><br><span class="line">b.setAttribute(<span class="string">&#x27;style&#x27;</span>,<span class="string">&#x27;height: 50px;width: 100px;border: 1px solid #ccc;margin-top: 6px;font-size: 20px;background: #FF6A00;color: white;border: none;float: left;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">//获取元素</span><br><span class="line">  <span class="built_in">let</span> input = document.getElementsByName(<span class="string">&#x27;info&#x27;</span>)[0];</span><br><span class="line">  <span class="built_in">let</span> button = document.getElementsByTagName(<span class="string">&#x27;button&#x27;</span>)[0];</span><br><span class="line">  <span class="built_in">let</span> ul = document.getElementsByTagName(<span class="string">&#x27;ul&#x27;</span>)[0];</span><br><span class="line"></span><br><span class="line">  button.onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">   <span class="built_in">let</span> li = document.createElement(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">   li.innerHTML = input.value; //文本框的内容</span><br><span class="line">   ul.appendChild(li); //将用户信息显示到列表中</span><br><span class="line">   input.value = <span class="string">&#x27;&#x27;</span>; //将文本框内容清空</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS遍历数组的方法</title>
      <link href="/2018/04/10/JS%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2018/04/10/JS%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="js遍历数组的几种方法"><a href="#js遍历数组的几种方法" class="headerlink" title="js遍历数组的几种方法"></a>js遍历数组的几种方法</h1><ul><li>for 最快</li><li>forEach (不产生新的数组，效率没有map快)</li><li>map （产生新的数组）</li><li>for…….of </li><li>for….in(效率最慢，一般用与遍历对象)</li><li>some and every (返回布尔值)</li><li>filter （返回符合条件的某一项） findIndex （返回符合条件的下标，无则-1）</li><li>while (条件循环)</li></ul><h2 id="第一种：for循环，也是最常见的"><a href="#第一种：for循环，也是最常见的" class="headerlink" title="第一种：for循环，也是最常见的"></a>第一种：for循环，也是最常见的</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">  console.log(arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach(<span class="keyword">function</span>(item)&#123;</span><br><span class="line">  console.log(item)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const newArr = arr.map(<span class="keyword">function</span>(item)&#123;</span><br><span class="line">  console.log(item)</span><br><span class="line">  <span class="built_in">return</span> item</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> item of arr)&#123;</span><br><span class="line">  console.log(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for…-in-遍历对象"><a href="#for…-in-遍历对象" class="headerlink" title="for…..in 遍历对象"></a>for…..in 遍历对象</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">  console.log(key + <span class="string">&#x27;---&#x27;</span> + obj[key] )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="some-and-every-返回布尔值"><a href="#some-and-every-返回布尔值" class="headerlink" title="some and every (返回布尔值)"></a>some and every (返回布尔值)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const array = [1, 2, 3, 4, 5];</span><br><span class="line">const someBool = array.some((item)=&gt;&#123;</span><br><span class="line">  <span class="keyword">if</span>(item &gt; 2) &#123;</span><br><span class="line">    // 满足条件中止循环</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// someBool 为<span class="literal">true</span></span><br><span class="line">const everyBool = array.every((item)=&gt;&#123;</span><br><span class="line">  <span class="keyword">if</span>(item &gt; 2) </span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  // 只要有一项不符合就中止循环 <span class="built_in">return</span> <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line">// everyBool为<span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="filter-（返回符合条件的所有项）-findIndex-（返回符合条件的下标，无则-1）"><a href="#filter-（返回符合条件的所有项）-findIndex-（返回符合条件的下标，无则-1）" class="headerlink" title="filter （返回符合条件的所有项） findIndex （返回符合条件的下标，无则-1）"></a>filter （返回符合条件的所有项） findIndex （返回符合条件的下标，无则-1）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const array = [1, 2, 3, 4, 5];</span><br><span class="line">const filterItem = array.filter((item)=&gt;&#123;</span><br><span class="line">  <span class="keyword">if</span>(item &gt; 2) &#123;</span><br><span class="line">    <span class="built_in">return</span> item</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// filterItem: [3,4,5]</span><br><span class="line">const findIndex = array.findIndex((item)=&gt;&#123;</span><br><span class="line">  <span class="keyword">if</span>(item &gt; 2) &#123;</span><br><span class="line">    <span class="built_in">return</span> item</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// findIndex: 2</span><br></pre></td></tr></table></figure><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> i = 0</span><br><span class="line"><span class="keyword">while</span>(i &lt; arr.length)&#123;</span><br><span class="line">  i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建我的博客</title>
      <link href="/2018/04/10/First-Blog/"/>
      <url>/2018/04/10/First-Blog/</url>
      
        <content type="html"><![CDATA[<h1 id="从零开始搭建我的博客"><a href="#从零开始搭建我的博客" class="headerlink" title="从零开始搭建我的博客"></a><a href="https://github.com/13725102796/13725102796.github.io">从零开始搭建我的博客</a></h1><h3 id="node-v16-14-0-npm-8-3-1"><a href="#node-v16-14-0-npm-8-3-1" class="headerlink" title="node v16.14.0 npm 8.3.1"></a><code>node v16.14.0</code> <code>npm 8.3.1</code></h3><h1 id="搭建步骤："><a href="#搭建步骤：" class="headerlink" title="搭建步骤："></a>搭建步骤：</h1><ul><li>GitHub创建个人仓库</li><li>安装Hexo</li><li>使用Hexo</li><li>命令简写</li></ul><h2 id="GitHub创建个人仓库"><a href="#GitHub创建个人仓库" class="headerlink" title="GitHub创建个人仓库"></a><strong>GitHub创建个人仓库</strong></h2><h4 id="在Github创建新仓库，仓库名应该为：用户名-github-io-比如我的仓库名为13725102796-github-io"><a href="#在Github创建新仓库，仓库名应该为：用户名-github-io-比如我的仓库名为13725102796-github-io" class="headerlink" title="在Github创建新仓库，仓库名应该为：用户名.github.io 比如我的仓库名为13725102796.github.io"></a>在Github创建新仓库，仓库名应该为：<code>用户名.github.io</code> 比如我的仓库名为<code>13725102796.github.io</code></h4><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a><strong>安装Hexo</strong></h2><h4 id="Hexo-是一个快速、简单、强大的博客框架。你可以用Markdown-（或其他标记语言）写帖子，Hexo-会在几秒钟内生成带有漂亮主题的静态文件。非常快捷，方便。"><a href="#Hexo-是一个快速、简单、强大的博客框架。你可以用Markdown-（或其他标记语言）写帖子，Hexo-会在几秒钟内生成带有漂亮主题的静态文件。非常快捷，方便。" class="headerlink" title="Hexo 是一个快速、简单、强大的博客框架。你可以用Markdown （或其他标记语言）写帖子，Hexo 会在几秒钟内生成带有漂亮主题的静态文件。非常快捷，方便。"></a>Hexo 是一个快速、简单、强大的博客框架。你可以用Markdown （或其他标记语言）写帖子，Hexo 会在几秒钟内生成带有漂亮主题的静态文件。非常快捷，方便。</h4><h4 id="我们先来全局安装-Hexo-初始化项目，在切进对应目录："><a href="#我们先来全局安装-Hexo-初始化项目，在切进对应目录：" class="headerlink" title="我们先来全局安装 Hexo,初始化项目，在切进对应目录："></a>我们先来全局安装 Hexo,初始化项目，在切进对应目录：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br><span class="line">$ hexo init Blog</span><br><span class="line">$ <span class="built_in">cd</span> Blog</span><br></pre></td></tr></table></figure><h2 id="使用Hexo"><a href="#使用Hexo" class="headerlink" title="使用Hexo"></a><strong>使用Hexo</strong></h2><h4 id="创建一篇文章-hexo-n-quot-First-Blog-quot-，对应会在-x2F-sources-x2F-posts-x2F-文件下面生成一个First-Blog-md-文件，在里面编辑好博文"><a href="#创建一篇文章-hexo-n-quot-First-Blog-quot-，对应会在-x2F-sources-x2F-posts-x2F-文件下面生成一个First-Blog-md-文件，在里面编辑好博文" class="headerlink" title="创建一篇文章 hexo n &quot;First Blog&quot;，对应会在&#x2F;sources&#x2F;_posts&#x2F;文件下面生成一个First-Blog.md 文件，在里面编辑好博文"></a>创建一篇文章<code> hexo n &quot;First Blog&quot;</code>，对应会在&#x2F;sources&#x2F;_posts&#x2F;文件下面生成一个<code>First-Blog.md</code> 文件，在里面编辑好博文</h4><h4 id="修改根目录-config-yml配置文件"><a href="#修改根目录-config-yml配置文件" class="headerlink" title="修改根目录_config.yml配置文件"></a><a href="">修改根目录_config.yml配置文件</a></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: https://github.com/13725102796/13725102796.github.io </span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h4 id="执行-清除缓存并重新生成静态资源并本地运行"><a href="#执行-清除缓存并重新生成静态资源并本地运行" class="headerlink" title="执行 清除缓存并重新生成静态资源并本地运行"></a>执行 清除缓存并重新生成静态资源并本地运行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><h4 id="发布到Github上-，需要安装一个发布github的插件，再发布"><a href="#发布到Github上-，需要安装一个发布github的插件，再发布" class="headerlink" title="发布到Github上 ，需要安装一个发布github的插件，再发布"></a>发布到Github上 ，需要安装一个发布github的插件，再发布</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><h4 id="通过https-13725102796-github-io-即可访问"><a href="#通过https-13725102796-github-io-即可访问" class="headerlink" title="通过https://13725102796.github.io 即可访问"></a>通过<a href="https://13725102796.github.io/">https://13725102796.github.io</a> 即可访问</h4><h2 id="命令简写"><a href="#命令简写" class="headerlink" title="命令简写"></a><strong>命令简写</strong></h2><h4 id="新建一篇文章-hexo-n-quot-我的博客-quot-x3D-x3D-hexo-new-quot-我的博客-quot"><a href="#新建一篇文章-hexo-n-quot-我的博客-quot-x3D-x3D-hexo-new-quot-我的博客-quot" class="headerlink" title="新建一篇文章 hexo n &quot;我的博客&quot; &#x3D;&#x3D; hexo new &quot;我的博客&quot;"></a>新建一篇文章 <code>hexo n &quot;我的博客&quot;</code> &#x3D;&#x3D; <code>hexo new &quot;我的博客&quot;</code></h4><h4 id="生成静态资源文件-hexo-g-x3D-x3D-hexo-generate"><a href="#生成静态资源文件-hexo-g-x3D-x3D-hexo-generate" class="headerlink" title="生成静态资源文件 hexo g &#x3D;&#x3D; hexo generate "></a>生成静态资源文件 <code>hexo g</code> &#x3D;&#x3D; <code>hexo generate </code></h4><h4 id="启动本地服务预览-hexo-s-x3D-x3D-hexo-server"><a href="#启动本地服务预览-hexo-s-x3D-x3D-hexo-server" class="headerlink" title="启动本地服务预览 hexo s &#x3D;&#x3D; hexo server "></a>启动本地服务预览 <code>hexo s</code> &#x3D;&#x3D; <code>hexo server </code></h4><h4 id="部署到线上-hexo-d-x3D-x3D-hexo-deploy"><a href="#部署到线上-hexo-d-x3D-x3D-hexo-deploy" class="headerlink" title="部署到线上 hexo d &#x3D;&#x3D; hexo deploy "></a>部署到线上 <code>hexo d</code> &#x3D;&#x3D; <code>hexo deploy </code></h4>]]></content>
      
      
      
        <tags>
            
            <tag> Next Hexo Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/04/09/hello-world/"/>
      <url>/2018/04/09/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Next Hexo Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
