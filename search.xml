<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>React 服务端构建后，白屏问题</title>
      <link href="/2024/03/10/React-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%9E%84%E5%BB%BA%E5%90%8E%EF%BC%8C%E7%99%BD%E5%B1%8F%E9%97%AE%E9%A2%98/"/>
      <url>/2024/03/10/React-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%9E%84%E5%BB%BA%E5%90%8E%EF%BC%8C%E7%99%BD%E5%B1%8F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>在每次打包完发布代码后，访问都会出现白屏现象。提示页面丢失。<br>一开始以为和Vue一样是浏览器缓存问题，需要新增文件后缀。<br>但是发现其实后缀已经改变了，脚手架基于Vite生成。<br>确认配置没有问题后，再次排查发现，只有改动过的页面才会存在该问题<br>原因是新版的React改成了分片打包，防止首次加载index.js代码超重的问题。<br>同时还加了一层缓存。这确实是不错的技术方案，不过也带来了一些副作用。</p><h3 id="处理方案"><a href="#处理方案" class="headerlink" title="处理方案"></a>处理方案</h3><p>保留原有的技术方案，增加处理副作用的流程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 路由采用动态加载的方式</span></span><br><span class="line"> element: useLazy(() =&gt; import(<span class="string">&#x27;@/pages/home/index&#x27;</span>)),</span><br><span class="line"><span class="comment"># 可以在 useLazy 加一层处理，如果加载该页面失败，就重新刷新页面。</span></span><br><span class="line">/**</span><br><span class="line"> * @<span class="keyword">function</span> useResize 使用的类型</span><br><span class="line"> */</span><br><span class="line">import &#123; Skeleton &#125; from <span class="string">&quot;antd-mobile&quot;</span>;</span><br><span class="line">import React from <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="built_in">export</span> namespace Type &#123;</span><br><span class="line">  <span class="built_in">export</span> <span class="built_in">type</span> defRC = &#123;</span><br><span class="line">    default: React.ComponentType&lt;any&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">const lazyRetry = <span class="keyword">function</span> (componentImport, name) &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    // 动态导入组件</span><br><span class="line">    componentImport()</span><br><span class="line">      .<span class="keyword">then</span>(resolve)</span><br><span class="line">      .catch((error) =&gt; &#123;</span><br><span class="line">        // 检查是否已经刷新过了，防止无限循环。因为有可能该路径本身就是失效了</span><br><span class="line">        const hasRefreshed = JSON.parse(</span><br><span class="line">          window.sessionStorage.getItem(`<span class="variable">$&#123;name&#125;</span>-retry-lazy-refreshed`) ||</span><br><span class="line">            <span class="string">&quot;false&quot;</span></span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (!hasRefreshed) &#123;</span><br><span class="line">          // 没有刷新过，需要刷新页面刷新</span><br><span class="line">          window.sessionStorage.setItem(`<span class="variable">$&#123;name&#125;</span>-retry-lazy-refreshed`, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">          <span class="built_in">return</span> window.location.reload(); //</span><br><span class="line">        &#125;</span><br><span class="line">        reject(error);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> useLazy(callback) &#123;</span><br><span class="line">  // const LazyRC = React.lazy(callback);</span><br><span class="line">  // @ts-ignore</span><br><span class="line">  const LazyRC = React.lazy(() =&gt; lazyRetry(callback, <span class="string">&quot;test&quot;</span>));</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    &lt;React.Suspense fallback=&#123;&lt;Skeleton animated /&gt;&#125;&gt;</span><br><span class="line">      &lt;LazyRC /&gt;</span><br><span class="line">    &lt;/React.Suspense&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>React H5权限拦截</title>
      <link href="/2024/02/17/React-H5%E6%9D%83%E9%99%90%E6%8B%A6%E6%88%AA/"/>
      <url>/2024/02/17/React-H5%E6%9D%83%E9%99%90%E6%8B%A6%E6%88%AA/</url>
      
        <content type="html"><![CDATA[<h3 id="功能明细"><a href="#功能明细" class="headerlink" title="功能明细"></a>功能明细</h3><ol><li>页面功能划分，游客与用户之间的页面访问控制</li><li>游客只能访问指定的页面</li><li>超出权限的，需要打回登陆流程</li></ol><h3 id="实现明细"><a href="#实现明细" class="headerlink" title="实现明细"></a>实现明细</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过路由前置拦截去实现，React 与 Vue 的实现方式有所差异</span></span><br><span class="line"><span class="comment"># Vue 是通过BeforeRouter，路由前置拦截；React相当于设置一个全局页面开关，由这个页面去控制，改次跳转的路径是否成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># route.js</span></span><br><span class="line">const routes: RouteObject[] = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    element: &lt;AuthRoute /&gt;,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        element: &lt;Navigate to=<span class="string">&quot;/index&quot;</span> replace /&gt;,</span><br><span class="line">        handle: &#123; title: <span class="string">&#x27;研学甄选&#x27;</span> &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">     ...</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/index-no-user&#x27;</span>,</span><br><span class="line">    element: useLazy(() =&gt; import(<span class="string">&#x27;@/pages/404&#x27;</span>)),</span><br><span class="line">    handle: &#123; title: <span class="string">&#x27;无法访问&#x27;</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">];</span><br><span class="line"><span class="built_in">export</span> default routes;</span><br><span class="line"></span><br><span class="line"><span class="comment"># AuthRoute 就相当于一个总页面开关</span></span><br><span class="line">import &#123; useSelector &#125; from <span class="string">&#x27;react-redux&#x27;</span>;</span><br><span class="line">import &#123; RootState &#125; from <span class="string">&#x27;@/reduces/user&#x27;</span>;</span><br><span class="line"><span class="built_in">export</span> const whiteList = [</span><br><span class="line">  <span class="string">&#x27;/application&#x27;</span>,</span><br><span class="line">  ...</span><br><span class="line">];</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">AuthRoute</span></span>() &#123;</span><br><span class="line">  const matches = useMatches();</span><br><span class="line">  console.log(matches);</span><br><span class="line">  const outlet = useOutlet();</span><br><span class="line">  const isLogined = <span class="literal">false</span>;</span><br><span class="line">  const user = useSelector((state: RootState) =&gt; state.user.userMsg);</span><br><span class="line">  // 根据白名单的登录状态进行鉴权</span><br><span class="line">  const page = useMemo(() =&gt; &#123;</span><br><span class="line">    const &#123; pathname &#125; = matches[1];</span><br><span class="line">    const isInWL = whiteList.includes(pathname);</span><br><span class="line"></span><br><span class="line">    const isLogined = user.mobile ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isInWL) <span class="built_in">return</span> &lt;Outlet /&gt;;</span><br><span class="line">    <span class="keyword">if</span> (isLogined) <span class="built_in">return</span> &lt;Outlet /&gt;;</span><br><span class="line">    <span class="built_in">return</span> &lt;Navigate to=<span class="string">&quot;/index-no-user?type=1&quot;</span> replace /&gt;;</span><br><span class="line">  &#125;, [isLogined, matches, outlet]);</span><br><span class="line">  // 路由后置钩子更改网页标题</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    const title = (matches[1].handle as any)?.title;</span><br><span class="line">    const isHasTitle = typeof title === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (isHasTitle &amp;&amp; title) &#123;</span><br><span class="line">      document.title = title;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [matches]);</span><br><span class="line">  <span class="built_in">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>H5&amp;&amp;小程序一键换肤</title>
      <link href="/2023/11/28/H5-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%80%E9%94%AE%E6%8D%A2%E8%82%A4/"/>
      <url>/2023/11/28/H5-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%80%E9%94%AE%E6%8D%A2%E8%82%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="一键换肤功能分析"><a href="#一键换肤功能分析" class="headerlink" title="一键换肤功能分析"></a>一键换肤功能分析</h3><ol><li>通过配置好的指定颜色，一键切换</li><li>与UI提前沟通好需要换肤的模块组件等页面功能</li></ol><h3 id="功能难点"><a href="#功能难点" class="headerlink" title="功能难点"></a>功能难点</h3><ol><li>与后台管理系统换肤的实现方法有差异，后台直接通过全局类注入，再动态切换该类即可。<br>但是小程序的本质是多页面的。虽然基于Uni开发，看起来像是单页面的。但是最终生成的都是一个页面一个wxml文件。</li><li>小程序包大小有限制，不能超过2M。所以不能无限制的设置N个颜色。因为最终所有颜色类都会构建生成到小程序的wxss。</li></ol><h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过Vuex去存储全局的颜色类名</span></span><br><span class="line">SETTHEMECLASS(state, data) &#123;</span><br><span class="line">   state.<span class="variable">$themeClass</span> = data</span><br><span class="line">   uni.setStorageSync(<span class="string">&#x27;themeClass&#x27;</span>, data);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment"># 将主题色文件单独维护</span></span><br><span class="line">@import url(<span class="string">&quot;@/common/styles/theme-app.css&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># themes.scss 通过scss批量设置多颜色class，这样就写一次就可以了 </span></span><br><span class="line">@mixin setTheme(<span class="variable">$color</span>,<span class="variable">$rgba</span>)&#123;</span><br><span class="line">   // 日历组件 </span><br><span class="line">  .uni-calendar-item--checked &#123;</span><br><span class="line">    background:  <span class="variable">$color</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量生成类</span></span><br><span class="line"> @import <span class="string">&#x27;@/common/styles/themes.scss&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$bg</span>-6C61E6: <span class="comment">#6C61E6;</span></span><br><span class="line"><span class="variable">$rgba</span>-6C61E6: rgba(108,97,230,0.06);</span><br><span class="line">.THEME-6C61E6 &#123;</span><br><span class="line">  @include setTheme(<span class="variable">$bg</span>-6C61E6,<span class="variable">$rgba</span>-6C61E6)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$bg</span>-1167FF: <span class="comment">#1167FF ;</span></span><br><span class="line"><span class="variable">$rgba</span>-1167FF: rgba(17,103,255,0.06);</span><br><span class="line"></span><br><span class="line">.THEME-1167FF &#123;</span><br><span class="line">  @include setTheme(<span class="variable">$bg</span>-1167FF,<span class="variable">$rgba</span>-1167FF)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$bg</span>-0AB8A0: <span class="comment">#0AB8A0;</span></span><br><span class="line"><span class="variable">$rgba</span>-0AB8A0: rgba(10,184,160,0.06);</span><br><span class="line"></span><br><span class="line">.THEME-0AB8A0 &#123;</span><br><span class="line">  @include setTheme(<span class="variable">$bg</span>-0AB8A0,<span class="variable">$rgba</span>-0AB8A0)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$bg</span>-F7BA1E: <span class="comment">#F7BA1E;</span></span><br><span class="line"><span class="variable">$rgba</span>-F7BA1E: rgba(247,186,30,0.06);</span><br><span class="line"></span><br><span class="line">.THEME-F7BA1E &#123;</span><br><span class="line">  @include setTheme(<span class="variable">$bg</span>-F7BA1E,<span class="variable">$rgba</span>-F7BA1E)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$bg</span>-F14356: <span class="comment">#F14356;</span></span><br><span class="line"><span class="variable">$rgba</span>-F14356: rgba(241,67,86,0.06);</span><br><span class="line"></span><br><span class="line">.THEME-F14356 &#123;</span><br><span class="line">  @include setTheme(<span class="variable">$bg</span>-F14356,<span class="variable">$rgba</span>-F14356)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 使用方法</span></span><br><span class="line">&lt;button</span><br><span class="line">  class=<span class="string">&quot;btn-default&quot;</span></span><br><span class="line">  :style=<span class="string">&quot;&#123; background: GETCOLOR &#125;&quot;</span></span><br><span class="line">  @click=<span class="string">&quot;navigateTo&quot;</span></span><br><span class="line">&gt;</span><br><span class="line">  添加孩子</span><br><span class="line">&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">### 当前页面覆盖,顶层DIV设置</span></span><br><span class="line">&lt;view</span><br><span class="line">    class=<span class="string">&quot;container&quot;</span></span><br><span class="line">    :class=<span class="string">&quot;GETTHEME&quot;</span></span><br><span class="line">  &gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/view&gt;</span><br><span class="line"><span class="comment"># GETCOLOR 是全局的计算方法，获取当前系统的主题色</span></span><br><span class="line"><span class="comment"># GETTHEME 获取当前系统的主题</span></span><br><span class="line"> computed: &#123;</span><br><span class="line">    <span class="function"><span class="title">GETTHEME</span></span>() &#123;</span><br><span class="line">      <span class="built_in">return</span> <span class="string">&#x27;THEME-&#x27;</span> + this.<span class="variable">$store</span>.state.<span class="variable">$themeClass</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">GETCOLOR</span></span>() &#123;</span><br><span class="line">      <span class="built_in">return</span> <span class="string">&#x27;#&#x27;</span> + this.<span class="variable">$store</span>.state.<span class="variable">$themeClass</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>H5签名手写板功能的实现</title>
      <link href="/2023/11/11/H5%E7%AD%BE%E5%90%8D%E6%89%8B%E5%86%99%E6%9D%BF%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/11/11/H5%E7%AD%BE%E5%90%8D%E6%89%8B%E5%86%99%E6%9D%BF%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="实现功能明细"><a href="#实现功能明细" class="headerlink" title="实现功能明细"></a>实现功能明细</h3><ol><li>实现一个手写版，支持通过手指滑动绘制线条</li><li>将绘制的线条保存成图片</li><li>图片粘贴到文件制定签名的位置</li></ol><h3 id="功能难点"><a href="#功能难点" class="headerlink" title="功能难点"></a>功能难点</h3><ol><li>手写版需要兼容小程序</li><li>用户在操作过程可能会存在横竖屏的方式，导致签名图片颠倒</li><li>绘制线条涉及到Canvas，Canvas在小程序中表现并不理想</li></ol><p>好在该功能市场有成熟的产品可以参考，说明该功能是可以通过技术去实现的</p><h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 采用 lime-signature 插件完成在手指滑动绘制线条的操作</span></span><br><span class="line">&lt;l-signature</span><br><span class="line">   disableScroll</span><br><span class="line">   backgroundColor=<span class="string">&quot;rgba(0,0,0,0)&quot;</span></span><br><span class="line">   ref=<span class="string">&quot;signatureRef&quot;</span></span><br><span class="line">   :penColor=<span class="string">&quot;penColor&quot;</span></span><br><span class="line">   :penSize=<span class="string">&quot;penSize&quot;</span></span><br><span class="line">   :openSmooth=<span class="string">&quot;openSmooth&quot;</span></span><br><span class="line">   @handleIsEmpty=<span class="string">&quot;handleIsEmpty&quot;</span></span><br><span class="line">&gt;&lt;/l-signature&gt;</span><br><span class="line">import lSignature from <span class="string">&quot;@/uni_modules/lime-signature/components/l-signature/l-signature&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过判断屏幕宽高来确定用户是否出于横屏还是竖屏</span></span><br><span class="line"><span class="comment"># 因为有些用户会锁死竖屏，所以要做一些兼容处理</span></span><br><span class="line"><span class="comment"># 通过 handleCanvas 去判断采用横屏手绘板还是竖屏手绘板</span></span><br><span class="line"><span class="comment"># 然后上传给后端合成签名协议</span></span><br><span class="line"><span class="function"><span class="title">onShow</span></span>() &#123;</span><br><span class="line"> console.log(uni.getSystemInfoSync().windowHeight);</span><br><span class="line"> const initDate = uni.getSystemInfoSync();</span><br><span class="line"> <span class="keyword">if</span> (initDate.windowWidth &gt; initDate.windowHeight) &#123;</span><br><span class="line">   this.handleCanvas = <span class="literal">false</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   this.handleCanvas = <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> const windowResizeCallback = (res) =&gt; &#123;</span><br><span class="line">   <span class="keyword">if</span> (res.size.windowWidth &gt; res.size.windowHeight) &#123;</span><br><span class="line">     this.handleCanvas = <span class="literal">false</span>;</span><br><span class="line">     this.getStatus = <span class="literal">true</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     this.handleCanvas = <span class="literal">true</span>;</span><br><span class="line">     this.getStatus = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> uni.onWindowResize(windowResizeCallback);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 canvasToTempFilePath 方法，获取到用户的签名图片临时路径</span></span><br><span class="line"></span><br><span class="line">this.<span class="variable">$refs</span>.signatureRef.canvasToTempFilePath(&#123;</span><br><span class="line">  success: async (res) =&gt; &#123;</span><br><span class="line">            // 是否为空画板 无签名</span><br><span class="line">            // console.log(res.isEmpty);</span><br><span class="line">            <span class="keyword">if</span> (res.isEmpty) &#123;</span><br><span class="line">              // alert(<span class="string">&quot;签名不能为空！&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              this.imgBase64 = res.tempFilePath;</span><br><span class="line">              // console.log(res.tempFilePath);</span><br><span class="line">              // <span class="comment">#ifdef MP-WEIXIN</span></span><br><span class="line">              base64ToUrl(res.tempFilePath, (url) =&gt; &#123;</span><br><span class="line">                this.img = url;</span><br><span class="line">                this.handleSign();</span><br><span class="line">              &#125;);</span><br><span class="line"></span><br><span class="line">              // <span class="comment">#endif</span></span><br><span class="line">              // <span class="comment">#ifdef H5</span></span><br><span class="line">              this.img = res.tempFilePath;</span><br><span class="line">              this.handleSign();</span><br><span class="line">              // <span class="comment">#endif</span></span><br><span class="line">            &#125;</span><br><span class="line">            // 生成图片的临时路径</span><br><span class="line">            // app | H5 | 微信小程序 生成的是<span class="built_in">base64</span></span><br><span class="line">          &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="插件存在的问题"><a href="#插件存在的问题" class="headerlink" title="插件存在的问题"></a>插件存在的问题</h3><p>在开发的过程中，发现插件并没有达到自己的理想效果<br>比如，初始化时，并没有提供该手绘有没有签名，导致可以直接生成一张空白的图片。<br>需要监听手绘板，只有签名了才能生成并上传图片<br>翻阅源码后，增加了是否为空的回调</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">touchEnd(e) &#123;</span><br><span class="line">   <span class="keyword">if</span> (!this.canvasEl) <span class="built_in">return</span>;</span><br><span class="line">   this.isStart = <span class="literal">false</span>;</span><br><span class="line">   this.canvasEl.dispatchEvent(<span class="string">&quot;touchend&quot;</span>, wrapEvent(e));</span><br><span class="line">   this.<span class="variable">$emit</span>(<span class="string">&quot;handleIsEmpty&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Chatgpt 前端层技术</title>
      <link href="/2023/08/17/Chatgpt-%E5%89%8D%E7%AB%AF%E5%B1%82%E6%8A%80%E6%9C%AF/"/>
      <url>/2023/08/17/Chatgpt-%E5%89%8D%E7%AB%AF%E5%B1%82%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="通讯层"><a href="#通讯层" class="headerlink" title="通讯层"></a>通讯层</h3><p>采用websocket的方式与后端通讯</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># isJSON 处理 后端返回的通讯信息</span></span><br><span class="line">import &#123; isJSON &#125; from <span class="string">&quot;@/common/index&quot;</span></span><br><span class="line">class WebSocketClass &#123;</span><br><span class="line">  constructor(url) &#123;</span><br><span class="line">    this.lockReconnect = <span class="literal">false</span>;  // 是否开始重连</span><br><span class="line">    this.ws = null;</span><br><span class="line">    this.wsUrl = <span class="string">&quot;&quot;</span>;  // ws 地址</span><br><span class="line">    this.globalCallback = null;  // 回调方法</span><br><span class="line">    this.userClose = <span class="literal">false</span>;  // 是否主动关闭</span><br><span class="line">    this.createWebSocket(url);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  createWebSocket(url) &#123;</span><br><span class="line">    <span class="keyword">if</span> (typeof (WebSocket) === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">      this.Toast(<span class="string">&quot;您的浏览器不支持WebSocket，无法获取数据&quot;</span>);</span><br><span class="line">      <span class="built_in">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    this.wsUrl = url;</span><br><span class="line">    try &#123;</span><br><span class="line">      // 创建一个this.ws对象【发送、接收、关闭socket都由这个对象操作】</span><br><span class="line">      this.ws = new WebSocket(this.wsUrl);</span><br><span class="line">      this.initEventHandle();</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      this.reconnect(url);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 初始化</span><br><span class="line">  <span class="function"><span class="title">initEventHandle</span></span>() &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 监听WebSocket连接打开成功</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    this.ws.onopen = (event) =&gt; &#123;</span><br><span class="line">      console.log(<span class="string">&quot;WebSocket连接打开&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 连接关闭后的回调函数</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    this.ws.onclose = (event) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!this.userClose) &#123;</span><br><span class="line">        this.reconnect(this.wsUrl); //重连</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 报错时的回调函数</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    this.ws.onerror = (event) =&gt; &#123;</span><br><span class="line">      console.log(<span class="string">&#x27;连接异常&#x27;</span>)</span><br><span class="line">      <span class="keyword">if</span> (!this.userClose) &#123;</span><br><span class="line">        this.reconnect(this.wsUrl); //重连</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 收到服务器数据后的回调函数</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    this.ws.onmessage = (event) =&gt; &#123;</span><br><span class="line">      console.log(event)</span><br><span class="line">      <span class="keyword">if</span> (isJSON(event.data)) &#123;</span><br><span class="line">        const jsonobject = JSON.parse(event.data)</span><br><span class="line">        this.globalCallback(jsonobject)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        this.globalCallback(event)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 关闭ws连接回调</span><br><span class="line">  reconnect(url) &#123;</span><br><span class="line">    <span class="keyword">if</span> (this.lockReconnect) <span class="built_in">return</span>;</span><br><span class="line">    this.ws.close();</span><br><span class="line">    this.lockReconnect = <span class="literal">true</span>;  // 关闭重连，没连接上会一直重连，设置延迟避免请求过多</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      this.createWebSocket(url);</span><br><span class="line">      this.lockReconnect = <span class="literal">false</span>;</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 发送信息方法</span><br><span class="line">  webSocketSendMsg(msg) &#123;</span><br><span class="line">    const token = uni.getStorageSync(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line"></span><br><span class="line">    this.ws &amp;&amp; this.ws.send(msg)</span><br><span class="line">    // this.ws &amp;&amp; this.ws.send(&#123;</span><br><span class="line">    //   data: msg,</span><br><span class="line">    //   <span class="function"><span class="title">success</span></span>() &#123;</span><br><span class="line">    //     console.log(<span class="string">&quot;消息发送成功&quot;</span>);</span><br><span class="line">    //   &#125;,</span><br><span class="line">    //   fail(err) &#123;</span><br><span class="line">    //     console.log(<span class="string">&quot;关闭失败&quot;</span>, err)</span><br><span class="line">    //   &#125;</span><br><span class="line">    // &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 获取ws返回的数据方法</span><br><span class="line">  getWebSocketMsg(callback) &#123;</span><br><span class="line">    this.globalCallback = callback</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 关闭ws方法</span><br><span class="line">  <span class="function"><span class="title">closeSocket</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (this.ws) &#123;</span><br><span class="line">      this.userClose = <span class="literal">true</span>;</span><br><span class="line">      this.ws.close(&#123;</span><br><span class="line">        success(res) &#123;</span><br><span class="line">          console.log(<span class="string">&quot;关闭成功&quot;</span>, res)</span><br><span class="line">        &#125;,</span><br><span class="line">        fail(err) &#123;</span><br><span class="line">          console.log(<span class="string">&quot;关闭失败&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">export</span> default WebSocketClass;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># index.vue</span></span><br><span class="line">import WS from <span class="string">&quot;@/common/websocket.js&quot;</span>;</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  mixins: [showBtn],</span><br><span class="line">  <span class="function"><span class="title">data</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      ws: null, //websocket对象</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">created</span></span>() &#123;</span><br><span class="line">    this.createWebSocket();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">beforeDestroy</span></span>() &#123;</span><br><span class="line">    this.ws &amp;&amp; this.ws.closeSocket();</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    // 新建会话</span><br><span class="line">    <span class="function"><span class="title">createWebSocket</span></span>() &#123;</span><br><span class="line">      this.ws &amp;&amp; this.ws.closeSocket();</span><br><span class="line">      const token = uni.getStorageSync(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">      this.ws = new WS(<span class="string">&quot;wss://&quot;</span> + baseWebSocketUrl + <span class="string">&quot;/ws/&quot;</span> + token + <span class="string">&quot;-0&quot;</span>); //区分聊天（-0）和应用（-1）</span><br><span class="line">      // 回调-服务器返回数据</span><br><span class="line">      this.ws.getWebSocketMsg((data) =&gt; &#123;</span><br><span class="line">        this.requesting = <span class="literal">false</span>;</span><br><span class="line">        clearTimeout(this.timer);</span><br><span class="line">        <span class="keyword">if</span> (data.status == 0) &#123;</span><br><span class="line">          this.tempText = this.tempText + data.content;</span><br><span class="line">          this.showText(this.tempText);</span><br><span class="line">          this.records[this.records.length - 1].content = this.tempText;</span><br><span class="line">          this.status = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (data.status == 2) &#123;</span><br><span class="line">          this.tempText = this.tempText + data.content;</span><br><span class="line">          this.status = <span class="literal">false</span>;</span><br><span class="line">          this.showText(this.tempText);</span><br><span class="line">          this.records[this.records.length - 1].content = this.tempText;</span><br><span class="line">          this.tempText = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    // 逐字显示</span><br><span class="line">    showText(text) &#123;</span><br><span class="line">      this.latestContent = text.slice(0, this.index);</span><br><span class="line">      this.scrollToBottom();</span><br><span class="line">      <span class="keyword">if</span> (this.index &gt;= text.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (this.status) &#123;</span><br><span class="line">          // this.timer = setTimeout(() =&gt; this.showText(text), 50);</span><br><span class="line">          <span class="built_in">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          this.waiting = <span class="literal">false</span>;</span><br><span class="line">          clearTimeout(this.timer);</span><br><span class="line"></span><br><span class="line">          this.index = 1;</span><br><span class="line">          <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      this.index++;</span><br><span class="line"></span><br><span class="line">      this.timer = setTimeout(() =&gt; this.showText(text), 50);</span><br><span class="line">    &#125;,</span><br><span class="line">    // 发送问题</span><br><span class="line">    sendQuestion(question) &#123;</span><br><span class="line">      this.requesting = <span class="literal">true</span>;</span><br><span class="line">      this.ws.webSocketSendMsg(question);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>React 高阶组件实战技巧</title>
      <link href="/2023/08/06/React-%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E5%AE%9E%E6%88%98%E6%8A%80%E5%B7%A7/"/>
      <url>/2023/08/06/React-%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E5%AE%9E%E6%88%98%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="开发一个可复用的滚动列表组件"><a href="#开发一个可复用的滚动列表组件" class="headerlink" title="开发一个可复用的滚动列表组件"></a>开发一个可复用的滚动列表组件</h1><p>满足功能如下：</p><ol><li>滚动分页请求加载</li><li>分页结束提示 到底了</li><li>没有数据时提示为空</li><li>满足项目大部分分页场景，可复用</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">import * as React from <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line">import &#123; InfiniteScroll, List &#125; from <span class="string">&#x27;antd-mobile&#x27;</span>;</span><br><span class="line">import &#123; mockRequest &#125; from <span class="string">&#x27;./mock-request&#x27;</span>;</span><br><span class="line"></span><br><span class="line">import &#123; useState, useEffect, useCallback &#125; from <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line">import &#123; setSessionStorage &#125; from <span class="string">&#x27;@/utils/localStorage&#x27;</span>;</span><br><span class="line">// interface Props &#123;</span><br><span class="line">//   url: string;</span><br><span class="line">//   params?: Record&lt;string | number | symbol, any&gt;;</span><br><span class="line">// &#125;</span><br><span class="line"><span class="built_in">let</span> pageSize = 10;</span><br><span class="line"></span><br><span class="line">// console.log(<span class="string">&quot;reset Page&quot;</span>);</span><br><span class="line">const ScrollList = (</span><br><span class="line">  Com: any,</span><br><span class="line">  url: string,</span><br><span class="line">  params: Object = &#123;&#125;,</span><br><span class="line">  ComProps: Object = &#123;&#125;,</span><br><span class="line">  noDataCb?: Function</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">  const [data, setData] = useState&lt;string[]&gt;([]);</span><br><span class="line">  const [hasMore, setHasMore] = useState(<span class="literal">true</span>);</span><br><span class="line">  const [pageNo, setpageNo] = useState(0);</span><br><span class="line"></span><br><span class="line">  async <span class="keyword">function</span> <span class="function"><span class="title">loadMore</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> tempNo = pageNo + 1;</span><br><span class="line"></span><br><span class="line">    const temp = &#123; pageSize, pageNo: tempNo, ...params &#125;;</span><br><span class="line"></span><br><span class="line">    const data = await window.<span class="variable">$api</span>(url, temp);</span><br><span class="line">    const append = data.data.content || data.data;</span><br><span class="line">    // const append = await mockRequest();</span><br><span class="line"></span><br><span class="line">    setpageNo(tempNo);</span><br><span class="line">    setData((val) =&gt; [...val, ...append]);</span><br><span class="line">    setHasMore(append.length == temp.pageSize);</span><br><span class="line">    <span class="keyword">if</span> (tempNo == 1 &amp;&amp; append.length == 0 &amp;&amp; noDataCb) &#123;</span><br><span class="line">      console.log(<span class="string">&#x27;no data&#x27;</span>);</span><br><span class="line">      noDataCb();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const init = useCallback(() =&gt; &#123;</span><br><span class="line">    setpageNo(0);</span><br><span class="line">    setData([]);</span><br><span class="line">    loadMore();</span><br><span class="line">  &#125;, []);</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    // const temp = Object.assign(&#123;&#125;, &#123; pageSize, pageNo &#125;, params);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &#123;data.map((item, index) =&gt; (</span><br><span class="line">        &lt;Com key=&#123;index&#125; item=&#123;item&#125; &#123;...ComProps&#125; init=&#123;init&#125;&gt;&lt;/Com&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">      &lt;InfiniteScroll loadMore=&#123;loadMore&#125; hasMore=&#123;hasMore&#125; /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default ScrollList;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用方法</span></span><br><span class="line"> const Category = () =&gt; &#123;</span><br><span class="line">    <span class="built_in">return</span> ScrollList(</span><br><span class="line">      <span class="comment"># GoodCard 为商品卡片组件</span></span><br><span class="line">      GoodCard,</span><br><span class="line">      <span class="comment"># 接口API</span></span><br><span class="line">      <span class="string">&#x27;index/getGoodList&#x27;</span>,</span><br><span class="line">      <span class="comment"># 请求携带参数</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">type</span>: 1,</span><br><span class="line">        categoryId: <span class="built_in">id</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment"># 组件参数</span></span><br><span class="line">      &#123; showTag: <span class="literal">true</span> &#125;,</span><br><span class="line">      <span class="comment"># 无数据请求完成回调</span></span><br><span class="line">      () =&gt; &#123;</span><br><span class="line">        navigate(<span class="string">&#x27;/index-no-user?type=1&#x27;</span>, &#123; replace: <span class="literal">true</span> &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>深度学习和神经网络框架PyTorch 安装</title>
      <link href="/2023/07/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%92%8C%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6PyTorch-%E5%AE%89%E8%A3%85/"/>
      <url>/2023/07/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%92%8C%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6PyTorch-%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h3 id="安装遇到的问题"><a href="#安装遇到的问题" class="headerlink" title="安装遇到的问题"></a>安装遇到的问题</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pip3 install torch torchvision </span><br><span class="line"><span class="comment"># 执行会遇到问题，提示</span></span><br><span class="line">This environment is externally managed</span><br><span class="line">╰─&gt; To install Python packages system-wide, try brew install</span><br><span class="line">    xyz, <span class="built_in">where</span> xyz is the package you are trying to</span><br><span class="line">    install.</span><br><span class="line">If you wish to install a non-brew-packaged Python package,</span><br><span class="line">create a virtual environment using python3 -m venv path/to/venv.</span><br><span class="line">Then use path/to/venv/bin/python and path/to/venv/bin/pip.</span><br><span class="line"></span><br><span class="line">If you wish to install a non-brew packaged Python application,</span><br><span class="line">it may be easiest to use pipx install xyz, <span class="built_in">which</span> will manage a</span><br><span class="line">virtual environment <span class="keyword">for</span> you. Make sure you have pipx installed.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 大致意思就是需要一个外部环境来承载这些，不能直接装进系统里面</span></span><br><span class="line"></span><br><span class="line">python3 -m venv path/to/venv</span><br><span class="line"><span class="built_in">cd</span> path/to/venv/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来就是重点，需要使用 path/to/venv/bin 文件下面的程序去安装</span></span><br><span class="line">./pip3 install torch torchvision </span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用时也需要引用 外部环境的python去运行</span></span><br><span class="line">../../../path/to/venv/bin/python3 test.py</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="RuntimeError-Numpy-is-not-available"><a href="#RuntimeError-Numpy-is-not-available" class="headerlink" title="RuntimeError: Numpy is not available"></a>RuntimeError: Numpy is not available</h3><p>这种就是Python 与 Numpy 包版本不兼容问题，只需要安装 制定 Numpy 版本即可<br>下面是 Numpy 与 Python 版本兼容文档<br><a href="https://numpy.org/news/">https://numpy.org/news/</a></p><p>我的是 Python 3.12.0 需要安装 NumPy 1.26.0</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./pip uninstall numpy  </span><br><span class="line">./pip install numpy==1.26.0   </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>React页面开发实操指南</title>
      <link href="/2023/07/10/React%E9%A1%B5%E9%9D%A2%E5%BC%80%E5%8F%91%E5%AE%9E%E6%93%8D%E6%8C%87%E5%8D%97/"/>
      <url>/2023/07/10/React%E9%A1%B5%E9%9D%A2%E5%BC%80%E5%8F%91%E5%AE%9E%E6%93%8D%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="样式开发"><a href="#样式开发" class="headerlink" title="样式开发"></a>样式开发</h1><p>主流引用 hooks 库中的 useClass ，方便条件渲染判断。<br>个人感觉比较鸡肋，故而很少使用。<br>因为其内部是通过函数转化的，每次渲染页面用到的地方都会先跑一遍该函数，将其转化成正常的className</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> useClass(style: CSSModuleClasses) &#123;</span><br><span class="line">  <span class="built_in">return</span> (className: string | string[] | Record&lt;string, boolean&gt;) =&gt; &#123;</span><br><span class="line">    const arrStr = (arr: string[]) =&gt; &#123;</span><br><span class="line">      <span class="built_in">return</span> arr.map((item) =&gt; style[item] || item).<span class="built_in">join</span>(<span class="string">&quot; &quot;</span>) + <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    // 数组写法</span><br><span class="line">    <span class="keyword">if</span> (Array.isArray(className)) &#123;</span><br><span class="line">      <span class="built_in">return</span> arrStr(className);</span><br><span class="line">    &#125;</span><br><span class="line">    // 字符串写法</span><br><span class="line">    <span class="keyword">if</span> (typeof className === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">      const target = className.replace(/ +/g, <span class="string">&quot;,&quot;</span>).<span class="built_in">split</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">      <span class="built_in">return</span> arrStr(target);</span><br><span class="line">    &#125;</span><br><span class="line">    // 对象写法</span><br><span class="line">    const target = Object.keys(className).filter((key) =&gt; className[key]);</span><br><span class="line">    <span class="built_in">return</span> arrStr(target);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>本质是，减少代码量，增加客户端的渲染压力。</p><h1 id="页面开发重点-useState-useEffect"><a href="#页面开发重点-useState-useEffect" class="headerlink" title="页面开发重点 useState useEffect"></a>页面开发重点 useState useEffect</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># useState 是定义一个 可以驱动视图的变量</span></span><br><span class="line">const [showUs, setShowUs] = useState(<span class="literal">false</span>);</span><br><span class="line">setShowUs 可以改变 showUs 的值，showUs变化，进而更新绑定的视图模块</span><br><span class="line"></span><br><span class="line">&lt;List.Item onClick=&#123;() =&gt; setShowUs(<span class="literal">true</span>)&#125; &gt;</span><br><span class="line">  联系客服</span><br><span class="line">&lt;/List.Item&gt;</span><br><span class="line"> &lt;CenterPopup</span><br><span class="line">  visible=&#123;showUs&#125;</span><br><span class="line">  onMaskClick=&#123;() =&gt; &#123;</span><br><span class="line">    setShowUs(<span class="literal">false</span>);</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&gt;</span><br><span class="line">  &lt;div className=&#123;styles.myContent&#125;&gt;</span><br><span class="line">    &lt;div className=&#123;styles.btnBox&#125;&gt;</span><br><span class="line">      &lt;a href=<span class="string">&quot;tel:020-XXXXXXXX&quot;</span>&gt;</span><br><span class="line">        &lt;div className=&#123;styles.confirm&#125;&gt;立即拨打&lt;/div&gt;</span><br><span class="line">      &lt;/a&gt;</span><br><span class="line">      &lt;div className=&#123;styles.cancel&#125; onClick=&#123;() =&gt; setShowUs(<span class="literal">false</span>)&#125;&gt;</span><br><span class="line">        取消</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/CenterPopup&gt;</span><br><span class="line"><span class="comment"># 至始至终都是单向的数据流，这是与Vue中v-model，最本质的区别</span></span><br><span class="line"><span class="comment"># 使用setState进行状态更新时，React可能会将多个setState调用合并成一个，并在稍后异步地更新组件</span></span><br><span class="line"><span class="comment"># 即时更新的方法</span></span><br><span class="line">this.setState((props)=&gt;(&#123;</span><br><span class="line">  num:props.num+1 // 实现state的num属性值加1</span><br><span class="line">&#125;));</span><br><span class="line"><span class="comment"># useEffect 包含生命周期的开始阶段和更新阶段以及销毁阶段</span></span><br><span class="line"></span><br><span class="line"> useEffect(() =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (user &amp;&amp; user.mobile) &#123;</span><br><span class="line">      window.<span class="variable">$api</span>(<span class="string">&#x27;index/getUserDetail&#x27;</span>).<span class="keyword">then</span>((res) =&gt; &#123;</span><br><span class="line">        localStorage.setItem(<span class="string">&#x27;userMsg&#x27;</span>, JSON.stringify(res.data));</span><br><span class="line">        <span class="keyword">if</span> (!localStorage.getItem(<span class="string">&#x27;promoterStatus&#x27;</span>)) &#123;</span><br><span class="line">          localStorage.setItem(<span class="string">&#x27;promoterId&#x27;</span>, res.data.promoterId);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> ()=&gt;&#123;</span><br><span class="line">      <span class="comment">#销毁需要TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [<span class="string">&#x27;监听需要的参数&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两者都只能写在函数的第一层，因为它们都是通过数组下标来识别执行哪个方法。写到第二层会抛出异常了</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="数据流-Store-用的是-react-redux"><a href="#数据流-Store-用的是-react-redux" class="headerlink" title="数据流 Store 用的是 react-redux"></a>数据流 Store 用的是 react-redux</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useSelector, useDispatch &#125; from <span class="string">&#x27;react-redux&#x27;</span>;</span><br><span class="line"><span class="comment"># 获取store中的数据</span></span><br><span class="line">const user = useSelector((state: RootState) =&gt; state.user.userMsg);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 事件分发 </span></span><br><span class="line">const dispatch = useDispatch();</span><br><span class="line">dispatch(setUserMsg([]));</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义数据 切片 toolkit</span></span><br><span class="line">import &#123; createSlice &#125; from <span class="string">&quot;@reduxjs/toolkit&quot;</span>;</span><br><span class="line">import &#123; getLocalStorage, setLocalStorage &#125; from <span class="string">&quot;@/utils/localStorage&quot;</span>;</span><br><span class="line">const counterSlice = createSlice(&#123;</span><br><span class="line">  name: <span class="string">&quot;userMsg&quot;</span>,</span><br><span class="line">  initialState: &#123;</span><br><span class="line">    orderUserMsg: getLocalStorage(<span class="string">&quot;orderUserMsg&quot;</span>, <span class="string">&quot;array&quot;</span>) || [],</span><br><span class="line">    selectSchool: getLocalStorage(<span class="string">&quot;selectSchool&quot;</span>, <span class="string">&quot;object&quot;</span>) || &#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    setUserMsg: (state, action) =&gt; &#123;</span><br><span class="line">      console.log(action);</span><br><span class="line">      setLocalStorage(<span class="string">&quot;orderUserMsg&quot;</span>, action.payload);</span><br><span class="line">      state.orderUserMsg = action.payload;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">export</span> const &#123; setUserMsg, setSelectSchool &#125; = counterSlice.actions;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> interface RootState &#123;</span><br><span class="line">  userMsg: any;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">export</span> default counterSlice.reducer;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据切片集中输出</span></span><br><span class="line">import counterSlice from <span class="string">&quot;./test&quot;</span>;</span><br><span class="line">import starSlice from <span class="string">&quot;./setStar&quot;</span>;</span><br><span class="line">import userSlice from <span class="string">&quot;./user&quot;</span>;</span><br><span class="line">import userMsgSlice from <span class="string">&quot;./userMsg&quot;</span>;</span><br><span class="line">import &#123; configureStore &#125; from <span class="string">&quot;@reduxjs/toolkit&quot;</span>;</span><br><span class="line">import thunksSlice from <span class="string">&quot;./thunks&quot;</span>;</span><br><span class="line">const store = configureStore(&#123;</span><br><span class="line">  reducer: &#123;</span><br><span class="line">    counter: counterSlice,</span><br><span class="line">    thunks: thunksSlice,</span><br><span class="line">    star: starSlice,</span><br><span class="line">    user: userSlice,</span><br><span class="line">    userMsg: userMsgSlice,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default store;</span><br></pre></td></tr></table></figure><p>掌握以上这些就可以正常开放React 页面了</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git 版本回退</title>
      <link href="/2023/06/05/git-%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/"/>
      <url>/2023/06/05/git-%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/</url>
      
        <content type="html"><![CDATA[<h1 id="git-版本回退"><a href="#git-版本回退" class="headerlink" title="git 版本回退"></a>git 版本回退</h1><p>git reset –hard 8a85bfd95f0e63543c699470595da119fa4480f7<br>&#x2F;&#x2F; 强推<br>git push -f </p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>threejs 基础</title>
      <link href="/2023/06/02/threejs-%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/06/02/threejs-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="创建一个场景-依赖3个对象"><a href="#创建一个场景-依赖3个对象" class="headerlink" title="创建一个场景 依赖3个对象"></a>创建一个场景 依赖3个对象</h1><ul><li>场景 </li><li>相机</li><li>渲染器</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 场景</span></span><br><span class="line">const scene = new THREE.Scene();</span><br><span class="line"><span class="comment"># 相机 PerspectiveCamera（透视摄像机）</span></span><br><span class="line"><span class="comment"># new THREE.PerspectiveCamera(视野角度（FOV）,长宽比（aspect ratio）,近截面（near）,远截面（far） ）</span></span><br><span class="line">const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );</span><br><span class="line"><span class="comment"># 渲染器</span></span><br><span class="line">const renderer = new THREE.WebGLRenderer();</span><br><span class="line"></span><br><span class="line">renderer.setSize( window.innerWidth, window.innerHeight );</span><br><span class="line">document.body.appendChild( renderer.domElement );</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="添加一个立方体"><a href="#添加一个立方体" class="headerlink" title="添加一个立方体"></a>添加一个立方体</h1>]]></content>
      
      
      
        <tags>
            
            <tag> Threejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue2 与 Vue3 监听方式的优化</title>
      <link href="/2023/04/19/Vue2-%E4%B8%8E-Vue3-%E7%9B%91%E5%90%AC%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BC%98%E5%8C%96/"/>
      <url>/2023/04/19/Vue2-%E4%B8%8E-Vue3-%E7%9B%91%E5%90%AC%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="DefineProperty"><a href="#DefineProperty" class="headerlink" title="DefineProperty"></a>DefineProperty</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123;</span><br><span class="line">  key: &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 2,</span><br><span class="line">    c: &#123;</span><br><span class="line">      c1: 5</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> isObject(a) &#123;</span><br><span class="line">  <span class="built_in">return</span> typeof a === <span class="string">&#x27;object&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> reduce(obj) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (var i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">let</span> val = obj[i]</span><br><span class="line">    <span class="keyword">if</span> (isObject(val)) &#123;</span><br><span class="line">      reduce(val)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object.defineProperty(obj, i, &#123;</span><br><span class="line">      <span class="function"><span class="title">get</span></span>() &#123;</span><br><span class="line">        console.log(<span class="string">&#x27;属性&#x27;</span> + i + <span class="string">&#x27;被get了一下&#x27;</span>)</span><br><span class="line">        <span class="built_in">return</span> val</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="built_in">set</span>(value) &#123;</span><br><span class="line">        console.log(<span class="string">&#x27;属性&#x27;</span> + i + <span class="string">&#x27;被set成了&#x27;</span> + value)</span><br><span class="line">        val = value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reduce(data)</span><br><span class="line">console.log(data.key.a)</span><br></pre></td></tr></table></figure><h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123;</span><br><span class="line">  key: &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 2,</span><br><span class="line">    c: &#123;</span><br><span class="line">      c1: 5</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const handler = &#123;</span><br><span class="line">  get: <span class="keyword">function</span> (obj, prop) &#123;</span><br><span class="line">    console.log(<span class="string">&#x27;属性&#x27;</span> + prop + <span class="string">&#x27;被get了一下&#x27;</span>)</span><br><span class="line">    <span class="built_in">return</span> prop <span class="keyword">in</span> obj ? obj[prop] : null;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">set</span>: <span class="keyword">function</span> (obj, prop, value) &#123;</span><br><span class="line">    console.log(<span class="string">&#x27;属性&#x27;</span> + prop + <span class="string">&#x27;被set成了&#x27;</span> + value)</span><br><span class="line">    obj[prop] = value</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">data = new Proxy(data, handler)</span><br><span class="line"></span><br><span class="line">console.log(data.key.a)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Vue DefineProperty Proxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react.lazy 失败的重载机制</title>
      <link href="/2023/04/18/react-lazy-%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%87%8D%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
      <url>/2023/04/18/react-lazy-%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%87%8D%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="React-lazy"><a href="#React-lazy" class="headerlink" title="React.lazy"></a>React.lazy</h1><p>前言：<br>在使用 vite + react 构建项目发布生产后，一切都正常使用没有问题。<br>当开始迭代了第一个版本发布后，部分用户出现 <code>Failed to fetch dynamicallyimported module</code> 的错误。大致意思就是找不到动态导入的模块。<br>当用户手动刷新后，又正常显示。</p><p>初步原因判断：初版使用的用户访问网站域名后，微信将资源文件缓存下来，后续访问会读取本地资源。当访问到没有缓存的资源时，就会报该错误。因为本地没有该资源，服务器也没有。版本已经迭代了。</p><p>解决方案</p><ul><li><p>配置 nginx 永不缓存<br>该方法直接在服务器修改nginx配置即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">        include vhost/security/ua_deny.conf;</span><br><span class="line">        include vhost/security/country_deny.conf;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$request_filename</span> ~* .*\.(?:htm|html)$)</span><br><span class="line">        &#123;</span><br><span class="line">                add_header Cache-Control <span class="string">&quot;private, no-store, no-cache, must-revalidate, proxy-revalidate&quot;</span>;</span><br><span class="line">                // 或者</span><br><span class="line">                expires -1;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样每次访问域名都会从服务器拉取最新的index.html</p><p>经过多次Jenkins构建尝试后，发现有以下缺陷：</p><ol><li>第一次，必须要手动清除微信缓存。否则无法读取到新的资源。</li><li>当用户停留在网站，刚好发生更新时，依旧无法获取到新的资源</li><li>资源正确的情况，弱网环境也有可能发生动态加载失败</li></ol><p>情况1必然无法避免，情况2和3可以在发生更新时，手动触发一下更新。<br>于是有了方案二</p></li><li><p>在React.lazy 的时候，加入异常处理的流程，当正确加载时，正常显示。失败则记录并无感刷新<br>首先去研究 React.lazy 该方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># callback: useLazy(() =&gt; import(&quot;@/pages/home/index&quot;)),</span></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> useLazy(callback) &#123;</span><br><span class="line">  const LazyRC = React.lazy(callback);</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    &lt;React.Suspense fallback=&#123;&lt;Skeleton animated /&gt;&#125;&gt;</span><br><span class="line">      &lt;LazyRC /&gt;</span><br><span class="line">    &lt;/React.Suspense&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># import() 返回的是一个promise ，那么可以再包多一层</span></span><br><span class="line">const lazyRetry = <span class="keyword">function</span> (componentImport) &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    componentImport()</span><br><span class="line">      .<span class="keyword">then</span>(resolve)</span><br><span class="line">      .catch((error) =&gt; &#123;</span><br><span class="line">        // 检查是否已经刷新过了</span><br><span class="line">        const hasRefreshed = JSON.parse(</span><br><span class="line">          window.sessionStorage.getItem(`retry-lazy-refreshed`) ||</span><br><span class="line">            <span class="string">&quot;false&quot;</span></span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (!hasRefreshed) &#123;</span><br><span class="line">          // 没有刷新过，需要刷新页面刷新</span><br><span class="line">          window.sessionStorage.setItem(`retry-lazy-refreshed`, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">          <span class="built_in">return</span> window.location.reload(); </span><br><span class="line">        &#125;</span><br><span class="line">        reject(error);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> useLazy(callback) &#123;</span><br><span class="line">  <span class="comment"># const LazyRC = React.lazy(callback);</span></span><br><span class="line"></span><br><span class="line">  const LazyRC = React.lazy(() =&gt; lazyRetry(callback));</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    &lt;React.Suspense fallback=&#123;&lt;Skeleton animated /&gt;&#125;&gt;</span><br><span class="line">      &lt;LazyRC /&gt;</span><br><span class="line">    &lt;/React.Suspense&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> React Lazy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝湖直转Html=》React &amp;&amp; Vue</title>
      <link href="/2023/04/10/%E8%93%9D%E6%B9%96%E7%9B%B4%E8%BD%ACHtml-%E3%80%8BReact-Vue/"/>
      <url>/2023/04/10/%E8%93%9D%E6%B9%96%E7%9B%B4%E8%BD%ACHtml-%E3%80%8BReact-Vue/</url>
      
        <content type="html"><![CDATA[<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>简化，页面绘制流程。高效率生产。摸鱼神器</p><h1 id="蓝湖"><a href="#蓝湖" class="headerlink" title="蓝湖"></a>蓝湖</h1><p>具体到某一张设计稿，点击旁边的代码</p><p>可以看到里面含有 Vue Uni React 版本的代码。这里主要讲解React代码怎么用<br>因为Vue 与 Uni 在单页面开发中存在 <code>&lt;style scoped&gt;</code> 属性<br>可以直接复制代码使用。但是React中的Css没办法通过设置隔离。页面与页面之间的CSS重叠问题。<br>这里主要解决这个问题</p><h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=<span class="string">&quot;block_3 flex-col&quot;</span>&gt;</span><br><span class="line">  &lt;span className=<span class="string">&quot;text_10&quot;</span>&gt;注册/登录&lt;/span&gt;</span><br><span class="line">  &lt;div className=<span class="string">&quot;group_17 flex-col&quot;</span> /&gt;</span><br><span class="line">  &lt;span className=<span class="string">&quot;text_11&quot;</span>&gt;手机号&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这是一段React页面UI转化的代码，<br>蓝湖生成的规则都是一个样，换一个页面它还是会定义<code>group_xx，text_xx</code><br>这就导致页面css重用，页面UI样式错乱问题。</p><p>我们需要一个程序将html中的className重新定义，以符合我们的实际需求<br>像这样</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=&#123;styles.block_3 + <span class="string">&quot; &quot;</span> + styles[<span class="string">&#x27;flex-col&#x27;</span>]&#125;&gt;</span><br><span class="line">  &lt;span className=&#123;styles.text_10&#125;&gt;注册/登录&lt;/span&gt;</span><br><span class="line">  &lt;div className=&#123;styles.group_17 + <span class="string">&quot; &quot;</span> + styles[<span class="string">&#x27;flex-col&#x27;</span>]&#125; /&gt;</span><br><span class="line">  &lt;span className=&#123;styles.text_11&#125;&gt;手机号&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="comment"># 再把styles变量 引入进来 </span></span><br><span class="line">import styles from <span class="string">&#x27;./index.module.scss&#x27;</span>;</span><br><span class="line"><span class="comment"># 把蓝湖的CSS复制到这个index文件里面</span></span><br></pre></td></tr></table></figure><h1 id="生成工具代码"><a href="#生成工具代码" class="headerlink" title="生成工具代码"></a>生成工具代码</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">const &#123; src, dest &#125; = require(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line">var through = require(<span class="string">&#x27;through2&#x27;</span>);</span><br><span class="line"><span class="keyword">function</span> defaultTask(cb) &#123;</span><br><span class="line">  // place code <span class="keyword">for</span> your default task here</span><br><span class="line">  // cb();</span><br><span class="line">  <span class="built_in">return</span> src(<span class="string">&#x27;src/index.jsx&#x27;</span>).pipe(through.obj(<span class="keyword">function</span> (file, encode, cb) &#123;</span><br><span class="line">    <span class="built_in">let</span> str = file.contents.toString()</span><br><span class="line">    str = str.replace(/className=<span class="string">&quot;([^&quot;</span>]+)<span class="string">&quot;/g, function (match, className) &#123;</span></span><br><span class="line"><span class="string">      const classNames = className.split(&#x27; &#x27;)</span></span><br><span class="line"><span class="string">      const strTemp = classNames.map(function (name) &#123;</span></span><br><span class="line"><span class="string">        if (name.indexOf(&#x27;-&#x27;) &gt; -1) &#123;</span></span><br><span class="line"><span class="string">          return &#x27;styles[\&#x27;&#x27; + name + &#x27;\&#x27;]&#x27;</span></span><br><span class="line"><span class="string">        &#125; else &#123;</span></span><br><span class="line"><span class="string">          return &#x27;styles.&#x27; + name;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;)</span></span><br><span class="line"><span class="string">        .join(&#x27; + &quot;</span> <span class="string">&quot; + &#x27;);</span></span><br><span class="line"><span class="string">      console.log(strTemp)</span></span><br><span class="line"><span class="string">      return &#x27;className=&#123;&#x27; + strTemp + &#x27;&#125;&#x27;</span></span><br><span class="line"><span class="string">    &#125;)</span></span><br><span class="line"><span class="string">    file.contents = new Buffer(str)</span></span><br><span class="line"><span class="string">    this.push(file)</span></span><br><span class="line"><span class="string">    cb()</span></span><br><span class="line"><span class="string">  &#125;)).pipe(dest(&#x27;output/&#x27;))</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">exports.default = defaultTask</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>批量处理AI生成的静态文件</title>
      <link href="/2023/04/04/%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86AI%E7%94%9F%E6%88%90%E7%9A%84%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6/"/>
      <url>/2023/04/04/%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86AI%E7%94%9F%E6%88%90%E7%9A%84%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="批量处理AI生成的静态文件"><a href="#批量处理AI生成的静态文件" class="headerlink" title="批量处理AI生成的静态文件"></a>批量处理AI生成的静态文件</h1><p>起因是，我需要将一段不合格的jsx文件 转化成 合格的jsx文件<br>用过React 都知道。在SPA应用下。css的状态是共享的。需要将其私有化。<br>只能通过定义一个 index.module.scss<br>再通过 引人styles的方式去使用，将其私有化<br>整个过程类似vue scoped 的效果。但是比较繁琐。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 转化前</span></span><br><span class="line">&lt;div className=<span class="string">&quot;group_1 flex-row&quot;</span>&gt;</span><br><span class="line">  &lt;div className=<span class="string">&quot;image-text_4 flex-row justify-between&quot;</span>&gt;</span><br><span class="line">    &lt;div className=<span class="string">&quot;box_4 flex-col&quot;</span> /&gt;</span><br><span class="line">    &lt;div className=<span class="string">&quot;text-group_4 flex-col&quot;</span>&gt;</span><br><span class="line">      &lt;span className=<span class="string">&quot;text_4&quot;</span>&gt;【自然探索类】&lt;/span&gt;</span><br><span class="line">      &lt;span className=<span class="string">&quot;text_5&quot;</span>&gt;科技创新类-变废为宝·争当环保先锋研学课程&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#转化后</span></span><br><span class="line">&lt;div className=&#123;styles.group_1 + <span class="string">&quot; &quot;</span> + styles[<span class="string">&#x27;flex-row&#x27;</span>]&#125;&gt;</span><br><span class="line">  &lt;div className=&#123;styles[<span class="string">&#x27;image-text_4&#x27;</span>] + <span class="string">&quot; &quot;</span> + styles[<span class="string">&#x27;flex-row&#x27;</span>] + <span class="string">&quot; &quot;</span> + styles[<span class="string">&#x27;justify-between&#x27;</span>]&#125;&gt;</span><br><span class="line">    &lt;div className=&#123;styles.box_4 + <span class="string">&quot; &quot;</span> + styles[<span class="string">&#x27;flex-col&#x27;</span>]&#125; /&gt;</span><br><span class="line">    &lt;div className=&#123;styles[<span class="string">&#x27;text-group_4&#x27;</span>] + <span class="string">&quot; &quot;</span> + styles[<span class="string">&#x27;flex-col&#x27;</span>]&#125;&gt;</span><br><span class="line">      &lt;span className=&#123;styles.text_4&#125;&gt;【自然探索类】&lt;/span&gt;</span><br><span class="line">      &lt;span className=&#123;styles.text_5&#125;&gt;科技创新类-变废为宝·争当环保先锋研学课程&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul><li>首先批量处理，需要使用工具Gulp，定义一个gulpfile 文件</li><li>写一个任务，将文件内容提取出来</li><li>再将内容执行批量替换操作</li><li>操作完，将内容输出到新的文件，保存下来</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">const &#123; src, dest &#125; = require(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line">var through = require(<span class="string">&#x27;through2&#x27;</span>);</span><br><span class="line"><span class="keyword">function</span> defaultTask(cb) &#123;</span><br><span class="line">  // place code <span class="keyword">for</span> your default task here</span><br><span class="line">  // cb();</span><br><span class="line">  <span class="built_in">return</span> src(<span class="string">&#x27;src/index.jsx&#x27;</span>).pipe(through.obj(<span class="keyword">function</span> (file, encode, cb) &#123;</span><br><span class="line">    <span class="built_in">let</span> str = file.contents.toString()</span><br><span class="line">    str = str.replace(/className=<span class="string">&quot;([^&quot;</span>]+)<span class="string">&quot;/g, function (match, className) &#123;</span></span><br><span class="line"><span class="string">      const classNames = className.split(&#x27; &#x27;)</span></span><br><span class="line"><span class="string">      const strTemp = classNames.map(function (name) &#123;</span></span><br><span class="line"><span class="string">        if (name.indexOf(&#x27;-&#x27;) &gt; -1) &#123;</span></span><br><span class="line"><span class="string">          return &#x27;styles[\&#x27;&#x27; + name + &#x27;\&#x27;]&#x27;</span></span><br><span class="line"><span class="string">        &#125; else &#123;</span></span><br><span class="line"><span class="string">          return &#x27;styles.&#x27; + name;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;)</span></span><br><span class="line"><span class="string">        .join(&#x27; + &quot;</span> <span class="string">&quot; + &#x27;);</span></span><br><span class="line"><span class="string">      console.log(strTemp)</span></span><br><span class="line"><span class="string">      return &#x27;className=&#123;&#x27; + strTemp + &#x27;&#125;&#x27;</span></span><br><span class="line"><span class="string">    &#125;)</span></span><br><span class="line"><span class="string">    file.contents = new Buffer(str)</span></span><br><span class="line"><span class="string">    this.push(file)</span></span><br><span class="line"><span class="string">    cb()</span></span><br><span class="line"><span class="string">  &#125;)).pipe(dest(&#x27;output/&#x27;))</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">exports.default = defaultTask</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> React Gulp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react 全局页面权限控制</title>
      <link href="/2023/04/03/react-%E5%85%A8%E5%B1%80%E9%A1%B5%E9%9D%A2%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
      <url>/2023/04/03/react-%E5%85%A8%E5%B1%80%E9%A1%B5%E9%9D%A2%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="基于最新版本的-react-router-dom-V6-版"><a href="#基于最新版本的-react-router-dom-V6-版" class="headerlink" title="基于最新版本的 react-router-dom V6 版"></a>基于最新版本的 react-router-dom V6 版</h1><p>主要依赖方法：</p><ul><li>useMatches</li><li>useOutlet</li><li>Navigate</li><li>Outlet</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### useMatches 判断路由地址白名单是否完全匹配</span></span><br><span class="line"><span class="comment">### Outlet 匹配规则路由，放行操作</span></span><br><span class="line"><span class="comment">### Navigate 不匹配则打到登录页或者无权限访问页</span></span><br><span class="line"></span><br><span class="line">const whiteList = [</span><br><span class="line">  <span class="string">&quot;/&quot;</span>,</span><br><span class="line">  <span class="string">&quot;/index&quot;</span>,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">AuthRoute</span></span>() &#123;</span><br><span class="line">  const matches = useMatches();</span><br><span class="line">  console.log(matches);</span><br><span class="line">  const outlet = useOutlet();</span><br><span class="line">  const isLogined = <span class="literal">false</span>;</span><br><span class="line">  // 从user-redux读取用户信息，判断是否登录</span><br><span class="line">  const user = useSelector((state: RootState) =&gt; state.user.userMsg);</span><br><span class="line">  // 根据白名单的登录状态进行鉴权</span><br><span class="line">  const page = useMemo(() =&gt; &#123;</span><br><span class="line">    const &#123; pathname &#125; = matches[1];</span><br><span class="line">    const isInWL = whiteList.includes(pathname);</span><br><span class="line"></span><br><span class="line">    const isLogined = user.mobile ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isInWL) <span class="built_in">return</span> &lt;Outlet /&gt;;</span><br><span class="line">    <span class="keyword">if</span> (isLogined) <span class="built_in">return</span> &lt;Outlet /&gt;;</span><br><span class="line">    <span class="built_in">return</span> &lt;Navigate to=<span class="string">&quot;/index-no-user?type=1&quot;</span> replace /&gt;;</span><br><span class="line">  &#125;, [isLogined, matches, outlet]);</span><br><span class="line">  // 路由后置钩子更改网页标题</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    const title = (matches[1].handle as any)?.title;</span><br><span class="line">    const isHasTitle = typeof title === <span class="string">&quot;string&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (isHasTitle) &#123;</span><br><span class="line">      document.title = title;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [matches]);</span><br><span class="line">  <span class="built_in">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 路由表定义</span></span><br><span class="line">// 将需要鉴权的页面放进 被 AuthRoute 组件包裹的 children 里面。</span><br><span class="line">// 例如当访问 /index 路径时，会先执行 AuthRoute，</span><br><span class="line">// 根据对应的条件在决定 &lt;Outlet /&gt; 还是 &lt;Navigate to=<span class="string">&quot;/index-no-user&quot;</span> replace /&gt;;</span><br><span class="line">const routes: RouteObject[] = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">    element: &lt;AuthRoute /&gt;,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        element: &lt;Navigate to=<span class="string">&quot;/index&quot;</span> replace /&gt;,</span><br><span class="line">        handle: &#123; title: <span class="string">&quot;index&quot;</span> &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">&quot;index&quot;</span>,</span><br><span class="line">        element: useLazy(() =&gt; import(<span class="string">&quot;@/pages/home/index&quot;</span>)),</span><br><span class="line">        handle: &#123; title: <span class="string">&quot;index&quot;</span> &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&quot;*&quot;</span>,</span><br><span class="line">    element: &lt;div&gt;无权限访问 &lt;/div&gt;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&quot;/index-no-user&quot;</span>,</span><br><span class="line">    element: useLazy(() =&gt; import(<span class="string">&quot;@/pages/404&quot;</span>)),</span><br><span class="line">    handle: &#123; title: <span class="string">&quot;无法访问&quot;</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">];</span><br></pre></td></tr></table></figure><h1 id="拓展性配置-createHashRouter"><a href="#拓展性配置-createHashRouter" class="headerlink" title="拓展性配置 createHashRouter"></a>拓展性配置 createHashRouter</h1><p>要想使用最新版本的功能，需要通过最新的语法去创建路由<br>createBrowserRouter </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const hashRouter = createHashRouter(routes);</span><br><span class="line"><span class="built_in">export</span> default <span class="keyword">function</span> <span class="function"><span class="title">App</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    <span class="comment"># store 是 redux 暴露出来的。目的是将redux挂载进来</span></span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">      &lt;RouterProvider router=&#123;hashRouter&#125; /&gt;</span><br><span class="line">    &lt;/Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> React Premiss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react17.x 主流程解析</title>
      <link href="/2023/03/29/react17-x-%E4%B8%BB%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/"/>
      <url>/2023/03/29/react17-x-%E4%B8%BB%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="关于-React-三大架构"><a href="#关于-React-三大架构" class="headerlink" title="关于 React 三大架构"></a>关于 React 三大架构</h1><ul><li>reconciler 协调器 ，集成filber</li><li>Scheduler 任务调度器</li><li>react-dom 渲染器</li></ul><h1 id="reconciler"><a href="#reconciler" class="headerlink" title="reconciler"></a>reconciler</h1><p>reconciler 主要是负责 scheduler 与 react-dom 的任务之间的互相协调与分配。</p><p>内置一个任务循环，将同步的任务放入循环，按顺序执行。异步的任务，直接执行。</p><p>通过fiber 构建fiber树。输出给react-dom去生成dom树给浏览器渲染。</p><p>内置一个 scheduleUpdateOnFiber （更新fiber树）的方法，该方法主要将 更新fiber树 的操作封装成 scheduler 接收的 task 任务包。然后放进任务调度循环里面，根据优先级 ，等待 reconciler 提取task来执行 task的回调 来构建fiber树。</p><h1 id="scheduler"><a href="#scheduler" class="headerlink" title="scheduler"></a>scheduler</h1><p>scheduler 存放任务包 用的是 二叉堆 中的最小堆数据模型。优先级最高的就会出现在最顶点，等待被取用。</p><p>优先级使用的是 lanes 模型。二进制变量。 利用了位掩码的特性, 在频繁运算的时候占用内存少, 计算速度快.</p><p>主要提供了4个调度的核心的函数</p><ul><li>requestHostCallback</li><li>cancelHostCallback</li><li>requestHostTimeout</li><li>cancelHostTimeout</li></ul><p>通过 消息通道 MessageChannel 来通知执行callback</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 接收 MessageChannel 消息</span><br><span class="line">const performWorkUntilDeadline = () =&gt; &#123;</span><br><span class="line">  // ...省略无关代码</span><br><span class="line">  <span class="keyword">if</span> (scheduledHostCallback !== null) &#123;</span><br><span class="line">    // 执行callback</span><br><span class="line">    scheduledHostCallback(hasTimeRemaining, currentTime);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    isMessageLoopRunning = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const channel = new MessageChannel()</span><br><span class="line">const port = channel.port2</span><br><span class="line">channel.port1.onmessage = performWorkUntilDeadline;</span><br><span class="line"></span><br><span class="line">// 请求回调</span><br><span class="line">requestHostCallback = <span class="keyword">function</span>(callback) &#123;</span><br><span class="line">  // 1. 保存callback</span><br><span class="line">  scheduledHostCallback = callback;</span><br><span class="line">  // 判断事件循环是否处于工作中，不是就开启</span><br><span class="line">  <span class="keyword">if</span> (!isMessageLoopRunning) &#123;</span><br><span class="line">    isMessageLoopRunning = <span class="literal">true</span>;</span><br><span class="line">    // 2. 通过 MessageChannel 发送消息</span><br><span class="line">    port.postMessage(null);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 取消回调 就是移除回调</span><br><span class="line">cancelHostCallback = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  scheduledHostCallback = null;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间切片(time slicing)相关: 执行时间分割, 让出主线程(把控制权归还浏览器, 浏览器可以处理用户输入, UI 绘制等紧急任务).</p><ul><li>getCurrentTime: 获取当前时间</li><li>shouldYieldToHost: 是否让出主线程</li><li>requestPaint: 请求绘制</li><li>forceFrameRate: 强制设置 yieldInterval(从源码中的引用来看, 算一个保留函数, 其他地方没有用到)</li></ul><h1 id="Fiber"><a href="#Fiber" class="headerlink" title="Fiber"></a>Fiber</h1><p>fiber树构造 </p><ul><li>从scheduler调度中心的角度来看, 它是任务队列taskQueue中的一个具体的任务回调(task.callback).</li><li>从React 工作循环的角度来看, 它属于fiber树构造循环.</li></ul><p>通过 函数编程 return 出来的是一段类似html的jsx语法片段，经过编译器转换, 最终会以React.createElement(…)的方式，创建出来一个与之对应的ReactElement对象。</p><p>经过scheduler包，封装成task，放入二叉堆，按照任务优先级，等待任务回调</p><p>执行任务回调， 通过 ReactElement对象 里面的属性 进行创建多个fiber对象， 这些fiber构成了一棵fiber树, fiber树是构造DOM树的数据模型。</p><p>开发人员通过编程只能控制ReactElement树的结构, ReactElement树驱动fiber树, fiber树再驱动DOM树, 最后展现到页面上. 所以fiber树的构造过程, 实际上就是ReactElement对象到fiber对象的转换过程.</p><p>双缓冲技术(double buffering)<br>fiber树的构造过程, 就是把ReactElement转换成fiber树的过程.<br>在这个过程中, 内存里会同时存在 2 棵fiber树: fiberRoot &amp;&amp; HostRootFiber</p><ul><li>代表当前界面的fiber树(已经被展示出来, 挂载到fiberRoot.current上). 如果是初次构造(初始化渲染), 页面还没有渲染, 此时界面对应的 fiber 树为空(fiberRoot.current &#x3D; null).</li><li>正在构造的fiber树(即将展示出来, 挂载到HostRootFiber.alternate上, 正在构造的节点称为workInProgress). 当构造完成之后, 重新渲染页面, 最后切换fiberRoot.current &#x3D; workInProgress, 使得fiberRoot.current重新指向代表当前界面的fiber树.</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2022/10/27/test/"/>
      <url>/2022/10/27/test/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git 多分支合并减少冲突</title>
      <link href="/2022/09/07/git-%E5%A4%9A%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6%E5%87%8F%E5%B0%91%E5%86%B2%E7%AA%81/"/>
      <url>/2022/09/07/git-%E5%A4%9A%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6%E5%87%8F%E5%B0%91%E5%86%B2%E7%AA%81/</url>
      
        <content type="html"><![CDATA[<h1 id="git-在开发生产环境产生的问题"><a href="#git-在开发生产环境产生的问题" class="headerlink" title="git 在开发生产环境产生的问题"></a>git 在开发生产环境产生的问题</h1><p>一般情况所存在的主要分支</p><ul><li>master 生产</li><li>hotfix 用于修复生产bug的专属分支</li><li>main 开发分支</li></ul><p>问题<br>在多人协作开发的时候，大家都往main提交代码，甚至有时候直接在main上改，导致main的版本已经超前了master很多很多，在下一次合并master的时侯会产生很多冲突。</p><h1 id="提交与合并原则"><a href="#提交与合并原则" class="headerlink" title="提交与合并原则"></a>提交与合并原则</h1><ul><li>在hotfix 修复完 bug 合并到 master 上时，用 main 去合并一下 master，让生产修复的bug在测试环境也生效</li><li>准备发生产时，先用 main 去合并 master，再用master去合并main。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos 部署 Uni H5打包</title>
      <link href="/2022/08/12/centos-%E9%83%A8%E7%BD%B2-Uni-H5%E6%89%93%E5%8C%85/"/>
      <url>/2022/08/12/centos-%E9%83%A8%E7%BD%B2-Uni-H5%E6%89%93%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h1><ol><li>从window hbuildx 软件中提取构建包 <code>uniapp-cli</code>.zip ,放到服务器里面 rz 命令上传,通过<code>cp 复制文件路径/名称 文件路径/名称</code>  复制到指定的目录上面。</li><li>安装node 环境<br>  下载 node-v16.16.0-linux-x64.tar.xz<br>  rz 传到服务器<br>  tar -xvf node-v16.16.0-linux-x64.tar.xz 解压<br>  配置环境变量<br>  vi  &#x2F;etc&#x2F;profile<br>  export NODEJS&#x3D;&#x2F;zyc&#x2F;node-v16.16.0<br>  export PATH&#x3D;$PATH:$NODEJS&#x2F;bin</li></ol><p>  触发生效<br>  source &#x2F;etc&#x2F;profile<br>  设置淘宝镜像源<br>   npm config set registry <a href="http://registry.npm.taobao.org/">http://registry.npm.taobao.org/</a></p><h1 id="检查是否更换成功"><a href="#检查是否更换成功" class="headerlink" title="检查是否更换成功"></a>检查是否更换成功</h1><p>   npm config get registry<br>3. 安装 uniapp-cli 依赖包，以及编译器包<br>   cd uniapp-cli 到该目录，npm install<br>  npm install bcrypt less node-sass-china –save<br>  因为node-sass-china镜像源无法下载需要到github官网去下载<br>  <a href="https://github.com/sass/node-sass/releases/tag/v6.0.1">https://github.com/sass/node-sass/releases/tag/v6.0.1</a></p><p>4. </p>]]></content>
      
      
      
        <tags>
            
            <tag> Uni </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React render props</title>
      <link href="/2022/07/27/React-render-props/"/>
      <url>/2022/07/27/React-render-props/</url>
      
        <content type="html"><![CDATA[<h1 id="Render-Props"><a href="#Render-Props" class="headerlink" title="Render Props"></a>Render Props</h1><p>术语 “render prop” 是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术<br>该函数的返回值 可以是一个 ReactElement</p><h1 id="Render-Props-解决的问题"><a href="#Render-Props-解决的问题" class="headerlink" title="Render Props 解决的问题"></a>Render Props 解决的问题</h1><ul><li>组件复用性的问题<br>以往我们需要通过高阶组件去复用其内部的逻辑与方法，但是不想复用其中的视图，或者只是想复用部分的数据</li><li>让组件可以动态的处理一些问题，而不是全量复制。特殊化处理。</li><li>类似于vue中的slot</li></ul><h1 id="Render-Props-注意事项"><a href="#Render-Props-注意事项" class="headerlink" title="Render Props 注意事项"></a>Render Props 注意事项</h1><ul><li>在使用ts进行类型定义时，必须声明该类型是一个函数</li><li>它的命名不一定是render ，也可以是children或者其他<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mouse.propTypes = &#123;</span><br><span class="line">  children: PropTypes.func.isRequired</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> render props </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器一帧做了什么（RequestAnimationFrame）</title>
      <link href="/2022/07/26/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%80%E5%B8%A7%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/"/>
      <url>/2022/07/26/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%80%E5%B8%A7%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h1><p>我们都知道，页面的内容都是一帧一帧绘制出来的，浏览器刷新率代表浏览器一秒绘制多少帧。原则上说 1s 内绘制的帧数也多，画面表现就也细腻。目前浏览器大多是 60Hz（60帧&#x2F;s），每一帧耗时也就是在 16.6ms 左右。</p><h1 id="在一帧内的执行过程"><a href="#在一帧内的执行过程" class="headerlink" title="在一帧内的执行过程"></a>在一帧内的执行过程</h1><ul><li>接受输入事件 like：touch wheel click keypress</li><li>执行事件回调  Timers</li><li>开始一帧 <ol><li>window resize 窗口大小调整</li><li>scroll 滚动</li><li>mediaquery changed 媒体查询变化</li><li>animation events 动画事件<br>上述这些情况都可以触发开始一帧</li></ol></li><li>执行 RAF (RequestAnimationFrame)</li><li>页面布局，样式计算</li><li>绘制渲染</li><li>执行 RIC (RequestIdelCallback)</li></ul><h1 id="RequestAnimationFrame-动画绘制-与-通过定时器触发的区别"><a href="#RequestAnimationFrame-动画绘制-与-通过定时器触发的区别" class="headerlink" title="RequestAnimationFrame 动画绘制 与 通过定时器触发的区别"></a>RequestAnimationFrame 动画绘制 与 通过定时器触发的区别</h1><p>计时器一直是javascript动画的核心技术，而setTimeout和setInterval的问题是，它们都不精确。<br>它们的内在运行机制决定了时间间隔参数实际上只是指定了把动画代码添加到浏览器UI线程队列中以等待执行的时间。<br>如果队列前面已经加入了其他任务，那动画代码就要等前面的任务完成后再执行。</p><p>requestAnimationFrame采用系统时间间隔，保持最佳绘制效率。<br>不会因为间隔时间过短，造成过度绘制，增加开销；也不会因为间隔时间太长，使用动画卡顿不流畅，让各种网页动画效果能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果。</p><h1 id="RequestAnimationFrame的特点"><a href="#RequestAnimationFrame的特点" class="headerlink" title="RequestAnimationFrame的特点"></a>RequestAnimationFrame的特点</h1><ul><li>requestAnimationFrame会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率</li><li>在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的CPU、GPU和内存使用量</li><li>requestAnimationFrame是由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了CPU开销</li></ul><h1 id="RequestAnimationFrame-的使用"><a href="#RequestAnimationFrame-的使用" class="headerlink" title="RequestAnimationFrame 的使用"></a>RequestAnimationFrame 的使用</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div <span class="built_in">id</span>=<span class="string">&quot;myDiv&quot;</span> style=<span class="string">&quot;background-color: lightblue;width: 0;height: 20px;line-height: 20px;&quot;</span>&gt;0%&lt;/div&gt;</span><br><span class="line">&lt;button <span class="built_in">id</span>=<span class="string">&quot;btn&quot;</span>&gt;run&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  var timer;</span><br><span class="line">  const btn = document.getElementById(<span class="string">&#x27;btn&#x27;</span>)</span><br><span class="line">  btn.onclick = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    myDiv.style.width = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    cancelAnimationFrame(timer);</span><br><span class="line">    timer = requestAnimationFrame(<span class="keyword">function</span> <span class="function"><span class="title">fn</span></span>() &#123;</span><br><span class="line">      <span class="keyword">if</span> (parseInt(myDiv.style.width) &lt; 500) &#123;</span><br><span class="line">        myDiv.style.width = parseInt(myDiv.style.width) + 5 + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">        myDiv.innerHTML = parseInt(myDiv.style.width) / 5 + <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">        timer = requestAnimationFrame(fn);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cancelAnimationFrame(timer);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>React16 设计与架构</title>
      <link href="/2022/07/26/React16-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%9E%B6%E6%9E%84/"/>
      <url>/2022/07/26/React16-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="React-设计理念"><a href="#React-设计理念" class="headerlink" title="React 设计理念"></a>React 设计理念</h1><p>由于JS是单线程的，脚本执行与页面渲染无法同时进行。当项目庞大，组件繁多时，JS执行就会超过16.6ms（浏览器单帧时长），用户就会感受到卡顿。<br>为了解决JS执行事件过长的问题，React 采取了时间切片的方式。将长任务拆分成多个片段到每一帧中执行。</p><h1 id="React16架构可以分为三层："><a href="#React16架构可以分为三层：" class="headerlink" title="React16架构可以分为三层："></a>React16架构可以分为三层：</h1><ul><li><p>Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入Reconciler<br>1.时间分片<br>每隔一段时间就把主线程还给浏览器，避免长时间占用主线程。当浏览器更新页面之后，继续执行未完成任务<br>浏览器每一帧JS执行流程：<br>task(宏任务) – 队列中全部job(微任务) – requestAnimationFrame – 浏览器重排&#x2F;重绘 – requestIdleCallback<br>requestIdleCallback 在ie和safair浏览器上会有兼容性问题。<br>React团队采用了宏任务中的 MessageChannel 来实现任务中断。<br>MessageChannel 可以在页面与内嵌iframe直接通信</p></li><li><p>Reconciler（协调器）—— 负责找出变化的组件 (render阶段)</p></li><li><p>Renderer（渲染器）—— 负责将变化的组件渲染到页面上 (commit阶段)</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github持续集成自动化发布npm包</title>
      <link href="/2022/06/27/Github%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8F%91%E5%B8%83npm%E5%8C%85/"/>
      <url>/2022/06/27/Github%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8F%91%E5%B8%83npm%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>我们发布插件不可能每次都 npm run build 然后 npm login npm publish，这属实有点麻烦，能不能简单一点，我提交个代码或者合并代码的时候就发布呢？<br>那就是持续集成，自动化发布了。</p><h1 id="什么是持续集成"><a href="#什么是持续集成" class="headerlink" title="什么是持续集成"></a>什么是持续集成</h1><p>持续集成指的是，频繁地（一天多次）将代码集成到主干。</p><p>它的好处主要有两个。</p><ul><li>快速发现错误。每完成一点更新，就集成到主干，可以快速发现错误，定位错误也比较容易。</li><li>防止分支大幅偏离主干。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。<br>持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。</li></ul><h1 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h1><ul><li><p>代码托管GitHub</p></li><li><p>找到Actions创建workflow模板<br>找到Publish Node.js Package 去 初始化config，并保存。<br>项目中即可生成下列文件<br>.github&#x2F;workflows&#x2F;npmpublish.yml</p></li><li><p>同步远程分支，并修改npmpublish.yml</p></li><li><p>npmpublish.yml 文件解释<br>name 此工作流的名称。<br>on 触发条件，上述文本表示当master分支合并和推送时会触发workflow。<br>jobs 工作集合，例如jobs内部的build、publish-npm表示具体的工作任务的ID，可以自定义。<br>needs 表示当前的job依赖与另外一个job，例如上面的publish-npm依赖于build。<br>runs-on 表示工作所在的虚拟机操作系统，目前可选的系统有ubuntu-latest、ubuntu-18.04、ubuntu-16.04、windows-latest、windows-2019、windows-2016、macOS-latest、macOS-10.14。<br>steps 表示job所执行的 actions 和 commands 集合。</p></li><li><p>添加npm access Tokens<br>登陆npm - accessTokens - Generate New Token 获取到token<br>在github对应项目&#x2F;settings&#x2F;secrets&#x2F;dependabot 上 New secret 保存，<br>名字要和npmpublish.yml设置的保持一致，一般不做修改: npm_token</p></li><li><p>提交之后就会自动构建更新npm</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> NPM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm上架流程</title>
      <link href="/2022/06/27/npm%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/"/>
      <url>/2022/06/27/npm%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="步骤流程"><a href="#步骤流程" class="headerlink" title="步骤流程"></a>步骤流程</h1><ul><li><p>注册npm账户 ，安装node.js</p></li><li><p>在本地创建自己的npm包<br>创建文件夹，名字建议不要与线上包重名<br>初始化npm包 npm init<br>创建一个index.js文件作为包入口文件（和package.json下的main保持一致）<br>编写完善index.js</p></li><li><p>发布npm包<br>npm adduser 添加登录用户，请确保当前链接源是官网，使用nrm工具可以快速查看和切换<br>npm publish 发布上传包</p></li><li><p>更新npm包<br>修改内容，更新版本号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//直接修改package.json中的version</span><br><span class="line"><span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.1.0&quot;</span></span><br></pre></td></tr></table></figure><p>npm publish 再次发布</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> NPM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UNI全局设置主题色调</title>
      <link href="/2022/06/10/uni%E5%85%A8%E5%B1%80%E8%AE%BE%E7%BD%AE%E4%B8%BB%E9%A2%98%E8%89%B2%E8%B0%83/"/>
      <url>/2022/06/10/uni%E5%85%A8%E5%B1%80%E8%AE%BE%E7%BD%AE%E4%B8%BB%E9%A2%98%E8%89%B2%E8%B0%83/</url>
      
        <content type="html"><![CDATA[<h1 id="UNI全局设置主题色调-的思路"><a href="#UNI全局设置主题色调-的思路" class="headerlink" title="UNI全局设置主题色调 的思路"></a>UNI全局设置主题色调 的思路</h1><ul><li>通过全局设置主类，在主类下添加子类来控制样式</li><li>基于scss去控制全局色调</li><li>基于scss mixin去生成多色调</li><li>通过vuex去控制全局色调的类</li><li>通过mixin混到全局暴露出全局的类和色调</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">// themes.scss</span><br><span class="line"><span class="variable">$bg</span>-007aff: <span class="comment">#007aff;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$bg</span>-00C997: <span class="comment">#00C997; </span></span><br><span class="line"></span><br><span class="line">@mixin setTheme(<span class="variable">$color</span>)&#123;</span><br><span class="line">  .Text&#123;</span><br><span class="line">    color: <span class="variable">$color</span>!important;</span><br><span class="line">  &#125;</span><br><span class="line">  .u-button &#123;</span><br><span class="line">background-color: <span class="variable">$color</span>!important;</span><br><span class="line">&#125;</span><br><span class="line">  .uni-button-color &#123;</span><br><span class="line">    color: <span class="variable">$color</span>!important;</span><br><span class="line">  &#125;</span><br><span class="line">  .uni-modal__btn  &#123;</span><br><span class="line">    color: <span class="variable">$color</span>!important;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// uni.scss</span><br><span class="line"> @import <span class="string">&#x27;@/common/styles/themes.scss&#x27;</span>;</span><br><span class="line">.THEME-00C997 &#123;</span><br><span class="line">  @include setTheme(<span class="variable">$bg</span>-00C997)</span><br><span class="line">&#125;</span><br><span class="line">.THEME-007aff &#123;</span><br><span class="line">  @include setTheme(<span class="variable">$bg</span>-007aff)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// store/index.js</span><br><span class="line">import Vue from <span class="string">&#x27;vue&#x27;</span></span><br><span class="line">import Vuex from <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex) // vue的插件机制</span><br><span class="line"></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">    // 为了不和页面或组件的data中的造成混淆，state中的变量前面建议加上$符号</span><br><span class="line">    state: &#123;</span><br><span class="line">      <span class="variable">$themeClass</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        SETTHEMECLASS(state,data)&#123;</span><br><span class="line">            state.<span class="variable">$themeClass</span> = data</span><br><span class="line">            uni.setStorageSync(<span class="string">&#x27;themeClass&#x27;</span>, data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default store</span><br><span class="line"></span><br><span class="line">// 在app.vue中设置</span><br><span class="line">onLaunch: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  // 可以异步获取</span><br><span class="line">this.<span class="variable">$store</span>.commit(<span class="string">&#x27;SETTHEMECLASS&#x27;</span>,<span class="string">&#x27;00C997&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 全局暴露</span><br><span class="line">computed:&#123;</span><br><span class="line">  <span class="function"><span class="title">GETTHEME</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">&#x27;THEME-&#x27;</span> + this.<span class="variable">$store</span>.state.<span class="variable">$themeClass</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">GETCOLOR</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">&#x27;#&#x27;</span> + this.<span class="variable">$store</span>.state.<span class="variable">$themeClass</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h1><p>需要在每个页面的根节点，动态注入该类 :class&#x3D;”GETTHEME”</p><p>可以通过 GETCOLOR 获取到该主题的色值，辅助某些组件提供api修改状态值</p>]]></content>
      
      
      <categories>
          
          <category> UNI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UNI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七牛云获取图片大小限制</title>
      <link href="/2022/06/08/%E4%B8%83%E7%89%9B%E4%BA%91%E8%8E%B7%E5%8F%96%E5%9B%BE%E7%89%87%E5%A4%A7%E5%B0%8F%E9%99%90%E5%88%B6/"/>
      <url>/2022/06/08/%E4%B8%83%E7%89%9B%E4%BA%91%E8%8E%B7%E5%8F%96%E5%9B%BE%E7%89%87%E5%A4%A7%E5%B0%8F%E9%99%90%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="通过链接访问图片"><a href="#通过链接访问图片" class="headerlink" title="通过链接访问图片"></a>通过链接访问图片</h1><p><a href="http://static.kewaimiao.com/0arRAjL94RNEwYIQ.img">http://static.kewaimiao.com/0arRAjL94RNEwYIQ.img</a></p><p>该方式获取到的是图片的原图，没有经过任何处理</p><h1 id="产生的问题"><a href="#产生的问题" class="headerlink" title="产生的问题"></a>产生的问题</h1><ul><li>在大量图片的网页中，多用户访问，会产生很多流量费用。</li><li>客户端在弱网环境下，访问资源加载会非常缓慢</li></ul><h1 id="解决方案-七牛云：云端的数据处理"><a href="#解决方案-七牛云：云端的数据处理" class="headerlink" title="解决方案 七牛云：云端的数据处理"></a>解决方案 七牛云：云端的数据处理</h1><p>通过添加后缀的方式：<br><code>?imageView2/3/w/200/h/100/q/90</code><br>按照 宽200px、高100px、质量为原图的90%进行展示</p><p><a href="http://static.kewaimiao.com/0arRAjL94RNEwYIQ.img?imageView2/3/w/200/h/100/q/90">http://static.kewaimiao.com/0arRAjL94RNEwYIQ.img?imageView2/3/w/200/h/100/q/90</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>全局设置样式完美解决方案</title>
      <link href="/2022/06/07/%E5%85%A8%E5%B1%80%E8%AE%BE%E7%BD%AE%E6%A0%B7%E5%BC%8F%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2022/06/07/%E5%85%A8%E5%B1%80%E8%AE%BE%E7%BD%AE%E6%A0%B7%E5%BC%8F%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="问题起源"><a href="#问题起源" class="headerlink" title="问题起源"></a>问题起源</h1><p>在多人开发，UI参次不齐的过程中。产生了大量的问题。其中最主要的就是统一滚动区域。</p><h1 id="思考解决方案的历程"><a href="#思考解决方案的历程" class="headerlink" title="思考解决方案的历程"></a>思考解决方案的历程</h1><ul><li>提供一个动态style，通过复制到各个使用的页面去解决；（无法统一修改，维护麻烦）</li><li>提供一个动态类，通过vuex去缓存，再各个页面去调用；（由vuex统一维护，但是使用麻烦）</li></ul><h1 id="终极解决方案"><a href="#终极解决方案" class="headerlink" title="终极解决方案"></a>终极解决方案</h1><p>通过全局动态插入css脚本，给某个id或者类赋值的方式<br>使用时给对应div添加该id或者类即可</p><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">mounted</span></span>() &#123;</span><br><span class="line">  const that = this</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">fixHeight</span></span>() &#123;</span><br><span class="line">    that.clientHeight = document.body.clientHeight</span><br><span class="line">    <span class="built_in">let</span> height = 0</span><br><span class="line">    <span class="keyword">if</span> (that.clientHeight &lt; 855) &#123;</span><br><span class="line">      const calc = 855 - that.clientHeight</span><br><span class="line">      height = (550 - calc) &gt; 200 ? 550 - calc : 200</span><br><span class="line">    &#125;</span><br><span class="line">    var style = document.createElement(<span class="string">&#x27;style&#x27;</span>)</span><br><span class="line">    style.type = <span class="string">&#x27;text/css&#x27;</span></span><br><span class="line">    try &#123;</span><br><span class="line">      style.appendChild(document.createTextNode(<span class="string">&#x27;#formBody&#123;height:&#x27;</span> + (that.clientHeight - 250) + <span class="string">&#x27;px&#x27;</span> + <span class="string">&#x27;&#125;&#x27;</span>))</span><br><span class="line">    &#125; catch (ex) &#123;</span><br><span class="line">      style.styleSheet.cssText = <span class="string">&#x27;#formBody&#123;height:&#x27;</span> + (that.clientHeight - 250) + <span class="string">&#x27;px&#x27;</span> + <span class="string">&#x27;&#125;&#x27;</span>// 针对IE</span><br><span class="line">    &#125;</span><br><span class="line">    var <span class="built_in">head</span> = document.getElementsByTagName(<span class="string">&#x27;head&#x27;</span>)[0]</span><br><span class="line">    head.appendChild(style)</span><br><span class="line">  &#125;</span><br><span class="line">  window.onload = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    fixHeight()</span><br><span class="line">    window.onresize = throttle(fixHeight, 300)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在对应页面添加 #formBody 即可<br>优化点： 可以在插入之前删掉之前插入的。<br>因为这个会根据窗口高度不断变化，不断插入，不删也不影响。<br>因为后面会覆盖前面的</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 三元运算符妙用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 回溯算法</title>
      <link href="/2022/05/21/JS-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
      <url>/2022/05/21/JS-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。<br>解题步骤</p><ul><li>1.定义一个解空间，它包含问题的解；</li><li>2.利用适于搜索的方法组织解空间；</li><li>3.利用深度优先法搜索解空间；</li><li>4.利用限界函数避免移动到不可能产生解的子空间。</li></ul><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。（不包含重复的数组）<br>示例:<br>输入: nums &#x3D; [1,2,3]<br>输出:[3][1][2][1,2,3][1,3][2,3][1,2][]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> allResult(nums)&#123;</span><br><span class="line">  <span class="built_in">let</span> arr = [[]]</span><br><span class="line">  <span class="keyword">function</span> digui(combine,idx)&#123;</span><br><span class="line">    combine.push(nums[idx])</span><br><span class="line">    arr.push([...combine])  </span><br><span class="line">    <span class="keyword">while</span>(idx !== nums.length-1) &#123;</span><br><span class="line">      idx++</span><br><span class="line">      digui([...combine],idx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  nums.map((item,idx)=&gt;&#123;</span><br><span class="line">    digui([],idx)</span><br><span class="line">  &#125;)  </span><br><span class="line">  <span class="built_in">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 滚动窗口视图算法</title>
      <link href="/2022/05/21/JS-%E6%BB%9A%E5%8A%A8%E7%AA%97%E5%8F%A3%E8%A7%86%E5%9B%BE%E7%AE%97%E6%B3%95/"/>
      <url>/2022/05/21/JS-%E6%BB%9A%E5%8A%A8%E7%AA%97%E5%8F%A3%E8%A7%86%E5%9B%BE%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="滑动窗口算法"><a href="#滑动窗口算法" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h1><p>滑动窗口算法在一个特定大小的字符串或数组上进行操作，而不在整个字符串和数组上操作，这样就降低了问题的复杂度，从而也达到降低了循环的嵌套深度。</p><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>无重复字符的最长子串<br>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。<br>输入: s &#x3D; “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @<span class="built_in">return</span> &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var lengthOfLongestSubstring = <span class="keyword">function</span>(s) &#123;</span><br><span class="line">    // 窗口视图拖动</span><br><span class="line">    var maxL = 0</span><br><span class="line">    var i = 0</span><br><span class="line">    <span class="keyword">while</span>(s.length &gt;= i) &#123;</span><br><span class="line">        var j = i+1      </span><br><span class="line">        <span class="keyword">while</span>(s.length &gt;= j)&#123;</span><br><span class="line">            var tmpStr = s.substring(i,j)</span><br><span class="line">            maxL = Math.max(maxL,tmpStr.length)</span><br><span class="line">            <span class="keyword">if</span>(tmpStr.indexOf(s.charAt(j)) &gt; -1)&#123;</span><br><span class="line">              <span class="built_in">break</span>  </span><br><span class="line">            &#125;</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> maxL</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 双指针算法</title>
      <link href="/2022/05/21/JS-%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/"/>
      <url>/2022/05/21/JS-%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><p>双指针指的是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个相同方向（快慢指针）或者相反方向（对撞指针）的指针进行扫描，从而达到相应的目的。</p><h1 id="案例-对撞指针"><a href="#案例-对撞指针" class="headerlink" title="案例 对撞指针"></a>案例 对撞指针</h1><p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。<br>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。<br>例如，121 是回文，而 123 不是。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number&#125; x</span><br><span class="line"> * @<span class="built_in">return</span> &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line">var isPalindrome = <span class="keyword">function</span>(x) &#123;</span><br><span class="line">    // 双指针解法 </span><br><span class="line">    x = String(x)</span><br><span class="line">    <span class="keyword">if</span>(x.length == 1) <span class="built_in">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="built_in">let</span> i = 0,j=x.length -1</span><br><span class="line">    <span class="keyword">while</span>(x.charAt(i) === x.charAt(j) )&#123;</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j ) <span class="built_in">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React fiber原理解析</title>
      <link href="/2022/05/20/React-fiber%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/05/20/React-fiber%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Fiber-起源"><a href="#Fiber-起源" class="headerlink" title="Fiber 起源"></a>Fiber 起源</h1><p>Fiber架构诞生于React16，是为了解决React15及之前版本的更新不可中断问题的。</p><h1 id="堆栈协调Stack-Reconciler"><a href="#堆栈协调Stack-Reconciler" class="headerlink" title="堆栈协调Stack Reconciler"></a>堆栈协调Stack Reconciler</h1><p>在React15的时候，React采用的还是堆栈协调Stack Reconciler，之所以把它成为堆栈协调，是因为React是使用递归来构建虚拟Dom树(React 15的叫法)的，构建过程中，数据被保存在递归调用栈中。由于递归是同步执行的，所以它一旦执行就只能执行完，不能被中途打断。这导致浏览器在执行代码时，Stack Reconciler 经常由于需要协调非常多的节点而耗费大量时间，而浏览器的UI渲染工作迟迟得不到执行</p><h1 id="Fiber协调器-Fiber-Reconciler"><a href="#Fiber协调器-Fiber-Reconciler" class="headerlink" title="Fiber协调器 Fiber Reconciler"></a>Fiber协调器 Fiber Reconciler</h1><p>在React16发布时推出了全新的Fiber架构，旨在解决老版本的更新不可中断问题。<br>一个大的同步任务可以分成许多小的同步任务，在浏览器运作的时候，平均的把这些小的同步任务塞到每一帧的一小块时间里执行，这种做法我们称为可中断的异步更新。</p><h1 id="Fiber工作流程"><a href="#Fiber工作流程" class="headerlink" title="Fiber工作流程"></a>Fiber工作流程</h1><p>双缓存机制<br>我们在图像处理的时候，往往会经历渲染画面-清除画面-重新渲染画面这个过程，往往清除画面后进行重绘的时候，可能会比较耗时，这时候用户就会感知到闪屏的现象。如果我们在内存中进行当前帧画面的构建，构建完毕后直接替换之前的画面，省去清屏的步骤，这样就节省了很多时间，很大程度上改善了用户体验。</p><p>所以在React中，我们也使用了双缓存机制，即系统中始终存在着两棵Fiber树，一棵对应的是当前DOM在屏幕上显示的画面，被称作current，此时我们称其为当前组件树，一棵是在内存中进行构建的新的Fiber树，被称作workInProgress，此时我们称其为正在构建中的组件树</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">App</span></span>() &#123;</span><br><span class="line">  const [num , setNum] = useState(0);</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">        &lt;p onClick=&#123;()=&gt;setNum(num + 1)&#125;&gt;</span><br><span class="line">           &#123;num&#125;</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Fiber-初始化首屏渲染"><a href="#Fiber-初始化首屏渲染" class="headerlink" title="Fiber 初始化首屏渲染"></a>Fiber 初始化首屏渲染</h1><p>一开始Fiber会构建 一个FiberRootNode和RootFiber，FiberRootNode的current指针指向rootFiber，此时rootFiber是为空的。</p><p>然后根据组件树返回的jsx对象，在render阶段创建新的rootFiber</p><p>这一步是递归的创建workInProgress，创建完workInProgress后，然后在commit阶段把这棵树渲染到页面上，此时修改current指针指向workInProgress，使其成为新的current树<br>current和workInProgress通过alternate互相连接</p><h1 id="Fiber树更新"><a href="#Fiber树更新" class="headerlink" title="Fiber树更新"></a>Fiber树更新</h1><p>在我们点击p使得页面触发更新后，React会在内存中重新构建一棵完整的Fiber树，也就是workInProgress<br>在构建完成后会直接让current指针指向它，然后render阶段就会基于这个新的current进行渲染。<br>在此过程中我们可以使用Diff算法决定是否复用current树中的节点，省去创建节点的流程，进一步加快渲染过程</p><h1 id="节点复用"><a href="#节点复用" class="headerlink" title="节点复用"></a>节点复用</h1><p>在页面更新时，由于React的双缓存机制，在渲染页面的时候，会先从内存中构建一棵Fiber树，等构建完毕后，直接改变current指针的指向替换掉当前的Fiber树，达到页面更新的目的。<br>如果重新的从无到有渲染一棵完整的Fiber树，是很耗时的，所以我们可以基于 current 树来复用一些节点创建workInProgress树.<br>我们会使用Diff算法来决定是否复用节点，要复用的节点就是current.alternate。</p><h1 id="Fiber-调度机制"><a href="#Fiber-调度机制" class="headerlink" title="Fiber 调度机制"></a>Fiber 调度机制</h1><p>Fiber将一个DOM更新任务拆分为由多个原子化可调度的节点组成的集合，从而提供了细粒度的任务调度能力。<br>Fiber架构由2部分组成：分发器（dispatcher）和调度器（scheduler）。</p><p>当点击p，触发点击事件，将事件会触发分发器的转换动作。可以先简单的认为分发器将触发1个FiberNode的更新： p文本由0变为1。</p><p>Task<br>分发器与调度器之间通过Task进行通信。Task对应的是组件的挂载或更新动作。由FiberRoot和FiberTree构成。<br>FiberTree是由一个一个FiberNode以单链表的形式组合成的节点集合。<br>FiberNode是调度器执行的最小单位，每执行完一个FiberNode更新后，线程的控制权将转交给调度器，由调度器来选择下一个执行的任务（继续或中断插入其他任务）。</p><p>Task调度过程<br>组件的初始化挂载或事件驱动更新都会触发一个任务的启动。</p><p>Task 挂起<br>开始执行过程。在执行每个节点单元的时候会先判断浏览器是否有空余时间执行下一个工作单元。当不满足向下执行条件时（比如有其他高优先级的任务插入，或则当前时间片已用完），任务中断，被挂起。</p><p>Task 任务恢复<br>任务执行过程中，每一个FiberNode的执行结果都会标记在属性上。调度模块重新执行挂起任务时，本质上是重新执行该更新任务，在具体更新每一FiberNode的时候会根据节点上的缓存属性判断该节点是否（props参数前后比对）需要重新计算更新数据，需要则逻辑不变，不需要则跳过。</p><p>Task 任务结束<br>当整个FiberTree中的节点都被处理后，统一提交所有FiberNode更新。并将更新结果统一反应到界面上，到此任务结束，任务将会被注销，同时回收FiberRoot保存的上下文。</p><h1 id="commit阶段"><a href="#commit阶段" class="headerlink" title="commit阶段"></a>commit阶段</h1><p>commit阶段的主要职责就是将render阶段创建的fiber树渲染到页面中，也就是要执行具体的dom操作。</p><ul><li>渲染前(before mutation)</li><li>渲染(mutation)</li><li>渲染后(layout)<br>各阶段执行函数<br>before mutation阶段：commitBeforeMutationEffects<br>mutation阶段：commitMutationEffects<br>layout阶段 commitLayoutEffects</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>Fiber 调度机制<br>Fiber 主要是可以在React更新节点的时候挂起更新，以往的由递归更新同步执行。<br>现在是由调度器在执行完每一个Task下的FiberNode（调度器执行的最小单元），将执行权返回调度器，由调度器决定 继续执行还是挂起等待。<br>当任务和FiberNode非常大的时候，也会存在性能瓶颈。</p></li><li><p>Fiber 工作流程<br>Fiber 是双缓存机制。在首屏初始化的时候 会创建一个 FiberRootNode 和 FiberRoot，<br>FiberRootNode.current 指向 FiberRoot。<br>在构建返回的jsx时，会额外创建一个工作中的FiberRoot，FiberRoot下面的节点与dom一致。<br>在构建时，会根据diff算法进行比对是否可以复用节点；<br>构建完成后，将FiberRootNode.current 指向该工作中的FiberRoot。</p></li></ul><p>最后提交到Commit交给浏览器渲染</p><h1 id="Fiber的主要目标是利用React的Scheduling的优势"><a href="#Fiber的主要目标是利用React的Scheduling的优势" class="headerlink" title="Fiber的主要目标是利用React的Scheduling的优势"></a>Fiber的主要目标是利用React的Scheduling的优势</h1><p>当前React并没有充分利用Scheduling的优势，一次更新会导致立刻重新渲染整个子树。<br>Fiber背后的思想就是彻底革新整个核心算法以充分利用Scheduling的优势。<br>它可以做到： </p><ul><li>暂停工作，并回来</li><li>为不同类型任务分配优先级</li><li>重用以前完成的工作</li><li>不需要的时候终止任务<br>为了做到这一点，我们需要一种将工作分解成多个单元的方法。从某种意义上来说，这就是Fiber。Fiber是一个最小工作单元</li></ul><h1 id="计算机工作原理"><a href="#计算机工作原理" class="headerlink" title="计算机工作原理"></a>计算机工作原理</h1><p>计算机通常使用调用堆栈来跟踪程序执行的方式，一个函数被调用的时候，一个新的stack frame被添加到堆栈中，这个stack frame也代表了这个函数的工作也被执行了</p><h1 id="Fiber是堆栈的重新实现，也可以将其视为虚拟堆栈-。"><a href="#Fiber是堆栈的重新实现，也可以将其视为虚拟堆栈-。" class="headerlink" title="Fiber是堆栈的重新实现，也可以将其视为虚拟堆栈 。"></a>Fiber是堆栈的重新实现，也可以将其视为虚拟堆栈 。</h1><p>重新实现堆栈的优势在于，你可以将堆栈保存在内存中，并根据需要（以及任何时候）执行他们，这对于我们的目标来说至关重要。<br>除了任务调度之外，手动处理堆栈还可以释放并发和错误边界等功能。</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> filber </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Router源码解析</title>
      <link href="/2022/05/20/React-Router%E5%8E%9F%E7%90%86/"/>
      <url>/2022/05/20/React-Router%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="BrowserRouter"><a href="#BrowserRouter" class="headerlink" title="BrowserRouter"></a>BrowserRouter</h1><p>BrowserRouter 一般是作为 App 的 container</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;BrowserRouter&gt;</span><br><span class="line">      &lt;App /&gt;</span><br><span class="line">    &lt;/BrowserRouter&gt;,</span><br><span class="line">  document.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们从BrowserRouter 入口开始,看看其做了哪些初始化工作：</span></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> BrowserRouter(&#123;</span><br><span class="line">  <span class="built_in">basename</span>,</span><br><span class="line">  children,</span><br><span class="line">  window</span><br><span class="line">&#125;: BrowserRouterProps) &#123;</span><br><span class="line">  const historyRef = React.useRef&lt;BrowserHistory&gt;();</span><br><span class="line">  <span class="keyword">if</span> (historyRef.current == null) &#123;</span><br><span class="line">    // 如果为空，则创建</span><br><span class="line">    // createBrowserHistory 是一个基于当前window构造的一个<span class="built_in">history</span> 的构造函数</span><br><span class="line">    // <span class="built_in">history</span> 拥有两个可读的属性 action location，以及路由跳转，路由监听的一些方法</span><br><span class="line">    historyRef.current = createBrowserHistory(&#123; window &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const <span class="built_in">history</span> = historyRef.current;</span><br><span class="line">  const [state, setState] = React.useState(&#123;</span><br><span class="line">    action: history.action,</span><br><span class="line">    location: history.location</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  React.useLayoutEffect(() =&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * popstate、push、replace时如果没有blokcers的话，会调用applyTx(nextAction)触发这里的setState</span><br><span class="line">     * <span class="keyword">function</span> applyTx(nextAction: Action) &#123;</span><br><span class="line">     *   action = nextAction;</span><br><span class="line">     * //  获取当前index和location</span><br><span class="line">     *   [index, location] = getIndexAndLocation();</span><br><span class="line">     *   listeners.call(&#123; action, location &#125;);</span><br><span class="line">     * &#125;</span><br><span class="line">     */</span><br><span class="line">    history.listen(setState)</span><br><span class="line">  &#125;, [<span class="built_in">history</span>]);</span><br><span class="line">  // 一般变化的就是action和location</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    &lt;Router</span><br><span class="line">      <span class="built_in">basename</span>=&#123;<span class="built_in">basename</span>&#125;</span><br><span class="line">      children=&#123;children&#125;</span><br><span class="line">      action=&#123;state.action&#125;</span><br><span class="line">      location=&#123;state.location&#125;</span><br><span class="line">      navigator=&#123;<span class="built_in">history</span>&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="createHashHistory-与-createBrowserHistory-的不同点"><a href="#createHashHistory-与-createBrowserHistory-的不同点" class="headerlink" title="createHashHistory 与 createBrowserHistory 的不同点"></a>createHashHistory 与 createBrowserHistory 的不同点</h1><p>createBrowserHistory 是直接获取 window.location，而 createHashHistory 是 parsePath(window.location.hash.substr(1))<br>即 url 中有多个#，但是会取第一个#后面的来解析对应的 pathname、search 和 hash<br>createHashHistory 多了监听 hashchange的事件<br>createHref 会在前面拼接 getBaseHref() + ‘#’</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><ul><li>通过 push、replace 和 go 可以切换路由</li><li>可以通过 history.listen 添加路由监听器 listener，每当路由切换可以收到最新的 action 和 location，从而做出不同的判断</li><li>可以通过 history.block 添加阻塞器 blocker，会阻塞 push、replace 和浏览器的前进后退。</li><li>且只要判断有 blockers，那么同时会加上beforeunload阻止浏览器刷新、关闭等默认行为，即弹窗提示。</li><li>且只要有 blocker，那么上面的 listener 就监听不到</li></ul>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>React自定义Hook</title>
      <link href="/2022/05/19/React%E8%87%AA%E5%AE%9A%E4%B9%89Hook/"/>
      <url>/2022/05/19/React%E8%87%AA%E5%AE%9A%E4%B9%89Hook/</url>
      
        <content type="html"><![CDATA[<h1 id="为何要自定义Hook"><a href="#为何要自定义Hook" class="headerlink" title="为何要自定义Hook"></a>为何要自定义Hook</h1><p>抽离公共逻辑hook，复用代码，而且数据隔离</p><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>想要一个公共获取详情的Hook</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> useGetDetail(<span class="built_in">id</span>,url,params=&#123;&#125;)&#123;</span><br><span class="line">  const [detail, setDetail] = useState(null);</span><br><span class="line">  useEffect(async ()=&gt;&#123;</span><br><span class="line">    const data = await axios.get(url+<span class="built_in">id</span>,params)</span><br><span class="line">    setDetail(data.result);</span><br><span class="line">  &#125;,[])</span><br><span class="line">  <span class="built_in">return</span> detail</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这样就可以通过 useGetDetail(id,url,params)去获取对应的详情</span></span><br><span class="line">const detail1 = useGetDetail(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;xxxx/api/detail?id=&#x27;</span>,&#123;&#125;)</span><br><span class="line">const detail2 = useGetDetail(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;xxxx/api/detail?id=&#x27;</span>,&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意，自定义Hook必须以use开头，不然eslint检测不到这是一个自定义Hook</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>试图处理antd-mobile Issue的心路历程</title>
      <link href="/2022/05/05/%E8%AF%95%E5%9B%BE%E5%A4%84%E7%90%86antd-mobile-Issue%E7%9A%84%E6%96%B0%E8%B7%AF/"/>
      <url>/2022/05/05/%E8%AF%95%E5%9B%BE%E5%A4%84%E7%90%86antd-mobile-Issue%E7%9A%84%E6%96%B0%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="问题：antd-mobile-Swiper-在滑动切换的时候，触发点击事件，会导致Swiper卡住"><a href="#问题：antd-mobile-Swiper-在滑动切换的时候，触发点击事件，会导致Swiper卡住" class="headerlink" title="问题：antd-mobile Swiper 在滑动切换的时候，触发点击事件，会导致Swiper卡住"></a>问题：antd-mobile Swiper 在滑动切换的时候，触发点击事件，会导致Swiper卡住</h1><h1 id="开始调研相关swiper插件，发现都有这样的问题，如vant等"><a href="#开始调研相关swiper插件，发现都有这样的问题，如vant等" class="headerlink" title="开始调研相关swiper插件，发现都有这样的问题，如vant等"></a>开始调研相关swiper插件，发现都有这样的问题，如vant等</h1><h1 id="只能进入源码层研究"><a href="#只能进入源码层研究" class="headerlink" title="只能进入源码层研究"></a>只能进入源码层研究</h1><ul><li>fork ant-design-mobile 关联到自己仓库</li><li>git clone ant-design-mobile 下载到本地运行</li><li>yarn install &amp;&amp; yarn start 安装依赖并本地运行调试</li><li>切换到 <code>./src/components/swiper/swiper.tsx</code></li></ul><h1 id="开始分析-swiper-构成"><a href="#开始分析-swiper-构成" class="headerlink" title="开始分析 swiper 构成"></a>开始分析 swiper 构成</h1><ul><li><p>主要依赖两个库 @react-spring&#x2F;web &amp;&amp; @use-gesture&#x2F;react<br><code>@react-spring/web</code> 主要是对动画的优化<br><code>@use-gesture/react</code> 是对手势的操作处理<br>很明显该bug产生的原因是因为滑动即拖拽手势，而产生的</p></li><li><p>分析<code>@use-gesture/react</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useDrag &#125; from <span class="string">&#x27;@use-gesture/react&#x27;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">const <span class="built_in">bind</span> = useDrag(</span><br><span class="line">  state =&gt; &#123;</span><br><span class="line">    const slidePixels = getSlidePixels()</span><br><span class="line">    <span class="keyword">if</span> (!slidePixels) <span class="built_in">return</span></span><br><span class="line">    const paramIndex = isVertical ? 1 : 0</span><br><span class="line">    const offset = state.offset[paramIndex]</span><br><span class="line">    const direction = state.direction[paramIndex]</span><br><span class="line">    const velocity = state.velocity[paramIndex]</span><br><span class="line">    setDragging(<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">if</span> (!state.last) &#123;</span><br><span class="line">      api.start(&#123;</span><br><span class="line">        position: (offset * 100) / slidePixels,</span><br><span class="line">        immediate: <span class="literal">true</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      const minIndex = Math.floor(offset / slidePixels)</span><br><span class="line">      const maxIndex = minIndex + 1</span><br><span class="line">      const index = Math.round(</span><br><span class="line">        (offset + velocity * 2000 * direction) / slidePixels</span><br><span class="line">      )</span><br><span class="line">      swipeTo(bound(index, minIndex, maxIndex))</span><br><span class="line">      window.setTimeout(() =&gt; &#123;</span><br><span class="line">        setDragging(<span class="literal">false</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    transform: ([x, y]) =&gt; [-x, -y],</span><br><span class="line">    from: () =&gt; &#123;</span><br><span class="line">      const slidePixels = getSlidePixels()</span><br><span class="line">      <span class="built_in">return</span> [</span><br><span class="line">        (position.get() / 100) * slidePixels,</span><br><span class="line">        (position.get() / 100) * slidePixels,</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    bounds: () =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (loop) <span class="built_in">return</span> &#123;&#125;</span><br><span class="line">      const slidePixels = getSlidePixels()</span><br><span class="line">      const lowerBound = boundIndex(0) * slidePixels</span><br><span class="line">      const upperBound = boundIndex(count - 1) * slidePixels</span><br><span class="line">      <span class="built_in">return</span> isVertical</span><br><span class="line">        ? &#123;</span><br><span class="line">            top: lowerBound,</span><br><span class="line">            bottom: upperBound,</span><br><span class="line">          &#125;</span><br><span class="line">        : &#123;</span><br><span class="line">            left: lowerBound,</span><br><span class="line">            right: upperBound,</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    rubberband: props.rubberband,</span><br><span class="line">    axis: isVertical ? <span class="string">&#x27;y&#x27;</span> : <span class="string">&#x27;x&#x27;</span>,</span><br><span class="line">    preventScroll: <span class="literal">true</span>,</span><br><span class="line">    pointer: &#123;</span><br><span class="line">      <span class="built_in">touch</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>发现将 preventScroll 设置为 false 则bug消失了。<br>产生新的问题： 在拖拽的时候会存在纵向滚动的问题</p></li><li><p>查看 use-gesture 文档，发现 该属性是个实验性的属性，建议使用 axis 配合 touchAction 达到同等效果。修改源码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const touchMero: object = useMemo(()=&gt;&#123;</span><br><span class="line">  console.log(dragging)</span><br><span class="line">  <span class="built_in">return</span> dragging ? &#123;touchAction: <span class="string">&#x27;pan-x&#x27;</span>&#125; : &#123;&#125;</span><br><span class="line">&#125;,[dragging])</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&lt;animated.div</span><br><span class="line">  className=<span class="string">&#x27;adm-swiper-track-inner&#x27;</span></span><br><span class="line">  style=&#123;&#123;</span><br><span class="line">    [isVertical ? <span class="string">&#x27;y&#x27;</span> : <span class="string">&#x27;x&#x27;</span>]: position.to(</span><br><span class="line">      position =&gt; `<span class="variable">$&#123;-position&#125;</span>%`</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">  &#125;&#125;</span><br><span class="line">&gt;</span><br><span class="line">  &#123;React.Children.map(validChildren, child =&gt; &#123;</span><br><span class="line">    <span class="built_in">return</span> &lt;div className=<span class="string">&#x27;adm-swiper-slide&#x27;</span> style=&#123;touchMero&#125;&gt;&#123;child&#125;&lt;/div&gt;</span><br><span class="line">  &#125;)&#125;</span><br><span class="line">&lt;/animated.div&gt;</span><br></pre></td></tr></table></figure><p>在微信环境，功能一切正常了。<br>在Safair环境，依旧存在纵向滚动的问题</p></li><li><p>查看 use-gesture github<br>发现该属性确实在Safair存在bug，<a href="https://github.com/pmndrs/use-gesture/issues/486#issue-1212399919">Issue</a></p></li><li><p>最后只能不了了之，等待第三方插件的维护人员修复这个bug</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>该bug是由antd-mobile依赖的第三方插件引起的。所以一时半会也处理不了。<br>终于明白为什么antd-pro要自己封装完整的工具链，继承到umi，dva里面。<br>如果什么都要等他们修复，不知道要等到什么时候。<br>最终的结果可能是，该框架存在很多无法解决的bug，大多来源于第三方插件。</p>]]></content>
      
      
      <categories>
          
          <category> Issue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Issue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三元运算符转二元的的妙用</title>
      <link href="/2022/05/04/%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%E8%BD%AC%E4%BA%8C%E5%85%83%E7%9A%84%E7%9A%84%E5%A6%99%E7%94%A8/"/>
      <url>/2022/05/04/%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%E8%BD%AC%E4%BA%8C%E5%85%83%E7%9A%84%E7%9A%84%E5%A6%99%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 三元运算符</span></span><br><span class="line">var obj = &#123;a: 1&#125;</span><br><span class="line"></span><br><span class="line">var a = obj.a ? obj.a : undefined</span><br><span class="line"></span><br><span class="line"><span class="comment"># ?.的妙用</span></span><br><span class="line">var obj = &#123;a: 1&#125;</span><br><span class="line"></span><br><span class="line">var a = obj?.a </span><br><span class="line"></span><br><span class="line"><span class="comment"># 在jsx的语法中，经常需要模版语法根据条件渲染，此时可以缩减写法</span></span><br><span class="line">const obj = &#123;arr: [1,2,3], &#125;</span><br><span class="line">obj?.arr.map((item)=&gt;&#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    &lt;div&gt;&#123;item&#125;&lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment"># 因为obj.arr1不存在所以不会执行</span></span><br><span class="line">obj.arr1?.arr1.map((item)=&gt;&#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    &lt;div&gt;&#123;item&#125;&lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 三元运算符妙用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提交PR完整流程</title>
      <link href="/2022/04/30/%E6%8F%90%E4%BA%A4PR%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B/"/>
      <url>/2022/04/30/%E6%8F%90%E4%BA%A4PR%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="首先，fork项目到本地"><a href="#首先，fork项目到本地" class="headerlink" title="首先，fork项目到本地"></a>首先，fork项目到本地</h1><ol><li>访问想要PR的github项目</li><li>点击Start旁边的Fork，fork到自己的仓库</li><li>通过git clone xxx 下载到本地</li></ol><h1 id="创建Issues"><a href="#创建Issues" class="headerlink" title="创建Issues"></a>创建Issues</h1><ol><li><p>Issues标题格式规范<br><code>[标签] 标题 </code> 的格式: “[bug] 点击获取验证码的时候有问题”</p></li><li><p>内容规范</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 背景</span></span><br><span class="line"></span><br><span class="line">- 描述你希望解决的问题的现状</span><br><span class="line">- 附上相关的 issue 地址</span><br><span class="line"></span><br><span class="line"><span class="comment">## 思路</span></span><br><span class="line"></span><br><span class="line">描述大概的解决思路，可以包含 API 设计和伪代码等</span><br><span class="line"></span><br><span class="line"><span class="comment">## 跟进</span></span><br><span class="line"></span><br><span class="line">后续编辑，附上对应的 Pull Request 地址，可以用 `- [ ] some task` 的方式。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 案例</span></span><br><span class="line">标题：[RFC] 框架统一错误码</span><br><span class="line"><span class="comment"># 背景</span></span><br><span class="line">Egg 生态插件众多，研发流程可能会抛出各种框架、插件异常，开发者难以自行定位和解决</span><br><span class="line"></span><br><span class="line">* 没有统一的错误引导文档，目前的文档分散在官网、语雀各个空间里；错误和文档之间没有建立联系</span><br><span class="line">* 一些底层 sdk 的抛错已经丢失了链路信息，定位很困难。例如：mysql 客户端抛 ACCESS_DENIED_ERROR，已经在最后环节，但是问题可能是在上层 SDK 的使用上</span><br><span class="line"><span class="comment"># 目标</span></span><br><span class="line">* 所有框架、中间件抛出的异常信息，带上对应的 FAQ 自查文档；向下兼容对非统一 Error 的错误展示</span><br><span class="line">* 覆盖研发流程的所有阶段：CLI 命令、应用启动、运行时</span><br><span class="line">* 逐步对框架和中间件使用统一的 Error 改造，补充 FAQ 文档</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方案</span></span><br><span class="line">具体实现的大致思路...</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>拓展词汇缩写<br>WIP：work in progress 进展中，比如 The next major version of Vue (WIP)<br>RFC：request for comments 请求意见稿，<br>PR：pull request 请求合并<br>CR：code review 代码审查<br>BTW： By the way 顺便说一下<br>FYI：For your information 供您参考<br>ASAP：As soon as possible马上，尽快<br>LGTM：Look good to me 看起来不错，代码已review，可以合并</p></li></ol><h1 id="认领Issues-对Issues打标签，指派给某个开发者"><a href="#认领Issues-对Issues打标签，指派给某个开发者" class="headerlink" title="认领Issues,对Issues打标签，指派给某个开发者"></a>认领Issues,对Issues打标签，指派给某个开发者</h1><p>该仓库的维护者可以对这个Issues做一些事情：</p><ul><li>指派开发者去修复这个Issues</li><li>打标签 Labels Assignees </li><li>创建指定分支去维护</li></ul><h1 id="在Fork到本地的代码，修复了bug后，推送到远程仓库，开始提交PR"><a href="#在Fork到本地的代码，修复了bug后，推送到远程仓库，开始提交PR" class="headerlink" title="在Fork到本地的代码，修复了bug后，推送到远程仓库，开始提交PR"></a>在Fork到本地的代码，修复了bug后，推送到远程仓库，开始提交PR</h1><p>在远程仓库项目主页可以看到提交记录旁边存在两个按钮Contribute和Fetch-upstream<br>点击Contribut -》 点击 Open pull request -》 Create pull request<br>输入本次提交的标题和描述 -》 点击Create pull request</p><p>此时 已经完成了PR的提交了<br>原项目的管理者可以到项目的Pull request 去合并完成整个Issues的修复</p><h1 id="测试git切换账号提交"><a href="#测试git切换账号提交" class="headerlink" title="测试git切换账号提交"></a>测试git切换账号提交</h1>]]></content>
      
      
      <categories>
          
          <category> Issue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度理解浏览器从访问url到页面展示的全过程</title>
      <link href="/2022/04/29/%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%8E%E8%AE%BF%E9%97%AEurl%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/"/>
      <url>/2022/04/29/%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%8E%E8%AE%BF%E9%97%AEurl%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器的多进程架构"><a href="#浏览器的多进程架构" class="headerlink" title="浏览器的多进程架构"></a>浏览器的多进程架构</h1><p>因为js是单线程的，一个线程可以有多个进程<br>浏览器的三大主要进程：</p><ol><li>浏览器进程<br>主要负责用户交互、子进程管理和文件存储等功能</li><li>网络进程<br>面向渲染进程和浏览器进程等提供网路下载功能</li><li>渲染进程<br>把从网络下载的资源文件解析为可以显示和交互的页面。因为渲染进程里面所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对操作系统进行攻击，所以运行在渲染进程里面的代码是被不信任的。这也是为什么 Chrome 会让渲染进程运行在安全沙箱里，为了保证系统的安全。</li></ol><h1 id="整个过程的大体描述"><a href="#整个过程的大体描述" class="headerlink" title="整个过程的大体描述"></a>整个过程的大体描述</h1><ul><li>首先用户从浏览器进程里输入请求信息</li><li>然后网络进程向服务器发起 URL 请求</li><li>服务器响应 URL 请求后，浏览器进程开始准备渲染进程</li><li>渲染进程准备好之后，需要向渲染进程提交待渲染的资源文档，提交文段阶段</li><li>渲染进程接收到文档后，便开始解析页面和加载子资源，完成页面的渲染</li><li>完成页面的渲染后，将渲染的图片交给浏览器进程，浏览器进程负责展示</li></ul><h1 id="从输入-URL-到页面展示的具体细节"><a href="#从输入-URL-到页面展示的具体细节" class="headerlink" title="从输入 URL 到页面展示的具体细节"></a>从输入 URL 到页面展示的具体细节</h1><ol><li>URL请求过程<br>浏览器进程会通过进程间通信（IPC）把 URL 请求发送至网络进程，网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求流程<br>首先，网络进程基于http缓存协议去执行该Url的请求<br>如果已经存在该资源且资源没有过期，则直接返回（命中强缓存）<br>如果没有或者已过期，则发起网络请求：</li></ol><ul><li>已过期，服务器发现该请求资源没有更新，则返回304，浏览器则取本地资源并更新</li><li>已过期，服务器发现该请求资源已经更新，则返回200，携带最新资源给浏览器</li><li>没有 则直接请求<br>浏览器缓存控制三种方式（Expires、Last-Modified、Etag）</li><li>第一次请求http响应头会有Last-Modified标记文件在服务器端最后被修改的时间。</li><li>浏览器第二次请求上次请求过的url时，浏览器会在HTTP请求头添加一个If-Modified-Since的标记，用来询问服务器该时间之后文件是否被修改过</li></ul><p>Etag 主要为了解决 Last-Modified 无法解决的一些问题:</p><ul><li>一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET;</li><li>某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)</li><li>某些服务器不能精确的得到文件的最后修改时间；</li></ul><p>浏览器是通过last-Modified Expires Etag控制缓存</p><p>第二次请求相同的资源的时候</p><ul><li>有缓存，过期了， 则判断Etag ？ 带If-None-Match ：判断last-Modified<br>判断 last-Modified ？ 带If-Modified-Since ： 发请求<br>根据服务器判断资源更新返回304或者200</li><li>缓存没有过期，则直接使用</li></ul><h1 id="根据响应的数据类型进行处理"><a href="#根据响应的数据类型进行处理" class="headerlink" title="根据响应的数据类型进行处理"></a>根据响应的数据类型进行处理</h1><p>浏览器会根据响应头中的 Content-Type 字段，来决定如何显示响应体的内容。</p><ul><li>如果是HTML，那么浏览器会继续进行页面渲染，需要准备渲染进程<br>默认情况下，Chrome 会为每个页面分配一个渲染进程，即每打开一个新页面，Chrome就会创建分配一个新的渲染进程，在某些情况下，浏览器会让多个页面直接运行在同一个渲染进程中。Chrome 的默认策略是，每个标签对应一个渲染进程，但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的化，那么新页面会复用父页面的渲染进程。process-per-site-instance</li></ul><h1 id="渲染阶段"><a href="#渲染阶段" class="headerlink" title="渲染阶段"></a>渲染阶段</h1><p>浏览器的渲染过程主要分为五个步骤：</p><ol><li>浏览器将获取的 HTML 文档解析成 DOM 树；</li><li>处理 CSS 标记，构成层叠样式表模型（CSSOM）；</li><li>将 DOM 和 CSSOM 合并为渲染树（rendering tree）；</li><li>根据渲染树上的元素布局 layout</li><li>将渲染树上的各个节点绘制到屏幕上，称之为 绘制painting；</li></ol><h1 id="构建-DOM-树"><a href="#构建-DOM-树" class="headerlink" title="构建 DOM 树"></a>构建 DOM 树</h1><ul><li>DOM 树的构建可能会被 CSS 和 JS 的加载而阻塞；</li><li>display: none 的元素也会在 DOM 树中；</li><li>注释也会在 DOM 树中；</li><li>script 标签也会在 DOM 树中；</li></ul><h1 id="解析-CSS"><a href="#解析-CSS" class="headerlink" title="解析 CSS"></a>解析 CSS</h1><p>浏览器会解析 CSS 文件并生成 CSS 规则树，每个 CSS 文件都会被解析成 StyleSheet 对象，每个对象都包括 CSS 规则，CSS规则对象包括对应的选择器和声明对象以及其他对象；</p><ul><li>CSS 的解析可以与 DOM 的解析同步进行（因为渲染树需要Dom和CSSOM一起合成，所以无论哪个都会阻塞dom的渲染）</li><li>CSS 的解析与 script 的执行互斥</li><li>在 Webkit 内核中进行了 script 执行优化，只有在 JS 访问 CSS 时才会发生互斥</li></ul><h1 id="构建渲染树"><a href="#构建渲染树" class="headerlink" title="构建渲染树"></a>构建渲染树</h1><p>根据 DOM 树和 CSS 规则树，浏览器就可以构建渲染树了。浏览器首先遍历 DOM 树上的每一个可见节点，然后对每个可见节点找到匹配的 CSS 样式规则并应用</p><ol><li>渲染树和 DOM 树不完全对对应；</li><li>display: none 的元素不在渲染树中；</li><li>visiblity: none 的元素在渲染树中；</li></ol><h1 id="渲染树布局"><a href="#渲染树布局" class="headerlink" title="渲染树布局"></a>渲染树布局</h1><p>布局阶段浏览器会遍历渲染树的所有节点，由于每个节点都是一个render对象，都包含宽高、位置、背景等样式信息，所以浏览器就能根据这写信息来确定元素在页面中的所在位置，及其样式；</p><ol><li>float 元素、absolute 元素、fixed 元素会发生位置偏移；</li><li>脱离标准文档流就是脱离渲染树（render tree）；所以一些动画元素可以让其脱离渲染树，通过absolute等方式</li></ol><h1 id="渲染树的绘制"><a href="#渲染树的绘制" class="headerlink" title="渲染树的绘制"></a>渲染树的绘制</h1><p>绘制阶段，浏览器遍历所有的渲染树节点，调用 paint() 方法，将其渲染在屏幕上。渲染树的绘制工作是由浏览器的UI后端组件完成的。</p><h1 id="浏览器渲染过程可能出现的事情"><a href="#浏览器渲染过程可能出现的事情" class="headerlink" title="浏览器渲染过程可能出现的事情"></a>浏览器渲染过程可能出现的事情</h1><ul><li>阻塞渲染<br>浏览器会延迟 JavaScript 的执行和 DOM 的构建，</li></ul><ol><li>CSS 被默认为阻塞渲染的资源，所以在 CSSOM 构建完成之前不会处理任何已处理的内容；</li><li>JavaScript 可以读取和修改 DOM 属性，还可读取和修改 CSSOM 属性，所以 CSS 解析和 script 的执行互斥<br>因此，script标签的位置很重要我们在实际开发中应该尽量坚持以下两个原则： </li><li>在引入顺序上，CSS 资源先于 JavaScript 资源；</li><li>JavaScript 尽量少去影响 DOM 的构建；</li></ol><ul><li>回流和重绘（ reflow 和 repaint ）<br>display:none 会触发 reflow；<br>visibility: hidden 不会触发 reflow，只会触发 repaint；</li></ul><h1 id="优化渲染效率建议"><a href="#优化渲染效率建议" class="headerlink" title="优化渲染效率建议"></a>优化渲染效率建议</h1><ol><li>合法地去书写 HTML 和 CSS ，且不要忘了文档编码类型；</li><li>样式文档应该在 head 标签中，而脚本文档应该在 body 结束之前，防阻塞；</li><li>优化 CSS 选择器，尽量少嵌套；</li><li>减少 JavaScript 对 DOM 的操作；</li><li>修改元素的样式时，修改 class 是性能最高的方法；</li><li>尽量用 transform 来做形变和位移</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从输入Url -》 dns解析 -》http请求，响应-》页面渲染<br>这里最主要就是http请求响应与页面渲染<br>http请求响应又分3次握手4次挥手协议，与http请求缓存<br>页面渲染 -》多个进程一起工作 -》事件循环机制 -》 回流重绘 -》<br>多个进程： </p><ul><li>浏览器主进程</li><li>GPU进程</li><li>渲染进程<br>事件循环机制：（又分宏任物和微任务）<br>同步任务在JS线程上优先执行，形成一个执行栈<br>JS的异步是通过回调函数来实现的，JS只有一个执行线程。 通过把回调函数添加到任务队列中来实现<br>执行步骤：</li></ul><ol><li>先执行执行栈中的同步任务</li><li>异步任务放入任务队列</li><li>同步任务执行完毕，从任务队列中读取异步任务，进入执行栈，开始执行<br>异步任务的主要类型：（又分宏任物和微任务） 微任务优先执行<br>1、普通事件 如click resize 等<br>2、资源加载 如load error 等<br>3、定时器 setInterval 等<br>这些都是宏任物<br>ajax async属于微任务</li></ol><p>渲染进程的组成： </p><ol><li>GUI渲染线程，构建DOM树，构建CSSOM，两者合成渲染树，然后绘制在页面上。</li><li>JS引擎线程（V8引擎）由于js是单线程，依靠任务队列来进行js代码的执行，所以js引擎会一直等待着任务队列中任务的到来，然后加以处理。</li><li>事件触发线程，定时器触发线程，异步HTTP请求线程</li></ol><p>GUI渲染线程与JS引擎线程互斥 JS阻塞页面加载<br>JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。<br>因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系。<br>当JS引擎执行时GUI线程会被挂起，GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。</p><p>浏览器渲染的图层一般包含两大类：普通图层以及复合图层<br>可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源<br>translate3d、translateZ， z-index 都可以加速</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写一个loader</title>
      <link href="/2022/04/27/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAloader/"/>
      <url>/2022/04/27/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAloader/</url>
      
        <content type="html"><![CDATA[<h1 id="loader-原理"><a href="#loader-原理" class="headerlink" title="loader 原理"></a>loader 原理</h1><p>loader就像一个翻译员，能将源文件翻译后输出新的结果，并且一个文件可以链式的经过几个翻译员。<br>以.scss文件为例子：</p><ul><li>先将.scss文件内容交给sass-loader翻译为css</li><li>在将翻译后的css交给css-loader,找出css中依赖的资源，压缩css</li><li>再将css-loader输出的内容交给style-loader,转化为通过脚本加载的JavaScript代码</li></ul><p>1，本质是一个函数。<br>参数能获取目标的内容，<br>结果能传递给下一个loader。</p><p>2.自定义loader要使用绝对路径引入。</p><h1 id="自定义一个loader"><a href="#自定义一个loader" class="headerlink" title="自定义一个loader"></a>自定义一个loader</h1><ul><li>首先定义一个loader自动在jsx文件中</li></ul>]]></content>
      
      
      <categories>
          
          <category> Webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Loader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>useCallback 和 useMemo 的区别</title>
      <link href="/2022/04/25/useCallback-%E5%92%8C-useMemo-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/04/25/useCallback-%E5%92%8C-useMemo-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h1><p>const memoizedCallback &#x3D; useCallback(<br>  () &#x3D;&gt; {<br>    doSomething(a, b);<br>  },<br>  [a, b],<br>);<br>把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件时，它将非常有用。</p><h1 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h1><p>const memoizedValue &#x3D; useMemo(() &#x3D;&gt; computeExpensiveValue(a, b), [a, b]);<br>返回一个 memoized 值 。</p><p>把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。</p><p>你可以把 useMemo 作为性能优化的手段，但不要把它当成语义上的保证<br>将来，React 可能会选择“遗忘”以前的一些 memoized 值，并在下次渲染时重新计算它们，比如为离屏组件释放内存。先编写在没有 useMemo 的情况下也可以执行的代码 —— 之后再在你的代码中添加 useMemo，以达到优化性能的目的。</p><p>function Example() {<br>    const [count, setCount] &#x3D; useState(1);<br>    const [val, setValue] &#x3D; useState(‘’);</p><pre><code>const getNum = useMemo(() =&gt; &#123;    return Array.from(&#123;length: count * 100&#125;, (v, i) =&gt; i).reduce((a, b) =&gt; a+b)&#125;, [count])return &lt;div&gt;    &lt;h4&gt;总和：&#123;getNum()&#125;&lt;/h4&gt;    &lt;div&gt;        &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+1&lt;/button&gt;        &lt;input value=&#123;val&#125; onChange=&#123;event =&gt; setValue(event.target.value)&#125;/&gt;    &lt;/div&gt;&lt;/div&gt;;</code></pre><p>}</p><p>避免因为val变化而导致getNum重新渲染</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>useCallback 返回的是一个函数<br>useMemo 返回的的函数的执行结果</p><p>类似于计算属性computed，避免使用了该函数或者该值的组件重复渲染。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把事件写进render里面会在重新渲染的时候重新生成新的onclick</span></span><br><span class="line">class Demo extends Component&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> </span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;Button onClick=&#123; () =&gt; &#123; console.log(<span class="string">&#x27;Hello World！！&#x27;</span>); &#125;&#125;  /&gt;</span><br><span class="line">        &lt;/div&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 在组件中可以在constructor里面</span></span><br><span class="line">class Demo extends Component&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span></span>()&#123;</span><br><span class="line">        super();</span><br><span class="line">        this.buttonClick = this.buttonClick.<span class="built_in">bind</span>(this);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> </span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;Button onClick=&#123; this.buttonClick &#125;  /&gt;</span><br><span class="line">        &lt;/div&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 在函数式组件中开发</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Demo</span></span>()&#123;</span><br><span class="line">    const buttonClick = useCallback(() =&gt; &#123; </span><br><span class="line">    console.log(<span class="string">&#x27;Hello World！！&#x27;</span>)</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="built_in">return</span>(</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;Button onClick=&#123; buttonClick &#125;  /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存泄漏详解</title>
      <link href="/2022/04/25/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/04/25/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="JS的回收机制"><a href="#JS的回收机制" class="headerlink" title="JS的回收机制"></a>JS的回收机制</h1><p>JS垃圾回收的机制（GC）会按照固定的时间间隔，周期性的执行。<br>标记清除：<br>当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。</p><p>function test(){<br>  var a&#x3D;10;&#x2F;&#x2F;被标记，进入环境<br>  var b&#x3D;20;&#x2F;&#x2F;被标记，进入环境<br>}<br>test();&#x2F;&#x2F;执行完毕之后a、b又被标记离开环境，被回收</p><h1 id="哪些操作会造成内存泄露"><a href="#哪些操作会造成内存泄露" class="headerlink" title="哪些操作会造成内存泄露"></a>哪些操作会造成内存泄露</h1><p>意外的全局变量引起的内存泄露：<br>function leak(){<br>  leak&#x3D;”xxx”;&#x2F;&#x2F;leak成为一个全局变量，不会被回收<br>}<br>闭包引起的内存泄漏<br>function bindEvent(){<br>  var obj&#x3D;document.createElement(“XXX”);<br>  obj.οnclick&#x3D;function(){<br>    &#x2F;&#x2F;Even if it’s a empty function<br>  }<br>}<br>解决方法：</p><ul><li>将事件处理函数定义在外部，解除闭包。<br>&#x2F;&#x2F;将事件处理函数定义在外部<br>function onclickHandler(){<br>&#x2F;&#x2F;do something<br>}<br>function bindEvent(){<br>var obj&#x3D;document.createElement(“XXX”);<br>obj.οnclick&#x3D;onclickHandler;<br>}</li><li>在定义事件处理函数的外部函数中，删除对 DOM 的引用<br>function bindEvent(){<br>var obj&#x3D;document.createElement(“XXX”);<br>obj.οnclick&#x3D;function(){<br>  &#x2F;&#x2F;Even if it’s a empty function<br>}<br>obj&#x3D;null;<br>}</li><li>没有清理的 DOM 元素引用：<br>var elements&#x3D;{<br>  button: document.getElementById(“button”),<br>  image: document.getElementById(“image”),<br>  text: document.getElementById(“text”)<br>};<br>function doStuff(){<br>  image.src&#x3D;”<a href="http://some.url/image&quot;">http://some.url/image&quot;</a>;<br>  button.click():<br>  console.log(text.innerHTML)<br>}<br>function removeButton(){<br>  document.body.removeChild(document.getElementById(‘button’))<br>}</li><li>被遗忘的定时器或者回调：<br>var someResouce&#x3D;getData();<br>setInterval(function(){<br>  var node&#x3D;document.getElementById(‘Node’);<br>  if(node){<br>  node.innerHTML&#x3D;JSON.stringify(someResouce)<br>  }<br>},1000)</li></ul><h1 id="怎样避免内存泄露："><a href="#怎样避免内存泄露：" class="headerlink" title="怎样避免内存泄露："></a>怎样避免内存泄露：</h1><ul><li>减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收；</li><li>注意程序逻辑，避免“死循环”之类的；</li><li>避免创建过多的对象，原则：不用了的东西要及时归还。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>定义全局变量，闭包，dom的引用，定时器都会产生内存使用的问题。不处理会导致内存泄漏</p>]]></content>
      
      
      
        <tags>
            
            <tag> memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue Computd与watch</title>
      <link href="/2022/04/24/Vue-Computd%E4%B8%8Ewatch/"/>
      <url>/2022/04/24/Vue-Computd%E4%B8%8Ewatch/</url>
      
        <content type="html"><![CDATA[<h1 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h1><p>computed 和 watch 都是在  beforeCreate - initState(vm) - created 阶段初始化监听的</p><p>最终实现原理都是通过 new Watcher 实现 监听的</p><h1 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h1><p>watch 支持 watch[key]的值，可以是 包含handle属性的对象, 某个method 名称的字符串，以及存在new old Value 的Function</p><p>computed 必须存在return 值。所以不支持异步，如果存在异步，则返回promise</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> initState (vm: Component) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (opts.computed) initComputed(vm, opts.computed)</span><br><span class="line">  <span class="keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">    initWatch(vm, opts.watch)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Computd"><a href="#Computd" class="headerlink" title="Computd"></a>Computd</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在vue 实例化后，会判断是否存在computed</span></span><br><span class="line"><span class="comment"># 存在则 遍历computed对象，初始化各个值</span></span><br><span class="line"><span class="keyword">function</span> initComputed (vm: Component, computed: Object) &#123;</span><br><span class="line">  const watchers = vm._computedWatchers = Object.create(null)</span><br><span class="line">  const isSSR = isServerRendering()</span><br><span class="line">  <span class="keyword">for</span> (const key <span class="keyword">in</span> computed) &#123;</span><br><span class="line">    const userDef = computed[key]</span><br><span class="line">    const getter = typeof userDef === <span class="string">&#x27;function&#x27;</span> ? userDef : userDef.get</span><br><span class="line">    watchers[key] = new Watcher(</span><br><span class="line">      vm,</span><br><span class="line">      getter || noop,</span><br><span class="line">      noop,</span><br><span class="line">      computedWatcherOptions</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    // 判断是否与<span class="built_in">date</span> 数据冲突，没有则开始定义Computed</span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      defineComputed(vm, key, userDef)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> defineComputed (</span><br><span class="line">  target: any,</span><br><span class="line">  key: string,</span><br><span class="line">  userDef: Object | Function</span><br><span class="line">) &#123;</span><br><span class="line">  const shouldCache = !isServerRendering()</span><br><span class="line">  <span class="keyword">if</span> (typeof userDef === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    sharedPropertyDefinition.get = shouldCache</span><br><span class="line">      ? createComputedGetter(key)</span><br><span class="line">      : createGetterInvoker(userDef)</span><br><span class="line">    sharedPropertyDefinition.<span class="built_in">set</span> = noop</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sharedPropertyDefinition.get = userDef.get</span><br><span class="line">      ? shouldCache &amp;&amp; userDef.cache !== <span class="literal">false</span></span><br><span class="line">        ? createComputedGetter(key)</span><br><span class="line">        : createGetterInvoker(userDef.get)</span><br><span class="line">      : noop</span><br><span class="line">    sharedPropertyDefinition.<span class="built_in">set</span> = userDef.<span class="built_in">set</span> || noop</span><br><span class="line">  &#125;</span><br><span class="line">  Object.defineProperty(target, key, sharedPropertyDefinition)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 在初始化的时候，获取defineComputed创建的watch，去执行一次 计算 evaluate </span></span><br><span class="line"><span class="comment"># 也就是对应key的方法。存在watcher.value中，return出去</span></span><br><span class="line"><span class="keyword">function</span> createComputedGetter (key) &#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="keyword">function</span> <span class="function"><span class="title">computedGetter</span></span> () &#123;</span><br><span class="line">    const watcher = this._computedWatchers &amp;&amp; this._computedWatchers[key]</span><br><span class="line">    <span class="keyword">if</span> (watcher) &#123;</span><br><span class="line">      <span class="keyword">if</span> (watcher.dirty) &#123;</span><br><span class="line">        watcher.evaluate()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        watcher.depend()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">return</span> watcher.value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算属性的结果会被缓存，除非依赖的响应式 property 变化才会重新计算。注意，如果某个依赖 (比如非响应式 property) 在该实例范畴之外，则计算属性是不会被更新的。<br>computed 就是一个带了缓存的执行函数，只有依赖的数据发生的变化才会重新求值</p><p>当计算属性依赖的响应式属性发生修改会做两件事<br>是将计算属性的watcher 中的dirty属性更新为true ，表示要重新求值<br>是将渲染函数的watcher 加入任务队列。当渲染函数重新执行的时候就会触发计算属性的getter 并重新计算，这样就达到的缓存计算结果的目的。</p><h1 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和Computed 一样初始化时，遍历 watch ，去挨个createWatcher</span></span><br><span class="line"><span class="keyword">function</span> initWatch(vm: Component, watch: Object) &#123;</span><br><span class="line">  <span class="keyword">for</span> (const key <span class="keyword">in</span> watch) &#123;</span><br><span class="line">    const handler = watch[key]</span><br><span class="line">    <span class="keyword">if</span> (Array.isArray(handler)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; handler.length; i++) &#123;</span><br><span class="line">        createWatcher(vm, key, handler[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      createWatcher(vm, key, handler)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> createWatcher(</span><br><span class="line">  vm: Component,</span><br><span class="line">  expOrFn: string | Function,</span><br><span class="line">  handler: any,</span><br><span class="line">  options?: Object</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">if</span> (isPlainObject(handler)) &#123;</span><br><span class="line">    options = handler</span><br><span class="line">    handler = handler.handler</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (typeof handler === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    handler = vm[handler]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> vm.<span class="variable">$watch</span>(expOrFn, handler, options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用$watch()，遍历 watch 对象的每一个 property。<br>watch 更像是一个观察者，只要监测到数据变动就会重新执行回调<br>首先Vue 会根据用户传入的参数类型做格式处理，按处理后的参数调用 $<br>watch 生成观察器</p><h1 id="watcher-的构造"><a href="#watcher-的构造" class="headerlink" title="watcher 的构造"></a>watcher 的构造</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> default class Watcher &#123;</span><br><span class="line">  vm: Component;</span><br><span class="line">  expression: string;</span><br><span class="line">  cb: Function;</span><br><span class="line">  <span class="built_in">id</span>: number;</span><br><span class="line">  deep: boolean;</span><br><span class="line">  user: boolean;</span><br><span class="line">  lazy: boolean;</span><br><span class="line">  <span class="built_in">sync</span>: boolean;</span><br><span class="line">  dirty: boolean;</span><br><span class="line">  active: boolean;</span><br><span class="line">  deps: Array&lt;Dep&gt;;</span><br><span class="line">  newDeps: Array&lt;Dep&gt;;</span><br><span class="line">  depIds: SimpleSet;</span><br><span class="line">  newDepIds: SimpleSet;</span><br><span class="line">  before: ?Function;</span><br><span class="line">  getter: Function;</span><br><span class="line">  value: any;</span><br><span class="line"></span><br><span class="line">  constructor(</span><br><span class="line">    vm: Component,</span><br><span class="line">    expOrFn: string | Function,</span><br><span class="line">    cb: Function,</span><br><span class="line">    options?: ?Object,</span><br><span class="line">    isRenderWatcher?: boolean</span><br><span class="line">  ) &#123;</span><br><span class="line">    this.vm = vm</span><br><span class="line">    <span class="keyword">if</span> (isRenderWatcher) &#123;</span><br><span class="line">      vm._watcher = this</span><br><span class="line">    &#125;</span><br><span class="line">    vm._watchers.push(this)</span><br><span class="line">    // options</span><br><span class="line">    <span class="keyword">if</span> (options) &#123;</span><br><span class="line">      this.deep = !!options.deep</span><br><span class="line">      this.user = !!options.user</span><br><span class="line">      this.lazy = !!options.lazy</span><br><span class="line">      this.sync = !!options.sync</span><br><span class="line">      this.before = options.before</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      this.deep = this.user = this.lazy = this.sync = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    this.cb = cb</span><br><span class="line">    this.id = ++uid // uid <span class="keyword">for</span> batching</span><br><span class="line">    this.active = <span class="literal">true</span></span><br><span class="line">    this.dirty = this.lazy // <span class="keyword">for</span> lazy watchers</span><br><span class="line">    this.deps = []</span><br><span class="line">    this.newDeps = []</span><br><span class="line">    this.depIds = new Set()</span><br><span class="line">    this.newDepIds = new Set()</span><br><span class="line">    this.expression = process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span></span><br><span class="line">      ? expOrFn.toString()</span><br><span class="line">      : <span class="string">&#x27;&#x27;</span></span><br><span class="line">    // parse expression <span class="keyword">for</span> getter</span><br><span class="line">    <span class="keyword">if</span> (typeof expOrFn === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      this.getter = expOrFn</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      this.getter = parsePath(expOrFn)</span><br><span class="line">      <span class="keyword">if</span> (!this.getter) &#123;</span><br><span class="line">        this.getter = noop</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    this.value = this.lazy</span><br><span class="line">      ? undefined</span><br><span class="line">      : this.get()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">get</span></span>() &#123;</span><br><span class="line">    pushTarget(this)</span><br><span class="line">    <span class="built_in">let</span> value</span><br><span class="line">    const vm = this.vm</span><br><span class="line">    value = this.getter.call(vm, vm)</span><br><span class="line">    <span class="keyword">if</span> (this.deep) &#123;</span><br><span class="line">      traverse(value)</span><br><span class="line">    &#125;</span><br><span class="line">    popTarget()</span><br><span class="line">    this.cleanupDeps()</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">update</span></span>() &#123;</span><br><span class="line">    /* istanbul ignore <span class="keyword">else</span> */</span><br><span class="line">    console.log(<span class="string">&#x27;watch update &#x27;</span> + this.id)</span><br><span class="line">    <span class="keyword">if</span> (this.lazy) &#123;</span><br><span class="line">      this.dirty = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (this.sync) &#123;</span><br><span class="line">      this.run()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      queueWatcher(this)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (this.active) &#123;</span><br><span class="line">      const value = this.get()</span><br><span class="line">      <span class="keyword">if</span> (value !== this.value || isObject(value) || this.deep) &#123;</span><br><span class="line">        // <span class="built_in">set</span> new value</span><br><span class="line">        const oldValue = this.value</span><br><span class="line">        this.value = value</span><br><span class="line">        this.cb.call(this.vm, value, oldValue)</span><br><span class="line">        </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">evaluate</span></span>() &#123;</span><br><span class="line">    this.value = this.get()</span><br><span class="line">    this.dirty = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Depend on all deps collected by this watcher.</span><br><span class="line">   */</span><br><span class="line">  <span class="function"><span class="title">depend</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> i = this.deps.length</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      this.deps[i].depend()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Remove self from all dependencies<span class="string">&#x27; subscriber list.</span></span><br><span class="line"><span class="string">   */</span></span><br><span class="line"><span class="string">  teardown() &#123;</span></span><br><span class="line"><span class="string">    # ...移除监听</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="Vue-初始化的时候"><a href="#Vue-初始化的时候" class="headerlink" title="Vue 初始化的时候"></a>Vue 初始化的时候</h1><p>vue 在init 阶段会根据传入的options 进行初始化，如果传入的options 中包含有computed , 会执行initComputed<br>vue 会为每个computed 属性生成一个watcher 实例，并将其中的lazy 属性设置为true (这个状态是用来标识 watcher 做惰性求值， 配合watcher 实例中的dirty 属性来实现)。并调用 createComputedGetter 重写计算属性的getter</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> createComputedGetter (key) &#123;</span><br><span class="line">  // 重写计算属性的 getter, </span><br><span class="line">  <span class="built_in">return</span> <span class="keyword">function</span> <span class="function"><span class="title">computedGetter</span></span> () &#123;</span><br><span class="line">    const watcher = this._computedWatchers &amp;&amp; this._computedWatchers[key]</span><br><span class="line">    <span class="keyword">if</span> (watcher) &#123;</span><br><span class="line">      // 初始化的时候会根据 lazy 来初始化dirty属性； </span><br><span class="line">      // 只有当依赖的响应属性变化，才会重新将计算属性的watcher.dirty 更新为 <span class="literal">true</span></span><br><span class="line">      // 表示在下次重新渲染的时候要重新求值。</span><br><span class="line">      <span class="keyword">if</span> (watcher.dirty) &#123;</span><br><span class="line">        watcher.evaluate()</span><br><span class="line">      &#125;</span><br><span class="line">      // 当前watcher 中收集了依赖的响应属性的dep</span><br><span class="line">      // 在这个阶段把计算属性依赖的渲染函数的watcher 收集到相同的dep中。</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        watcher.depend()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">return</span> watcher.value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// watcher 内定义的方法。  </span><br><span class="line"><span class="function"><span class="title">update</span></span> () &#123;</span><br><span class="line">    /* istanbul ignore <span class="keyword">else</span> */</span><br><span class="line">    // 计算属性</span><br><span class="line">    <span class="keyword">if</span> (this.lazy) &#123;</span><br><span class="line">      this.dirty = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (this.sync) &#123;</span><br><span class="line">      this.run()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      // 其他异步 watcher 加入任务队列等待执行</span><br><span class="line">      queueWatcher(this)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>重写后的 getter 做了两件事:</p><ul><li>是判断watcher 的dirty 属性，如果为true表示要重新执行watcher 实例的get 函数（重新求值的函数）</li><li>将计算属性依赖的渲染函数的 watcher 收集到自己依赖的响应属性的Dep 实例中。经过这样的一个初始化后在响应式数据的 dep 中将收集了两个watcher 一个是计算属性的 watcher , 另一个是计算属性关联的渲染函数的watcher</li></ul><p>当计算属性关联的渲染函数的watcher收到来自更新的通知后，就会执行其 update 方法，要求重新求值。判断计算后的值是否相等，不等就通知计算属性的 watcher更新</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>computed 、watch 的底层都是通过生成一个Watcher 对响应数据进行观察，并在需要的时候重新执行求值，他们的不同点主要在于：</p><ul><li>计算属性的依赖收集并能实现在依赖的数据变化的时候能触发视图的更新，也就要求这个属性必须在组件的 render 函数中有引用到，这样他才能收集渲染函数的watcher 。当在依赖的数据变化后进行重新求值并通知渲染函数重新渲染。</li><li>虽然watch 要求监听的也是响应式数据，但用户对监听的数据做了修改，用户定义的回调就会被执行。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redux-saga 详解</title>
      <link href="/2022/04/24/Redux-saga-%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/04/24/Redux-saga-%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="在与redux-toolkit-一起使用的-基础配置"><a href="#在与redux-toolkit-一起使用的-基础配置" class="headerlink" title="在与redux-toolkit 一起使用的 基础配置"></a>在与redux-toolkit 一起使用的 基础配置</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建一个saga.js</span></span><br><span class="line">import &#123; call, put, takeEvery &#125; from <span class="string">&#x27;redux-saga/effects&#x27;</span></span><br><span class="line">import axios from <span class="string">&#x27;axios&#x27;</span></span><br><span class="line">const testApi = <span class="string">&#x27;/public/page/getHomePageModules&#x27;</span></span><br><span class="line"></span><br><span class="line">// worker Saga : 将在 USER_FETCH_REQUESTED action 被 dispatch 时调用</span><br><span class="line"><span class="keyword">function</span>* fetchUser(action)&#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    const user = yield call(axios.get(testApi),action.payload.userId)</span><br><span class="line">    console.log(user)</span><br><span class="line">    yield put (&#123;<span class="built_in">type</span>:<span class="string">&quot;USER_FETCH_SUCCEEDED&quot;</span>,user:user&#125;)</span><br><span class="line">  &#125; catch (e)&#123;</span><br><span class="line">    yield put(&#123;<span class="built_in">type</span>: <span class="string">&quot;USER_FETCH_FAILED&quot;</span>,message:e.message&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">  在每个 `USER_FETCH_REQUESTED` action 被 dispatch 时调用 fetchUser</span><br><span class="line">  允许并发（译注：即同时处理多个相同的 action）</span><br><span class="line">*/</span><br><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">mySaga</span></span>()&#123;</span><br><span class="line">  yield takeEvery(<span class="string">&quot;USER_FETCH_REQUESTED&quot;</span>,fetchUser)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">  也可以使用 takeLatest</span><br><span class="line"></span><br><span class="line">  不允许并发，dispatch 一个 `USER_FETCH_REQUESTED` action 时，</span><br><span class="line">  如果在这之前已经有一个 `USER_FETCH_REQUESTED` action 在处理中，</span><br><span class="line">  那么处理中的 action 会被取消，只会执行当前的</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default mySaga;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 集中到store里面的写法</span></span><br><span class="line">import counterSlice from <span class="string">&quot;./test&quot;</span></span><br><span class="line">import &#123; configureStore &#125; from <span class="string">&#x27;@reduxjs/toolkit&#x27;</span></span><br><span class="line">import thunksSlice from <span class="string">&quot;./thunks&quot;</span></span><br><span class="line">import createSagaMiddleware from <span class="string">&#x27;redux-saga&#x27;</span></span><br><span class="line">import mySaga from <span class="string">&#x27;./saga&#x27;</span></span><br><span class="line"></span><br><span class="line">// create the saga middleware</span><br><span class="line">const sagaMiddleware = createSagaMiddleware()</span><br><span class="line">const store = configureStore(&#123;</span><br><span class="line">  reducer:&#123;</span><br><span class="line">    counter: counterSlice,</span><br><span class="line">    thunks: thunksSlice,</span><br><span class="line">    </span><br><span class="line">  &#125;,</span><br><span class="line">  middleware: defaultMiddleware =&gt; defaultMiddleware().concat(sagaMiddleware)</span><br><span class="line"> </span><br><span class="line">&#125;)</span><br><span class="line">sagaMiddleware.run(mySaga)</span><br><span class="line"><span class="built_in">export</span> default store</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用与其他的一致，通过dispatch</span></span><br><span class="line">import HightClock from <span class="string">&#x27;../hightComponents/clock&#x27;</span></span><br><span class="line">import &#123; useSelector,useDispatch &#125; from <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line">import &#123; useEffect &#125; from <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default HightClock((props)=&gt;&#123;</span><br><span class="line">  const count = useSelector(state=&gt;state.counter.value)</span><br><span class="line">  const dispatch = useDispatch()</span><br><span class="line">  useEffect(()=&gt;&#123;</span><br><span class="line">    dispatch(&#123;<span class="built_in">type</span>: <span class="string">&#x27;USER_FETCH_REQUESTED&#x27;</span>, payload: &#123;&#125;&#125;)</span><br><span class="line">  &#125;,[])</span><br><span class="line">  // </span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;Home Child1&lt;/h1&gt;</span><br><span class="line">      &lt;h2&gt;counterValue: &#123;count&#125;&lt;/h2&gt;</span><br><span class="line">      &lt;div&gt;&#123;props.date&#125;&lt;/div&gt;</span><br><span class="line">      &#123;/* &lt;Link to=<span class="string">&quot;/about&quot;</span>&gt;To About Clock&lt;/Link&gt; */&#125;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">)&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redux-saga </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>people X后台管理项目介绍</title>
      <link href="/2022/04/22/people-X%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/"/>
      <url>/2022/04/22/people-X%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="依赖包版本"><a href="#依赖包版本" class="headerlink" title="依赖包版本"></a>依赖包版本</h1><p>“antd”: “3.26.16”<br>“dva”: “^2.4.0”<br>“react-router-dom”: “^4.3.1”,</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>英文版自我介绍</title>
      <link href="/2022/04/21/%E8%8B%B1%E6%96%87%E7%89%88%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/"/>
      <url>/2022/04/21/%E8%8B%B1%E6%96%87%E7%89%88%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><p>  Hello!<br>  My name is Zhang YeChang. twenty-six years old.<br>  I’m very glad to join in the interview.<br>  First, I come from GuangDong ZhangJiang. Graduated from Panyu University of Technology. majoring in marketing<br>  I have about four point five years of front-end development experience.<br>  I’m mainly good at Vue React and Uni-app.<br>  Lead the construction of too many large projects.<br>  Like: people X,PinPin Bear Shop<br>  I like to communicate with others, discuss problems and share new learning technologies.<br>  In my free time.I will Continue to focus on front-end technology updates, like: mobx six version, Redux Toolkit.<br>  now, End of introduction.<br>  thank you very much.</p><h1 id="最近的项目-people-X"><a href="#最近的项目-people-X" class="headerlink" title="最近的项目 people X"></a>最近的项目 people X</h1><p>  Recently, In my led projects is people-x.<br>  People-x is P &amp; G’s enterprise wechat multi tenant  platform.<br>  The old version is based on PHP + angular1 Developed by X.</p><p>  Why should we refactor it.</p><p>  The response of the old system is too slow, the experience is very poor, and the request link is too long, resulting in easy disconnection. The most important thing is that one set of code for one tenant is inconvenient for future maintenance.<br>  The new system architecture scheme is as follows</p><p>● front end: enterprise wechat is based on Vue + vant . The background management system is based on react + ant-design-pro</p><p>● back end: Based on spring boot </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>React-Router 主要功能详解</title>
      <link href="/2022/04/19/React-Router-%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/04/19/React-Router-%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><code> $ npm install react-router-dom@6</code></p><h1 id="使用-（使用组件注册路由）"><a href="#使用-（使用组件注册路由）" class="headerlink" title="使用 （使用组件注册路由）"></a>使用 （使用组件注册路由）</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import React from <span class="string">&quot;react&quot;</span>;</span><br><span class="line">import &#123; Routes, Route, Link,BrowserRouter &#125; from <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line">import ReactDOM from <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">App</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    &lt;div &gt;</span><br><span class="line">      &lt;h1&gt;Welcome to React Router!&lt;/h1&gt;</span><br><span class="line">      &lt;Routes&gt;</span><br><span class="line">        &lt;Route path=<span class="string">&quot;/&quot;</span> element=&#123;&lt;Home /&gt;&#125; /&gt;</span><br><span class="line">        &lt;Route path=<span class="string">&quot;about&quot;</span> element=&#123;&lt;About /&gt;&#125; /&gt;</span><br><span class="line">      &lt;/Routes&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Home</span></span>()&#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      Home</span><br><span class="line">      &lt;Link to=<span class="string">&quot;/about&quot;</span>&gt;About&lt;/Link&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">About</span></span>()&#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    &lt;div&gt;About&lt;Link to=<span class="string">&quot;/&quot;</span>&gt;About&lt;/Link&gt;&lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;BrowserRouter&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;/BrowserRouter&gt;,</span><br><span class="line">  document.getElementById(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="使用useRoutes注册路由"><a href="#使用useRoutes注册路由" class="headerlink" title="使用useRoutes注册路由"></a>使用useRoutes注册路由</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//路由表配置：src/routes/index.js</span><br><span class="line">import About from <span class="string">&#x27;../pages/About&#x27;</span></span><br><span class="line">import Home from <span class="string">&#x27;../pages/Home&#x27;</span></span><br><span class="line">import &#123;Navigate&#125; from <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default [</span><br><span class="line">&#123;</span><br><span class="line">path:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">element:&lt;About/&gt;,</span><br><span class="line">    children: [&#123;</span><br><span class="line">      path:<span class="string">&#x27;aboutChild1&#x27;</span>,</span><br><span class="line">  element:&lt;AboutChild1 /&gt;,</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      path:<span class="string">&#x27;aboutChild2&#x27;</span>,</span><br><span class="line">  element:&lt;AboutChild2 /&gt;,</span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">path:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">element:&lt;Home/&gt;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">path:<span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">element:&lt;Navigate to=<span class="string">&quot;/about&quot;</span>/&gt;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">//App.jsx</span><br><span class="line">import React from <span class="string">&#x27;react&#x27;</span></span><br><span class="line">import &#123;NavLink,useRoutes&#125; from <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line">import routes from <span class="string">&#x27;./routes&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default <span class="keyword">function</span> <span class="function"><span class="title">App</span></span>() &#123;</span><br><span class="line">//根据路由表生成对应的路由规则</span><br><span class="line">const element = useRoutes(routes)</span><br><span class="line"><span class="built_in">return</span> (</span><br><span class="line">&lt;div&gt;</span><br><span class="line">......</span><br><span class="line">      &#123;/* 注册路由 */&#125;</span><br><span class="line">      &#123;element&#125;</span><br><span class="line">  ......</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="子路由渲染位置"><a href="#子路由渲染位置" class="headerlink" title=" 子路由渲染位置"></a><Outlet> 子路由渲染位置</h1><h1 id="useNavigate-返回一个函数用来实现编程式导航。"><a href="#useNavigate-返回一个函数用来实现编程式导航。" class="headerlink" title="useNavigate 返回一个函数用来实现编程式导航。"></a>useNavigate 返回一个函数用来实现编程式导航。</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import &#123;useNavigate&#125; from <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line">import React from <span class="string">&#x27;react&#x27;</span></span><br><span class="line">import &#123;useNavigate&#125; from <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default <span class="keyword">function</span> <span class="function"><span class="title">Demo</span></span>() &#123;</span><br><span class="line">  const navigate = useNavigate()</span><br><span class="line">  const handle = () =&gt; &#123;</span><br><span class="line">    //第一种使用方式：指定具体的路径</span><br><span class="line">    navigate(<span class="string">&#x27;/login&#x27;</span>, &#123;</span><br><span class="line">      replace: <span class="literal">false</span>,</span><br><span class="line">      state: &#123;a:1, b:2&#125;</span><br><span class="line">    &#125;) </span><br><span class="line">    //第二种使用方式：传入数值进行前进或后退，类似于5.x中的 history.go()方法</span><br><span class="line">    navigate(-1)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;handle&#125;&gt;按钮&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="useParams-返回当前匹配路由的params参数-useSearchParams-用于读取和修改当前位置的-URL-中的查询字符串。-useLocation-获取当前-location-信息"><a href="#useParams-返回当前匹配路由的params参数-useSearchParams-用于读取和修改当前位置的-URL-中的查询字符串。-useLocation-获取当前-location-信息" class="headerlink" title="useParams 返回当前匹配路由的params参数 | useSearchParams 用于读取和修改当前位置的 URL 中的查询字符串。 | useLocation 获取当前 location 信息"></a>useParams 返回当前匹配路由的params参数 | useSearchParams 用于读取和修改当前位置的 URL 中的查询字符串。 | useLocation 获取当前 location 信息</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># useParams</span></span><br><span class="line">import &#123; Routes, Route, useParams,useSearchParams,useLocation &#125; from <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">ProfilePage</span></span>() &#123;</span><br><span class="line">  // 获取URL中携带过来的params参数</span><br><span class="line">  <span class="built_in">let</span> &#123; <span class="built_in">id</span> &#125; = useParams();</span><br><span class="line">  // 返回一个包含两个值的数组，内容分别为：当前的seaech参数、更新search的函数。</span><br><span class="line">  const [search,setSearch] = useSearchParams()</span><br><span class="line">  // update</span><br><span class="line">  const <span class="built_in">id</span> = search.get(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">  setSearch(<span class="string">&#x27;id=12123123&#x27;</span>) </span><br><span class="line">  // 获取当前 location 信息</span><br><span class="line">  const x = useLocation()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">App</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    &lt;Routes&gt;</span><br><span class="line">      &lt;Route path=<span class="string">&quot;users/:id&quot;</span> element=&#123;&lt;User /&gt;&#125;/&gt;</span><br><span class="line">    &lt;/Routes&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="路由钩子-routerWillLeave"><a href="#路由钩子-routerWillLeave" class="headerlink" title="路由钩子 routerWillLeave"></a>路由钩子 routerWillLeave</h1><p>可以拦截正在发生的跳转，或在离开 route 前提示用户。<br>routerWillLeave 返回值有以下两种：</p><ul><li>return false 取消此次跳转</li><li>return 返回提示信息，在离开 route 前提示用户进行确认。</li></ul>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React Router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 组件生命周期</title>
      <link href="/2022/04/17/React-%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2022/04/17/React-%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="常用单个组件的生命周期"><a href="#常用单个组件的生命周期" class="headerlink" title="常用单个组件的生命周期"></a>常用单个组件的生命周期</h1><ol><li>初始化的生命周期</li></ol><ul><li>constructor</li><li>static getDerivedStateFromProps</li><li>render</li><li>componentDidMount</li></ul><ol start="2"><li>更新的生命周期</li></ol><ul><li>static getDerivedStateFromProps</li><li>shouldComponentUpdate</li><li>render</li><li>getSnapshotBeforeUpdate</li><li>componentDidUpdate</li></ul><ol start="3"><li>错误的生命周期</li></ol><ul><li>static getDerivedStateFromError</li><li>componentDidCatch</li></ul><h1 id="只执行一次"><a href="#只执行一次" class="headerlink" title="只执行一次"></a>只执行一次</h1><ul><li>constructor</li><li>componentWillMount</li><li>componentDidMount</li></ul><h1 id="执行多次"><a href="#执行多次" class="headerlink" title="执行多次"></a>执行多次</h1><ul><li>render</li><li>子组件-componentWillReceiveProps</li><li>componentWillUpdate</li><li>componentDidUpdate</li></ul><h1 id="执行顺序，类似事件捕获-事件冒泡"><a href="#执行顺序，类似事件捕获-事件冒泡" class="headerlink" title="执行顺序，类似事件捕获+事件冒泡"></a>执行顺序，类似事件捕获+事件冒泡</h1><p>App： constructor –&gt; componentWillMount –&gt; render –&gt;<br>parent: constructor –&gt; componentWillMount –&gt; render –&gt;<br>child: constructor –&gt; componentWillMount –&gt; render –&gt;<br>componentDidMount (child) –&gt; componentDidMount (parent) –&gt; componentDidMount (App)</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React 生命周期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊一聊装饰器模式</title>
      <link href="/2022/04/16/%E8%81%8A%E4%B8%80%E8%81%8A%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/04/16/%E8%81%8A%E4%B8%80%E8%81%8A%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>splice方法在react Hock中无法改变state数据</title>
      <link href="/2022/01/07/splice%E6%96%B9%E6%B3%95%E5%9C%A8react-Hock%E4%B8%AD%E6%97%A0%E6%B3%95%E6%94%B9%E5%8F%98state%E6%95%B0%E6%8D%AE/"/>
      <url>/2022/01/07/splice%E6%96%B9%E6%B3%95%E5%9C%A8react-Hock%E4%B8%AD%E6%97%A0%E6%B3%95%E6%94%B9%E5%8F%98state%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fun</span></span>()&#123;</span><br><span class="line">  const [arr,setArr] = useState([1,2])</span><br><span class="line">  arr.splice(1,3)</span><br><span class="line">  setArr(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这时候发现是没有效果的。<br>因为splice是修改原数组，并返回被切掉的元素。<br>而arr保存的是引用地址<br>所以要先copy一份arr再操作<br>const copyArr &#x3D; arr.slice()  ||  const copyArr &#x3D; […arr]</p><h1 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fun</span></span>()&#123;</span><br><span class="line">  const [arr,setArr] = useState([1,2])</span><br><span class="line">  const copyArr = arr.slice() </span><br><span class="line">  copyArr.splice(1,3)</span><br><span class="line">  setArr(copyArr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React组件通讯</title>
      <link href="/2021/09/22/React%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF/"/>
      <url>/2021/09/22/React%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="父子组件通讯"><a href="#父子组件通讯" class="headerlink" title="父子组件通讯"></a>父子组件通讯</h1><p>通过props，父组件向子组件传递值或者方法，子组件向父组件通讯，子组件可以调用父组件通过props传递的方法</p><h1 id="全局context"><a href="#全局context" class="headerlink" title="全局context"></a>全局context</h1><ol><li>通过createContext创建一个上下文 const Context &#x3D; React.createContext({color: red})</li><li>通过 当前节点的state复制一份Context的值</li><li>当前节点用&lt;Context.Provider value&#x3D;{this.state}&gt;包裹</li><li>在该节点下的某个组件使用，可以通过 &lt;Context.Consumer&gt;{(value)&#x3D;&gt;{}}&lt;&#x2F;Context.Consumer&gt; 组件下接收传递的value<br> 也可以给类组件 MyClass.contextType &#x3D; MyContext;直接赋值，在组件内部通过this.context访问</li></ol><h1 id="想要在子组件修改该context的值，需要将修改的方法一并传入进去"><a href="#想要在子组件修改该context的值，需要将修改的方法一并传入进去" class="headerlink" title="想要在子组件修改该context的值，需要将修改的方法一并传入进去"></a>想要在子组件修改该context的值，需要将修改的方法一并传入进去</h1><p>在复制context的值给节点的state的时候，需要额外定义一个修改该值的方法<br>this.handleFontSize &#x3D; () &#x3D;&gt; {<br>  this.setState(state &#x3D;&gt; ({<br>    fontSize: state.fontSize &#x3D;&#x3D;&#x3D; fontSize.small<br>        ? fontSize.big<br>        : fontSize.small,<br>  }));<br>}<br>&#x2F;&#x2F; State 也包含了更新函数，因此它会被传递进 context provider。<br>this.state &#x3D; {<br>  fontSize: fontSize.small,<br>  handleFontSize: this.handleFontSize,<br>};</p><p>在子组件通过 this.context.handleFontSize()去修改即可</p><h1 id="全局通讯之-redux-toolkit"><a href="#全局通讯之-redux-toolkit" class="headerlink" title="全局通讯之 redux toolkit"></a>全局通讯之 redux toolkit</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 先创建一个 Slice 通过 createSlice</span></span><br><span class="line">import &#123; createSlice,createAsyncThunk &#125; from <span class="string">&#x27;@reduxjs/toolkit&#x27;</span></span><br><span class="line">import axios from <span class="string">&#x27;axios&#x27;</span></span><br><span class="line">const testApi = <span class="string">&#x27;/public/page/getHomePageModules&#x27;</span></span><br><span class="line"><span class="built_in">export</span> const fetchThunks = createAsyncThunk(<span class="string">&#x27;thunks/fetchThunks&#x27;</span>, async () =&gt; &#123;</span><br><span class="line">  const response = await axios.get(testApi,&#123;&#125;)</span><br><span class="line">  <span class="built_in">return</span> response.data</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const counterSlice = createSlice(&#123;</span><br><span class="line">  name: <span class="string">&#x27;counter&#x27;</span>,</span><br><span class="line">  initialState: &#123;</span><br><span class="line">    value: 0,</span><br><span class="line">    state: <span class="string">&#x27;idle&#x27;</span>,</span><br><span class="line">    error: null</span><br><span class="line">  &#125;,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    incremented: state =&gt; &#123;</span><br><span class="line">      state.value += 1</span><br><span class="line">    &#125;,</span><br><span class="line">    decremented: state =&gt; &#123;</span><br><span class="line">      state.value -= 1</span><br><span class="line">    &#125;,</span><br><span class="line">    incrementByAmount: (state,action) =&gt; &#123;</span><br><span class="line">      state.value += action.payload</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  extraReducers(builder)&#123;</span><br><span class="line">    builder.addCase(fetchThunks.fulfilled,(state,action)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">export</span> const &#123; incremented,incrementByAmount, decremented &#125; = counterSlice.actions</span><br><span class="line"><span class="built_in">export</span> const asyncFun = (args)=&gt;&#123;</span><br><span class="line">  <span class="built_in">return</span> async (dispatch,getState)=&gt;&#123;</span><br><span class="line">    const data = await axios.get(testApi,&#123;&#125;)</span><br><span class="line">    const stateBefore = getState()</span><br><span class="line">    console.log(`Counter before: <span class="variable">$&#123;stateBefore.counter.value&#125;</span>`)</span><br><span class="line">    dispatch(incrementByAmount(args))</span><br><span class="line">    const stateAfter = getState()</span><br><span class="line">    console.log(`Counter after: <span class="variable">$&#123;stateAfter.counter.value&#125;</span>`)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default counterSlice.reducer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># redux 是不支持异步操作，所以需要支持异步的中间件来完成，如Thunk</span></span><br><span class="line"><span class="comment"># createAsyncThunk(&#x27;type名称&#x27;,asyncFn) 对应dispath(&#123;type:&#x27;actionname&#x27;,payload:&#x27;&#x27;&#125;)</span></span><br><span class="line"><span class="comment"># asyncFn的返回值就是payload</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建完后就关联到store集合里面，通过 configureStore</span></span><br><span class="line">import counterSlice from <span class="string">&quot;./test&quot;</span></span><br><span class="line">import &#123; configureStore &#125; from <span class="string">&#x27;@reduxjs/toolkit&#x27;</span></span><br><span class="line">import thunksSlice from <span class="string">&quot;./thunks&quot;</span></span><br><span class="line">const store = configureStore(&#123;</span><br><span class="line">  reducer:&#123;</span><br><span class="line">    counter: counterSlice,</span><br><span class="line">    thunks: thunksSlice</span><br><span class="line">  &#125; </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default store</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组件通讯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React开发使用总结</title>
      <link href="/2021/08/22/React%E5%BC%80%E5%8F%91%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2021/08/22/React%E5%BC%80%E5%8F%91%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="首先在根index全局引入redux，router-css等"><a href="#首先在根index全局引入redux，router-css等" class="headerlink" title="首先在根index全局引入redux，router,css等"></a>首先在根index全局引入redux，router,css等</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import React from <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line">import ReactDOM from <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line">import <span class="string">&#x27;./index.css&#x27;</span>;</span><br><span class="line">import <span class="string">&#x27;antd/dist/antd.css&#x27;</span>;</span><br><span class="line">import &#123; BrowserRouter,useRoutes &#125; from <span class="string">&quot;react-router-dom&quot;</span></span><br><span class="line">import store from <span class="string">&#x27;./reduces/index&#x27;</span></span><br><span class="line">import &#123; Provider &#125; from <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line">import routes from <span class="string">&#x27;./routes/index&#x27;</span></span><br><span class="line">const element = useRoutes(routes)</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;BrowserRouter&gt;</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">      &#123;element&#125;</span><br><span class="line">    &lt;/Provider&gt;</span><br><span class="line">  &lt;/BrowserRouter&gt;</span><br><span class="line">  ,</span><br><span class="line">  document.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>React-Toolkit 异步和数据获取的方法</title>
      <link href="/2021/07/21/React-Toolkit-%E5%BC%82%E6%AD%A5%E5%92%8C%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2021/07/21/React-Toolkit-%E5%BC%82%E6%AD%A5%E5%92%8C%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Thunks-中间件"><a href="#Thunks-中间件" class="headerlink" title="Thunks 中间件"></a>Thunks 中间件</h1><p>Thunks 内部可能有异步逻辑，例如setTimeout、Promises 和async&#x2F;await. 这使它们成为将 AJAX 调用放入服务器 API 的好地方。<br>Redux 的数据获取逻辑通常遵循可预测的模式：</p><ul><li>在请求之前调度“开始”操作，以指示请求正在进行中。这可用于跟踪加载状态以允许跳过重复请求或在 UI 中显示加载指示符。</li><li>发出异步请求</li><li>根据请求结果，异步逻辑分派包含结果数据的“成功”操作或包含错误详细信息的“失败”操作。在这两种情况下，reducer 逻辑都会清除加载状态，或者处理来自成功案例的结果数据，或者存储错误值以供潜在显示。</li></ul><p>这些步骤不是必需的，但很常用。（如果您只关心一个成功的结果，您可以在请求完成时分派一个“成功”操作，并跳过“开始”和“失败”操作。）</p><p>Redux Toolkit 提供了一个createAsyncThunk API 来实现这些操作的创建和分派</p><h1 id="请求的加载状态"><a href="#请求的加载状态" class="headerlink" title="请求的加载状态"></a>请求的加载状态</h1><ul><li>请求尚未开始</li><li>请求正在进行中</li><li>请求成功，我们现在有了我们需要的数据</li><li>请求失败，可能有错误消息<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">  // Multiple possible status enum values</span><br><span class="line">  status: <span class="string">&#x27;idle&#x27;</span> | <span class="string">&#x27;loading&#x27;</span> | <span class="string">&#x27;succeeded&#x27;</span> | <span class="string">&#x27;failed&#x27;</span>,</span><br><span class="line">  error: string | null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createSlice,createAsyncThunk &#125; from <span class="string">&#x27;@reduxjs/toolkit&#x27;</span></span><br><span class="line">import axios from <span class="string">&#x27;axios&#x27;</span></span><br><span class="line">const testApi = <span class="string">&#x27;/public/page/getHomePageModules&#x27;</span></span><br><span class="line"><span class="comment"># 通过createAsyncThunk，创建一个异步的thunk</span></span><br><span class="line"><span class="built_in">export</span> const fetchThunks = createAsyncThunk(<span class="string">&#x27;thunks/fetchThunks&#x27;</span>, async () =&gt; &#123;</span><br><span class="line">  const response = await axios.get(testApi,&#123;&#125;)</span><br><span class="line">  <span class="built_in">return</span> response.data</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment"># 创建一个thubksSlice，里面包含initialState，reducers，extraReducers</span></span><br><span class="line">const thunksSlice = createSlice(&#123;</span><br><span class="line">  name: <span class="string">&#x27;thunks&#x27;</span>,</span><br><span class="line">  initialState: &#123;</span><br><span class="line">    posts: [],</span><br><span class="line">    status: <span class="string">&#x27;idle&#x27;</span>,</span><br><span class="line">    error: null</span><br><span class="line">  &#125;,</span><br><span class="line">  reducers: &#123;&#125;,</span><br><span class="line">  extraReducers(builder)&#123;</span><br><span class="line">    builder</span><br><span class="line">      .addCase(fetchThunks.pending,(state,action)=&gt;&#123;</span><br><span class="line">        state.status = <span class="string">&#x27;loading&#x27;</span></span><br><span class="line">      &#125;)</span><br><span class="line">      .addCase(fetchThunks.fulfilled, (state, action) =&gt; &#123;</span><br><span class="line">        state.status = <span class="string">&#x27;succeeded&#x27;</span></span><br><span class="line">        // Add any fetched posts to the array</span><br><span class="line">        state.posts = state.posts.concat(action.payload)</span><br><span class="line">      &#125;)</span><br><span class="line">      .addCase(fetchThunks.rejected, (state, action) =&gt; &#123;</span><br><span class="line">        state.status = <span class="string">&#x27;failed&#x27;</span></span><br><span class="line">        state.error = action.error.message</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default thunksSlice.reducer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在组件中通过</span></span><br><span class="line">useDispatch()(fetchThunks()) 调用获取异步的数据</span><br><span class="line"><span class="comment"># 当触发 fetchThunks 时，extraReducers会监听到该请求的状态，从而根据状态执行相应的操作。</span></span><br><span class="line"><span class="comment"># 在使用了该reducer的state的组件的地方都会同步更新视图</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React Redux Toolkit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>useState原理</title>
      <link href="/2021/06/25/useState%E5%8E%9F%E7%90%86/"/>
      <url>/2021/06/25/useState%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="state是异步的"><a href="#state是异步的" class="headerlink" title="state是异步的"></a>state是异步的</h1><p>在控制台中，我们可以看到，打印的num并不是页面上显示的结果，这是因为react中state的更新是异步的。当我们setState后，react并不会立即将值做出改变，而是将其暂时放入pedding队列中。react会合并多个state，然后只render 一次。</p><h1 id="state改变却没有重新初始化"><a href="#state改变却没有重新初始化" class="headerlink" title="state改变却没有重新初始化"></a>state改变却没有重新初始化</h1><p>页面在首次渲染时会 render 渲染 <App /> 函数组件，其实际上是调用 App() 方法，得到虚拟 DOM 元素，并将其渲染到浏览器页面上。当用户点击 button 按钮时会调用 setN(n+1) 方法，然后再进行一次 render 渲染 <App /> 函数组件，其实际上还是调用了 App() 方法，得到一个新的虚拟 DOM 元素，然后 React 会执行 DOM diff 算法，将改变的部分更新到浏览器的页面上。</p><p>页面首次渲染和进行 +1 操作，都会调用 App() 函数去执行 const [n, setN] &#x3D; React.useState(0); 这行代码，那它是怎么做到在 +1 操作后，第二次渲染时执行同样的代码，却不对变量 n 进行初始化的，而是拿到 n 的最新值的呢 </p><p>let _state; &#x2F;&#x2F; 把 state 存储在外面</p><p>function useState(initialValue) {<br>  _state &#x3D; _state || initialValue; &#x2F;&#x2F; 如果没有 _state，说明是第一次执行，把 initialValue 复制给它<br>  function setState(newState) {<br>    _state &#x3D; newState;    &#x2F;&#x2F;实际修改的是_state，重新渲染也会去拿_state<br>    render();<br>  }<br>  return [_state, setState];<br>}</p><h1 id="这种使用-useState的方式在-React-中是不被允许-useEffect同理"><a href="#这种使用-useState的方式在-React-中是不被允许-useEffect同理" class="headerlink" title="这种使用 useState的方式在 React 中是不被允许 useEffect同理"></a>这种使用 useState的方式在 React 中是不被允许 useEffect同理</h1><p>if (n % 2 &#x3D;&#x3D;&#x3D; 1) {    的<br>    [m, setM] &#x3D; React.useState(0);<br>}<br>应对多个变量的问题，React 引用了数组对其进行解决，但是这中改进方式有一个缺点，由于数组不像对象，有对应的键，数组只能依靠顺序找到对应的变量，所以在 React 中不允许将 useState() hook 放到 if 判断语句中，这样就会导致变量在数组中的顺序混乱</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>useState是通过将变量抽离到函数体外形成闭包，在函数体内部判断而形成的缓存<br>因为允许组件多次调用的问题，useState只接受一个参数，所以采用数组的方式进行缓存。<br>不能在顶层做条件执行就是怕数组乱序</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> useState </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redux React-Redux @Reduxjs/toolkit组合拳的使用</title>
      <link href="/2021/04/20/Redux-React-Redux-Reduxjs-toolkit%E7%BB%84%E5%90%88%E6%8B%B3%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/04/20/Redux-React-Redux-Reduxjs-toolkit%E7%BB%84%E5%90%88%E6%8B%B3%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>因为redux不仅仅是react专用的状态管理工具，所以需要用到react-redux来帮助我们更好的在react项目中使用它<br>@reduxjs&#x2F;toolkit 是状态管理使用便捷的工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># NPM</span></span><br><span class="line">npm install @reduxjs/toolkit react-redux redux</span><br></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个reducer  counter.js</span></span><br><span class="line">import &#123; createSlice &#125; from <span class="string">&#x27;@reduxjs/toolkit&#x27;</span></span><br><span class="line"></span><br><span class="line">const counterSlice = createSlice(&#123;</span><br><span class="line">  name: <span class="string">&#x27;counter&#x27;</span>,</span><br><span class="line">  initialState: &#123;</span><br><span class="line">    value: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    incremented: state =&gt; &#123;</span><br><span class="line">      state.value += 1</span><br><span class="line">    &#125;,</span><br><span class="line">    decremented: state =&gt; &#123;</span><br><span class="line">      state.value -= 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> const &#123; incremented, decremented &#125; = counterSlice.actions</span><br><span class="line"><span class="built_in">export</span> default counterSlice.reducer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 集中到store里面</span></span><br><span class="line"><span class="comment"># 引入刚刚的创建的counter.js</span></span><br><span class="line">import counterSlice from <span class="string">&quot;./counter&quot;</span></span><br><span class="line">import &#123; configureStore &#125; from <span class="string">&#x27;@reduxjs/toolkit&#x27;</span></span><br><span class="line">const store = configureStore(&#123;</span><br><span class="line">  reducer:&#123;</span><br><span class="line">    counter: counterSlice</span><br><span class="line">  &#125; </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default store</span><br><span class="line"></span><br><span class="line"><span class="comment"># 集成到入口文件， 通过react-redux组件&lt;Provider&gt;传递到全局</span></span><br><span class="line">import React from <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line">import ReactDOM from <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line">import <span class="string">&#x27;./index.css&#x27;</span>;</span><br><span class="line">import &#123; BrowserRouter &#125; from <span class="string">&quot;react-router-dom&quot;</span></span><br><span class="line">import App from <span class="string">&#x27;./App&#x27;</span></span><br><span class="line">import store from <span class="string">&#x27;./reduces/index&#x27;</span></span><br><span class="line">import &#123; Provider &#125; from <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;BrowserRouter&gt;</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">      &lt;App /&gt;</span><br><span class="line">    &lt;/Provider&gt;</span><br><span class="line">  &lt;/BrowserRouter&gt;</span><br><span class="line">  ,</span><br><span class="line">  document.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 某个组件内部调用</span></span><br><span class="line"></span><br><span class="line">import &#123; Link &#125; from <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line">import HightClock from <span class="string">&#x27;../hightComponents/clock&#x27;</span></span><br><span class="line">import &#123; useSelector, useDispatch &#125; from <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line">import &#123; decremented, incremented &#125; from <span class="string">&#x27;./../reduces/test&#x27;</span></span><br><span class="line"><span class="built_in">export</span> default HightClock((props)=&gt;&#123;</span><br><span class="line">  <span class="comment"># useSelector 用于获取值</span></span><br><span class="line">  const count = useSelector(state =&gt; state.counter.value)</span><br><span class="line">  <span class="comment"># useDispatch() 用于触发action</span></span><br><span class="line">  const dispatch = useDispatch()</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;About&lt;/h1&gt;</span><br><span class="line">      &lt;h2 onClick=&#123;() =&gt; dispatch(incremented())&#125;&gt;Add One&lt;/h2&gt;</span><br><span class="line">      &lt;h2 onClick=&#123;() =&gt; dispatch(decremented())&#125;&gt;reduce One&lt;/h2&gt;</span><br><span class="line">      &lt;h2&gt;&#123;count&#125;&lt;/h2&gt;</span><br><span class="line">      &lt;div style=&#123;&#123;color: <span class="string">&#x27;blue&#x27;</span>&#125;&#125;&gt;&#123;props.date&#125;&lt;/div&gt;</span><br><span class="line">      &lt;Link to=<span class="string">&quot;/&quot;</span>&gt;To Home Clock&lt;/Link&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="异步的数据更新视图-中间件-thunk"><a href="#异步的数据更新视图-中间件-thunk" class="headerlink" title="异步的数据更新视图 中间件 thunk"></a>异步的数据更新视图 中间件 thunk</h1><p>Redux 存储对异步逻辑一无所知。它只知道如何同步调度动作，通过调用根 reducer 函数更新状态，并通知 UI 发生了一些变化。任何异步都必须在store之外发生。<br>但是，如果您想通过调度或检查当前存储状态来让异步逻辑与存储交互怎么办？这就是Redux 中间件的用武之地。它们扩展了存储，并允许您：</p><ul><li>在dispatch任何操作时执行额外的逻辑（例如记录操作和状态）</li><li>暂停、修改、延迟、替换或暂停已调度的操作</li><li>编写可以访问dispatch和getState</li><li>教dispatch如何接受除了普通动作对象之外的其他值，例如函数和promise，通过拦截它们并派发真实的动作对象来代替</li></ul><p>Redux Toolkit 的configureStore功能默认自动设置 thunk 中间件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改 reducer counter.js</span></span><br><span class="line">import &#123; createSlice &#125; from <span class="string">&#x27;@reduxjs/toolkit&#x27;</span></span><br><span class="line"></span><br><span class="line">const counterSlice = createSlice(&#123;</span><br><span class="line">  name: <span class="string">&#x27;counter&#x27;</span>,</span><br><span class="line">  initialState: &#123;</span><br><span class="line">    value: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    incremented: state =&gt; &#123;</span><br><span class="line">      state.value += 1</span><br><span class="line">    &#125;,</span><br><span class="line">    decremented: state =&gt; &#123;</span><br><span class="line">      state.value -= 1</span><br><span class="line">    &#125;,</span><br><span class="line">    incrementByAmount: (state,action) =&gt; &#123;</span><br><span class="line">      state.value += action.payload</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">export</span> const &#123; incremented,incrementByAmount, decremented &#125; = counterSlice.actions</span><br><span class="line"><span class="comment">#  在这里可以 新增异步操作，根据异步的结果再执行更不更新视图的操作</span></span><br><span class="line"><span class="built_in">export</span> const asyncFun = (args)=&gt;&#123;</span><br><span class="line">  <span class="built_in">return</span> async (dispatch,getState)=&gt;&#123;</span><br><span class="line">    // 这里需要引入axios 触发get的请求</span><br><span class="line">    const data = await axios.get(<span class="string">&#x27;url&#x27;</span>)</span><br><span class="line">    const stateBefore = getState()</span><br><span class="line">    console.log(`Counter before: <span class="variable">$&#123;stateBefore.counter.value&#125;</span>`)</span><br><span class="line">    dispatch(incrementByAmount(args))</span><br><span class="line">    const stateAfter = getState()</span><br><span class="line">    console.log(`Counter after: <span class="variable">$&#123;stateAfter.counter.value&#125;</span>`)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default counterSlice.reducer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 组件内部调用 方法同其他dispatch保持一致</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import &#123; Link &#125; from <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line">import HightClock from <span class="string">&#x27;../hightComponents/clock&#x27;</span></span><br><span class="line">import &#123; useSelector, useDispatch &#125; from <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line">import &#123; decremented, incremented,asyncFun &#125; from <span class="string">&#x27;./../reduces/test&#x27;</span></span><br><span class="line"><span class="built_in">export</span> default HightClock((props)=&gt;&#123;</span><br><span class="line">  const count = useSelector(state =&gt; state.counter.value)</span><br><span class="line">  // const selectCounter = useSelector(state =&gt; state.counter.value)</span><br><span class="line">  // console.log(selectCounter)</span><br><span class="line">  const dispatch = useDispatch()</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;About&lt;/h1&gt;</span><br><span class="line">      &lt;h2 onClick=&#123;() =&gt; dispatch(incremented())&#125;&gt;Add One&lt;/h2&gt;</span><br><span class="line">      &lt;h2 onClick=&#123;() =&gt; dispatch(decremented())&#125;&gt;reduce One&lt;/h2&gt;</span><br><span class="line">      &lt;h2 onClick=&#123;() =&gt; dispatch(asyncFun(5))&#125;&gt;add Five&lt;/h2&gt;</span><br><span class="line">      &lt;h2&gt;&#123;count&#125;&lt;/h2&gt;</span><br><span class="line">      &lt;div style=&#123;&#123;color: <span class="string">&#x27;blue&#x27;</span>&#125;&#125;&gt;&#123;props.date&#125;&lt;/div&gt;</span><br><span class="line">      &lt;Link to=<span class="string">&quot;/&quot;</span>&gt;To Home Clock&lt;/Link&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redux 为何需要其他辅助工具一起完成数据状态管理</title>
      <link href="/2021/04/20/Redux-%E4%B8%BA%E4%BD%95%E9%9C%80%E8%A6%81%E5%85%B6%E4%BB%96%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7%E4%B8%80%E8%B5%B7%E5%AE%8C%E6%88%90%E6%95%B0%E6%8D%AE%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
      <url>/2021/04/20/Redux-%E4%B8%BA%E4%BD%95%E9%9C%80%E8%A6%81%E5%85%B6%E4%BB%96%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7%E4%B8%80%E8%B5%B7%E5%AE%8C%E6%88%90%E6%95%B0%E6%8D%AE%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Redux-为何需要其他辅助工具一起完成数据状态管理"><a href="#Redux-为何需要其他辅助工具一起完成数据状态管理" class="headerlink" title="Redux 为何需要其他辅助工具一起完成数据状态管理"></a>Redux 为何需要其他辅助工具一起完成数据状态管理</h1><p>Web 应用程序通常需要从服务器获取数据才能显示它。他们通常还需要对该数据进行更新，将这些更新发送到服务器，并使客户端上的缓存数据与服务器上的数据保持同步。由于需要实现当今应用程序中使用的其他行为，这变得更加复杂：</p><ul><li>跟踪加载状态以显示 UI 微调器</li><li>避免对相同数据的重复请求</li><li>乐观的更新，让 UI 感觉更快</li><li>在用户与 UI 交互时管理缓存生命周期</li></ul><h1 id="产生的问题"><a href="#产生的问题" class="headerlink" title="产生的问题"></a>产生的问题</h1><p>Redux 核心一直非常小 而且 Redux 从来没有内置任何东西来帮助解决这些用例。<br>用户仍然需要编写大量的 reducer 逻辑来管理加载状态和缓存数据。</p><h1 id="生态中优秀的辅助工具"><a href="#生态中优秀的辅助工具" class="headerlink" title="生态中优秀的辅助工具"></a>生态中优秀的辅助工具</h1><ul><li>RTK Query（官方的）</li><li>Apollo Client</li><li>React Query</li><li>Urql </li><li>SWR</li></ul>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mobx6.x使用指南</title>
      <link href="/2021/04/16/mobx6-x%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2021/04/16/mobx6-x%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="直接开启动态监听，与视图双向绑定"><a href="#直接开启动态监听，与视图双向绑定" class="headerlink" title="直接开启动态监听，与视图双向绑定"></a>直接开启动态监听，与视图双向绑定</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import &#123;extendObservable&#125; from <span class="string">&#x27;mobx&#x27;</span>;</span><br><span class="line">import &#123; observer &#125; from <span class="string">&#x27;mobx-react&#x27;</span>;</span><br><span class="line">import React from <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line">class ShoppingList extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    extendObservable(this, &#123;</span><br><span class="line">      counter: 0,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  onIncrement = () =&gt; &#123;</span><br><span class="line">    this.counter++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onDecrement = () =&gt; &#123;</span><br><span class="line">    this.counter--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">    // const &#123; value &#125; = this.props</span><br><span class="line">    // const &#123; authStore &#125; = this.props.store;</span><br><span class="line">    console.log(this.props)</span><br><span class="line">    <span class="built_in">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">&quot;shopping-list&quot;</span>&gt;</span><br><span class="line">        &lt;h1&gt; &#123; this.counter&#125;&lt;/h1&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &lt;li onClick=&#123;this.onIncrement&#125; &gt;onIncrement&lt;/li&gt;</span><br><span class="line">          &lt;li onClick=&#123;this.onDecrement&#125;&gt;onDecrement&lt;/li&gt;</span><br><span class="line">          &lt;li&gt;Oculus&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">export</span> default observer(ShoppingList)</span><br></pre></td></tr></table></figure><h1 id="注意要点"><a href="#注意要点" class="headerlink" title="注意要点"></a>注意要点</h1><ul><li>安装 mobx mobx-react</li><li>初始化需要监听的数据,<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">constructor(props) &#123;</span><br><span class="line">  super(props);</span><br><span class="line">  extendObservable(this, &#123;</span><br><span class="line">    counter: 0,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>export 的时候 observer(ShoppingList) 一下</li></ul><p>这是实现了组件内的双向绑定类似于 data(){return{…obj}} v-model </p><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mobx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3 对比Vue2的提升</title>
      <link href="/2021/03/27/Vue3-%E5%AF%B9%E6%AF%94Vue2%E7%9A%84%E6%8F%90%E5%8D%87/"/>
      <url>/2021/03/27/Vue3-%E5%AF%B9%E6%AF%94Vue2%E7%9A%84%E6%8F%90%E5%8D%87/</url>
      
        <content type="html"><![CDATA[<h1 id="性能提升"><a href="#性能提升" class="headerlink" title="性能提升"></a>性能提升</h1><ul><li>响应式系统提升<br>vue2在初始化的时候，对data中的每个属性使用defineProperty调用getter和setter使之变为响应式对象。如果属性值为对象，还会递归调用。<br>vue3使用proxy对象重写响应式。proxy的性能本来比defineproperty好，proxy可以拦截属性的访问、赋值、删除等操作，不需要初始化的时候遍历所有属性<br>优势：</li></ul><ol><li>可以监听动态新增的属性；</li><li>可以监听删除的属性 ；</li><li>可以监听数组的索引和 length 属性；</li></ol><ul><li>编译优化<br>优化编译和重写虚拟dom，让首次渲染和更新dom性能有更大的提升。</li></ul><ol><li>vue2 通过标记静态根节点,优化 diff 算法；vue3 标记和提升所有静态根节点,diff 的时候只比较动态节点内容</li><li>Fragments, 模板里面不用创建唯一根节点,可以直接放同级标签和文本内容</li><li>静态提升 patch flag, 跳过静态节点,直接对比动态节点,缓存事件处理函数</li></ol><ul><li>源码体积的优化<br>vue3移除了一些不常用的api，例如：inline-template、filter等 使用tree-shaking</li></ul><h1 id="Composition-Api-与-Vue-2-x使用的Options-Api-有什么区别？"><a href="#Composition-Api-与-Vue-2-x使用的Options-Api-有什么区别？" class="headerlink" title="Composition Api 与 Vue 2.x使用的Options Api 有什么区别？"></a>Composition Api 与 Vue 2.x使用的Options Api 有什么区别？</h1><ul><li>Options Api<br>包含一个描述组件选项（data、methods、props等）的对象 options；<br>API开发复杂组件，同一个功能逻辑的代码被拆分到不同选项 ；<br>使用mixin重用公用代码，也有问题：命名冲突，数据来源不清晰；</li><li>composition Api<br>vue3 新增的一组 api，它是基于函数的 api，可以更灵活的组织组件的逻辑。<br>解决options api在大型项目中，options api不好拆分和重用的问题。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 组件通讯的方法</title>
      <link href="/2021/03/13/Vue-%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2021/03/13/Vue-%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue-组件通讯的方法"><a href="#Vue-组件通讯的方法" class="headerlink" title="Vue 组件通讯的方法"></a>Vue 组件通讯的方法</h1><ul><li>props和$emit</li><li>$on&#x2F;$emit</li><li>$parent&#x2F;$childen &amp; ref</li><li>Vuex</li></ul><h2 id="props和-emit"><a href="#props和-emit" class="headerlink" title="props和$emit"></a>props和$emit</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=<span class="string">&quot;home&quot;</span>&gt;</span><br><span class="line">    &lt;div&gt;我是父组件&lt;/div&gt;</span><br><span class="line">    &lt;Child :msg=<span class="string">&quot;msg&quot;</span> v-on:changed=<span class="string">&quot;changed&quot;</span>/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Child from <span class="string">&#x27;@/components/Child.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  name: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Child</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">data</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      msg: <span class="string">&#x27;child&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changed(e) &#123;</span><br><span class="line">      this.msg = e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ------- child component-------------</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p @click=<span class="string">&quot;change&quot;</span>&gt;</span><br><span class="line">          我是子组件:传递来的消息是：&#123;&#123;msg&#125;&#125;</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  name: <span class="string">&#x27;Child&#x27;</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    msg: &#123;</span><br><span class="line">      <span class="built_in">type</span>: String,</span><br><span class="line">      default: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">change</span></span>() &#123;</span><br><span class="line">      this.<span class="variable">$emit</span>(<span class="string">&#x27;changed&#x27;</span>,<span class="string">&#x27;向父组件传值&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="on-x2F-emit"><a href="#on-x2F-emit" class="headerlink" title="$on&#x2F;$emit"></a>$on&#x2F;$emit</h2><p>通过一个空的vue实例作为中央事件总线，用它来触发和监听事件，跨级组件之间的通讯</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ------  bus --------------</span></span><br><span class="line">import Vue from <span class="string">&#x27;vue&#x27;</span></span><br><span class="line">var Event = new Vue()</span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> <span class="function"><span class="title">sendSDKLoadend</span></span> () &#123;</span><br><span class="line">  Event.<span class="variable">$emit</span>(<span class="string">&#x27;loadendSDK&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> monitorSDKLoadend(callback) &#123;</span><br><span class="line">  Event.<span class="variable">$on</span>(<span class="string">&#x27;loadendSDK&#x27;</span>, callback)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 当某个页面触发了sendSDKLoadend()时，绑定了monitorSDKLoadend(fn) 的地方，fn会执行</span></span><br></pre></td></tr></table></figure><h2 id="parent-x2F-childen，访问父-x2F-子实例-和-ref获取组件实例"><a href="#parent-x2F-childen，访问父-x2F-子实例-和-ref获取组件实例" class="headerlink" title="$parent&#x2F;$childen，访问父&#x2F;子实例 和 ref获取组件实例"></a>$parent&#x2F;$childen，访问父&#x2F;子实例 和 ref获取组件实例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在组件上绑定 ref</span></span><br><span class="line">&lt;Child ref=<span class="string">&quot;child&quot;</span> /&gt;</span><br><span class="line"><span class="comment"># 通过 this.$refs.child 获取子组件的实例</span></span><br><span class="line">this.<span class="variable">$refs</span>.child</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子组件通过 $parent 获取父组件的实例</span></span><br><span class="line">this.<span class="variable">$parent</span></span><br></pre></td></tr></table></figure><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p>通过 this.$store.dispatch(‘actionName’,params) 触发Action去通知Mutation更新State的值。所有引用改State的值的组件都会更新</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue 组件通讯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm包classNames详解</title>
      <link href="/2021/02/04/npm%E5%8C%85classNames%E8%AF%A6%E8%A7%A3/"/>
      <url>/2021/02/04/npm%E5%8C%85classNames%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="classnames-快速组合CSS类"><a href="#classnames-快速组合CSS类" class="headerlink" title="classnames 快速组合CSS类"></a>classnames 快速组合CSS类</h1><p>在前端开发中，我们经常需要JS来判断生成DOM节点CSS类，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> className=<span class="string">&#x27;btn-primary&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(active)&#123;</span><br><span class="line">  className+=<span class="string">&#x27; active&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> &lt;div className=&#123;className&#125;&gt;Save&lt;/div&gt;;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们需要判断active变量来控制生成的按钮的CSS样式是否是激活状态，在实际开发中，可能会有更多的类似这样的样式控制逻辑，从而干扰阅读业务逻辑代码，使得代码变得很“脏”。</p><p>classnames 库对CSS样式类操作进行了封装，方便我们快速使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const classNames = require(<span class="string">&#x27;classnames&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> &lt;div className=&#123;classNames(<span class="string">&#x27;btn-primary&#x27;</span>,&#123; active &#125;)&#125;&gt;Save&lt;/div&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更多用法</span></span><br><span class="line">classNames(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); // =&gt; <span class="string">&#x27;foo bar&#x27;</span> </span><br><span class="line">classNames(<span class="string">&#x27;foo&#x27;</span>, &#123; bar: <span class="literal">true</span> &#125;); // =&gt; <span class="string">&#x27;foo bar&#x27;</span> </span><br><span class="line">classNames(&#123; <span class="string">&#x27;foo-bar&#x27;</span>: <span class="literal">true</span> &#125;); // =&gt; <span class="string">&#x27;foo-bar&#x27;</span> </span><br><span class="line">classNames(&#123; <span class="string">&#x27;foo-bar&#x27;</span>: <span class="literal">false</span> &#125;); // =&gt; <span class="string">&#x27;&#x27;</span> </span><br><span class="line">classNames(&#123; foo: <span class="literal">true</span> &#125;, &#123; bar: <span class="literal">true</span> &#125;); // =&gt; <span class="string">&#x27;foo bar&#x27;</span> </span><br><span class="line">classNames(&#123; foo: <span class="literal">true</span>, bar: <span class="literal">true</span> &#125;); // =&gt; <span class="string">&#x27;foo bar&#x27;</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> NPM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> classNames </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 多账号配置</title>
      <link href="/2021/02/01/git-%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/"/>
      <url>/2021/02/01/git-%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="git-多账号账号切换使用"><a href="#git-多账号账号切换使用" class="headerlink" title="git 多账号账号切换使用"></a>git 多账号账号切换使用</h1><ul><li>解决密钥问题。默认只有一个密钥，二次创建会覆盖</li><li>使用哪个账号提交的</li></ul><h1 id="生成两个账号私钥在本地"><a href="#生成两个账号私钥在本地" class="headerlink" title="生成两个账号私钥在本地"></a>生成两个账号私钥在本地</h1><p>生成默认的 id_rsa 和id_rsa.pub<br>ssh-keygen -t rsa -C “你的github注册邮箱1”<br>在创建第二个的时候必须要重命名 比如 137_id_ras,这样会生成另外两个文件137_id_rsa 和 137_id_rsa.pub<br>ssh-keygen -t rsa -C “你的github注册邮箱2”</p><h1 id="在-ssh下面创建config文件"><a href="#在-ssh下面创建config文件" class="headerlink" title="在.ssh下面创建config文件"></a>在.ssh下面创建config文件</h1><p>执行 touch config 创建<br>执行 vim config 编辑</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Default 第一个账号(123456@xxxx.com)</span></span><br><span class="line"></span><br><span class="line">Host default</span><br><span class="line">    HostName github.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/137_id_rsa</span><br><span class="line"><span class="comment">#second 第二个账号（38894403@xxxx.com）    </span></span><br><span class="line">Host zc</span><br><span class="line">    HostName github.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p>只需要修改 IdentityFile 即可<br>ssh -T <a href="mailto:&#103;&#105;&#x74;&#x40;&#103;&#105;&#116;&#x68;&#x75;&#98;&#x2e;&#x63;&#x6f;&#109;">&#103;&#105;&#x74;&#x40;&#103;&#105;&#116;&#x68;&#x75;&#98;&#x2e;&#x63;&#x6f;&#109;</a> 可以测试是否配置成功<br><code>配置成功会显示当前用户名</code> 这个很重要，因为当你想切换用户的时候没有这个不行<br>通过设置<br>git config –global user.name “13725102796”<br>git config –global user.email “<a href="mailto:&#x31;&#x34;&#x33;&#57;&#x36;&#53;&#x35;&#55;&#54;&#52;&#64;&#113;&#113;&#x2e;&#99;&#111;&#109;">&#x31;&#x34;&#x33;&#57;&#x36;&#53;&#x35;&#55;&#54;&#52;&#64;&#113;&#113;&#x2e;&#99;&#111;&#109;</a>“<br>还没有生效，因为ssh-add的代理始终指向默认的</p><h1 id="通过ssh-add删除代理"><a href="#通过ssh-add删除代理" class="headerlink" title="通过ssh-add删除代理"></a>通过ssh-add删除代理</h1><p>查看 ssh-add -l<br>删除 ssh-add -D<br>添加<br>ssh-add ~&#x2F;.ssh&#x2F;id_rsa<br>ssh-add ~&#x2F;.ssh&#x2F;137_id_rsa </p><h1 id="添加代理后还不可以，需要修改提交的git-clone-ssh链接"><a href="#添加代理后还不可以，需要修改提交的git-clone-ssh链接" class="headerlink" title="添加代理后还不可以，需要修改提交的git clone ssh链接"></a>添加代理后还不可以，需要修改提交的git clone ssh链接</h1><ul><li><p>还没clone的可以通过 来拉取项目，这样可以让ssh-add正确代理<br>git clone zy@:18820677498&#x2F;Blog.git<br>原来是 <a href="mailto:&#103;&#105;&#x74;&#x40;&#x67;&#105;&#116;&#x68;&#117;&#98;&#46;&#x63;&#111;&#x6d;">&#103;&#105;&#x74;&#x40;&#x67;&#105;&#116;&#x68;&#117;&#98;&#46;&#x63;&#111;&#x6d;</a>:18820677498&#x2F;Blog.git</p></li><li><p>已经clone的 可以切换到当前项目下，命令行执行<br><code>vim .git/config</code><br>打开config文件 按i去修改，按esc退出修改，再按 <code>:qw!</code> 保存修改</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue与React Diff算法比较</title>
      <link href="/2020/10/29/Vue%E4%B8%8EReact-Diff%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83/"/>
      <url>/2020/10/29/Vue%E4%B8%8EReact-Diff%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<h1 id="diff算法比对方式"><a href="#diff算法比对方式" class="headerlink" title="diff算法比对方式"></a>diff算法比对方式</h1><ol><li>Vue采用的是递归加双指针的方式对比旧节点，react是从左到右逐个对比<br>当一个集合，只是把最后一个节点移动到了第一个，</li><li>对比具体某个元素时，当元素类型相同，但是className不同，<br>vue认为是不同类型元素，删除重建。<br>react会认为是同类型节点，只是修改节点属性</li></ol><h1 id="diff-渲染机制不同"><a href="#diff-渲染机制不同" class="headerlink" title="diff 渲染机制不同"></a>diff 渲染机制不同</h1><ol><li>Vue是边对比边更新DOM</li><li>React使用的是队列保存需要更新的DDM，得到Patch树，再统一批量更新DOM</li></ol><h1 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h1><ol><li>虚拟DOM在比较时只比较同一层级节点，复杂度都为 O(n)，降低了算法复杂度；</li><li>都使用key比较是否是相同节点，都是为了尽可能的复用节点</li><li>都是操作虚拟DOM，最小化操作真实DOM，提高性能</li><li>都是不要用 index作为 key</li><li>在同级节点中元素顺序的变换，都是复用处理，新增的插入，多余的删掉</li></ol>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Diff </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷歌浏览器性能测试评估</title>
      <link href="/2020/10/25/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E8%AF%84%E4%BC%B0/"/>
      <url>/2020/10/25/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E8%AF%84%E4%BC%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Console-面板"><a href="#Console-面板" class="headerlink" title="Console 面板"></a>Console 面板</h1><p>console.log(‘普通信息’)<br>console.info(‘提示性信息’)<br>console.error(‘错误信息’)<br>console.warn(‘警示信息’)<br>time 和 timeEnd 一般放在一起用，传入一个参数用来标识起始位置用于统计时间:<br>console.time(‘遍历九十万次执行时间’)<br>Array(900000).fill({}).forEach((v, index) &#x3D;&gt; v.index &#x3D; index)<br>console.timeEnd(‘遍历九十万次执行时间’)<br>&#x2F;&#x2F;打印输出 遍历九十万次执行时间: 21.874755859375 ms</p><p>console.trace() 用于追踪代码的调用栈，不用专门断点去看了<br>performance.memory可以查看内存的使用情况<br>jsHeapSizeLimit: 4294705152<br>totalJSHeapSize: 31789794<br>usedJSHeapSize: 30112726<br>usedJSHeapSize &gt; totalJSHeapSize 则表明内存泄漏了</p><h1 id="代码断点-源代码面板"><a href="#代码断点-源代码面板" class="headerlink" title="代码断点  源代码面板"></a>代码断点  源代码面板</h1><p>找到源代码，点击要中断代码执行的位置，点击红色按钮的位置。然后再触发该方法执行，因为已知点击按钮可以触发，精准的定位到代码行就可以了</p><h1 id="Performance-面板"><a href="#Performance-面板" class="headerlink" title="Performance 面板"></a>Performance 面板</h1><ul><li>首先点击控制条左边的第一个圆圈，开始记录日志</li><li>等待几分钟(正常操作页面)</li><li>点击 Stop 按钮，Devtools 停止录制，处理数据，然后显示性能报告</li></ul><h1 id="Lighthouse-Audits-面板"><a href="#Lighthouse-Audits-面板" class="headerlink" title="Lighthouse(Audits) 面板"></a>Lighthouse(Audits) 面板</h1><p>来自 Google 的描述： Lighthouse 是一个开源的自动化工具，用于改进网络应用的质量。 您可以将其作为一个 Chrome 扩展程序运行，或从命令行运行。 您为 Lighthouse 提供一个您要审查的网址，它将针对此页面运行一连串的测试，然后生成一个有关页面性能的报告</p><p>会对页面的加载进行分析，然后给出提高页面性能的建议</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevTools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack中loader和Plugin</title>
      <link href="/2020/08/25/webpack%E4%B8%ADloader%E5%92%8CPlugin/"/>
      <url>/2020/08/25/webpack%E4%B8%ADloader%E5%92%8CPlugin/</url>
      
        <content type="html"><![CDATA[<h1 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h1><p>Loader直译为”加载器”。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。</p><p>Loader在module.rules中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options）</p><p>常见的loader<br>样式：style-loader、css-loader、less-loader、sass-loader等<br>文件：raw-loader、file-loader 、url-loader等<br>编译：babel-loader(把 ES6 转换成 ES5)、coffee-loader 、ts-loader等<br>校验测试：mocha-loader、jshint-loader 、eslint-loader等<br>imports-loader、exports-loader等可以向模块注入变量或者提供导出模块功能</p><h1 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h1><p>直译为”插件”。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果</p><p>Plugin在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入</p><p>常见的Plugin<br>webpack内置UglifyJsPlugin，压缩和混淆代码,通过UglifyES压缩ES6代码。<br>webpack内置CommonsChunkPlugin，提取公共代码,提高打包效率，将第三方库和业务代码分开打包<br>ProvidePlugin：自动加载模块，代替require和import </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new webpack.ProvidePlugin(&#123; </span><br><span class="line">   $: <span class="string">&#x27;jquery&#x27;</span>,</span><br><span class="line">   jQuery: <span class="string">&#x27;jquery&#x27;</span> </span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><p>html-webpack-plugin可以根据模板自动生成html代码，并自动引用css和js文件<br>extract-text-webpack-plugin 将js文件中引用的样式单独抽离成css文件<br>DefinePlugin编译时配置全局变量，这对开发模式和发布模式的构建允许不同的行为非常有用<br>HotModuleReplacementPlugin 热更新</p>]]></content>
      
      
      <categories>
          
          <category> Webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React函数组件如何使用生命周期钩子</title>
      <link href="/2020/08/21/React%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90/"/>
      <url>/2020/08/21/React%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<h1 id="useEffect-Hook-useState-Hook"><a href="#useEffect-Hook-useState-Hook" class="headerlink" title="useEffect Hook useState Hook"></a>useEffect Hook useState Hook</h1><p>Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Counter</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">  const [counter,setCounter] = useState(0)</span><br><span class="line">  <span class="comment"># 这句话等同于 class Components 的</span></span><br><span class="line">  <span class="comment"># state = &#123;</span></span><br><span class="line">  <span class="comment">#   counter: 0</span></span><br><span class="line">  <span class="comment"># &#125;</span></span><br><span class="line">  <span class="comment"># 可以在函数内使用多次，用法和state一样，不一定是值，可以是对象，like：</span></span><br><span class="line">  <span class="comment"># const [counter1,setCounter1] = useState(&#123;id:1,value: 2&#125;)</span></span><br><span class="line">  <span class="comment"># 通过setCounter设置counter的值</span></span><br><span class="line">  </span><br><span class="line">  useEffect(()=&gt;&#123;</span><br><span class="line">    <span class="comment"># 这里处理的是 componentDidMount 和 componentDidUpdate</span></span><br><span class="line">    setCounter(counter+1)</span><br><span class="line">    <span class="built_in">return</span> ()=&gt;&#123;</span><br><span class="line">      <span class="comment"># 这里处理的是componentWillUnmount</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment"># useEffect也可以设定多个，他还有第二个参数，用于设置他是否在更新的时候执行</span></span><br><span class="line">  <span class="comment"># useEffect(()=&gt;&#123;</span></span><br><span class="line">  <span class="comment">#   setCounter(counter+1)</span></span><br><span class="line">  <span class="comment"># &#125;,[counter])</span></span><br><span class="line">  <span class="comment"># 这里监听了counter，只有counter发生改变才会执行</span></span><br><span class="line">  <span class="comment"># useEffect(()=&gt;&#123;</span></span><br><span class="line">  <span class="comment">#   setCounter(counter+1)</span></span><br><span class="line">  <span class="comment"># &#125;,[])</span></span><br><span class="line">  <span class="comment"># 是空数组的话，就可以在更新的时候不执行，只会在第一次加载的时候执行</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="自定义Hook"><a href="#自定义Hook" class="headerlink" title="自定义Hook"></a>自定义Hook</h1><p>首先 自定义 Hook 是一种自然遵循 Hook 设计的约定，而并不是 React 的特性。<br>类似于将多个组件共同的功能抽离出来，统一封装使用<br>要点：</p><ul><li>自定义 Hook 必须以 “use” 开头，因为要判断某个函数是否包含对其内部 Hook 的调用，React 将需要自动检查你的 Hook 是否违反了 Hook 的规则。</li><li>在两个组件中使用相同的 Hook 不会共享 state。自定义 Hook 是一种重用状态逻辑的机制(例如设置为订阅并存储当前值)，所以每次使用自定义 Hook 时，其中的所有 state 和副作用都是完全隔离的。</li></ul><p>由于使用相同的 Hook 不会共享 state，大多数情况还是需要依赖redux等辅助工具来统一状态管理。</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> useEffect useState Hook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 配置本地代理</title>
      <link href="/2020/08/20/React-%E9%85%8D%E7%BD%AE%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%90%86/"/>
      <url>/2020/08/20/React-%E9%85%8D%E7%BD%AE%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="React配置代理"><a href="#React配置代理" class="headerlink" title="React配置代理"></a>React配置代理</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.检查自己的create-react-app脚手架若在2.0版本以下，使用对象类型配置代理，在自己项目的package.json文件中配置如下：</span></span><br><span class="line"><span class="string">&quot;proxy&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;/api&quot;</span>:&#123;</span><br><span class="line">      <span class="string">&quot;target&quot;</span>:<span class="string">&quot;代理服务器的地址&quot;</span>,  <span class="comment"># 跨域地址</span></span><br><span class="line">      <span class="string">&quot;changeOrigin&quot;</span>: <span class="literal">true</span>,    <span class="comment"># 是否允许跨域</span></span><br><span class="line">      <span class="string">&quot;pathRewrite&quot;</span>: &#123;        <span class="comment"># 重写路径</span></span><br><span class="line">           <span class="string">&quot;^/api&quot;</span>: <span class="string">&quot;/&quot;</span></span><br><span class="line">       &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 2.若脚手架版本在2.0以上只能配置string类型</span></span><br><span class="line"><span class="string">&quot;proxy&quot;</span>: <span class="string">&quot;代理服务器的地址&quot;</span>,</span><br><span class="line"><span class="comment"># 多代理配置可以使用中间件的方式 http-proxy-middleware</span></span><br><span class="line"><span class="comment"># 安装 http-proxy-middleware，然后在项目的src目录下建立setupProxy.js文件</span></span><br><span class="line">const &#123; createProxyMiddleware &#125; = require(<span class="string">&#x27;http-proxy-middleware&#x27;</span>);</span><br><span class="line">module.exports = <span class="keyword">function</span> (app) &#123;</span><br><span class="line">    app.use(</span><br><span class="line">      createProxyMiddleware(<span class="string">&#x27;/api&#x27;</span>, &#123;</span><br><span class="line">        target: <span class="string">&#x27;代理地址1&#x27;</span>,</span><br><span class="line">        secure: <span class="literal">false</span>,    <span class="comment"># 指定Cookies能否被用户读取</span></span><br><span class="line">        changeOrigin: <span class="literal">true</span>,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">            <span class="string">&quot;^/api&quot;</span>: <span class="string">&quot;/&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="comment"># 配置多个代理继续往下加就可以</span></span><br><span class="line">      createProxyMiddleware(<span class="string">&#x27;/api1&#x27;</span>, &#123;</span><br><span class="line">        target: <span class="string">&#x27;代理地址2&#x27;</span>,</span><br><span class="line">        secure: <span class="literal">false</span>,    <span class="comment"># 指定Cookies能否被用户读取</span></span><br><span class="line">        changeOrigin: <span class="literal">true</span>,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">            <span class="string">&quot;^/api&quot;</span>: <span class="string">&quot;/&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React手写一个高阶组件</title>
      <link href="/2020/08/17/React%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/"/>
      <url>/2020/08/17/React%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="高级组件是为了让数据和视图分离，这里以Clock为例"><a href="#高级组件是为了让数据和视图分离，这里以Clock为例" class="headerlink" title="高级组件是为了让数据和视图分离，这里以Clock为例"></a>高级组件是为了让数据和视图分离，这里以Clock为例</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取当前运动的时间点</span></span><br><span class="line">class Clock extends React.Components &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>()&#123;</span><br><span class="line">    super()</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      <span class="built_in">date</span>: new Date().toLocaleTimeString()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span></span>()&#123;</span><br><span class="line">    this.timerId = setInterval(()=&gt;&#123;</span><br><span class="line">      this.tick()</span><br><span class="line">    &#125;,1000)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentWillUnmount</span></span>()&#123;</span><br><span class="line">    clearInterval(this.timerId)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">tick</span></span>()&#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      <span class="built_in">date</span>: new Date().toLocaleTimeString()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;This is Clock&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;&#123;this.state.date&#125;&lt;/h2&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面一个普通的时钟组件就写好了，但是我想要很多个不同外观的时钟。<br>这个时候我不可能去一个个的复制这个Clock-》Clock1-》Clock2… 然后去修改里面的render里面html的外观。</p><p>首先要明确一点，这里的获取和生成数据的逻辑都是一样的，是可以复用<br>这时候，就可以使用高阶组件去包装，把数据操作层和UI层分离出来<br>通过向高阶组件传递UI的组件去复用数据的逻辑</p><p>实现代码如下： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">import React from <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">function</span> HightClock(UIComponents)&#123;</span><br><span class="line">  <span class="built_in">return</span> class extends React.Component &#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">      super(props)</span><br><span class="line">      this.state = &#123;</span><br><span class="line">        <span class="built_in">date</span>: new Date().toLocaleTimeString()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span></span>()&#123;</span><br><span class="line">      this.timerId = setInterval(()=&gt;&#123;</span><br><span class="line">        this.tick()</span><br><span class="line">      &#125;,1000)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">componentWillUnmount</span></span>()&#123;</span><br><span class="line">      clearInterval(this.timerId)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">tick</span></span>()&#123;</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        <span class="built_in">date</span>: new Date().toLocaleTimeString()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span></span>()&#123;</span><br><span class="line">      <span class="built_in">return</span> (</span><br><span class="line">        &lt;UIComponents <span class="built_in">date</span>=&#123;this.state.date&#125; &#123;...this.props&#125; /&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> Clock1 (props)&#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Clock1&lt;/h1&gt;</span><br><span class="line">      &lt;h2&gt;&#123;props.date&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> Clock2 (props)&#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    &lt;div style=&#123;&#123;color: <span class="string">&#x27;red&#x27;</span>&#125;&#125; &gt;</span><br><span class="line">      &lt;h1&gt;Clock2&lt;/h1&gt;</span><br><span class="line">      &lt;h2&gt;&#123;props.date&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">const Clock1Componetns = HightClock(Clock1)</span><br><span class="line">const Clock2Componetns = HightClock(Clock12)</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Clock</span></span> ()&#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Clock1Componetns /&gt;</span><br><span class="line">      &lt;Clock2Componetns /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default Clock</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React HOC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TS 详解</title>
      <link href="/2020/08/01/TS-%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/08/01/TS-%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="参数类型注解"><a href="#参数类型注解" class="headerlink" title="参数类型注解"></a>参数类型注解</h1><p>function greeter(person: string) {<br>  return “Hello, “ + person;<br>}<br>此刻表明 只能接受 greeter(“字符串类型”) 否则会报错</p><h1 id="接口方式定义注解"><a href="#接口方式定义注解" class="headerlink" title="接口方式定义注解"></a>接口方式定义注解</h1><ul><li>我们想要描述一个参数是一个对象且拥有两个属性 firstName &amp;&amp; lastName<br>interface Person {<br>firstName: string;<br>lastName: string;<br>}<br>function greeter(person: Person) {<br>  return “Hello, “ + person.firstName + “ “ + person.lastName;<br>}<br>greeter({ firstName: “Jane”, lastName: “User” });</li></ul><h1 id="类型基础"><a href="#类型基础" class="headerlink" title="类型基础"></a>类型基础</h1><ul><li><p>布尔值 boolean </p></li><li><p>数字 number</p></li><li><p>字符串 string</p></li><li><p>对象 object</p></li><li><p>数组 number[] || Array<number>  都是表示数组里面值为数字</p></li><li><p>元组 Tuple 可以定义数组顺序项的类型 [string, number]<br>(arr[0] is string, arr[1] is number) 当访问arr[3] 则会判断是否是string｜number</p></li><li><p>枚举 这是一个功能索引的方法<br>enum Color {Red &#x3D; 1,Green,Blue}<br>let c: Color &#x3D; Color.Green<br>let colorName: string &#x3D; Color[2];<br>console.log(colorName); &#x2F;&#x2F; Green</p></li><li><p>Any let notSure: any &#x3D; 4; 任意类型</p></li><li><p>Void 表示没有任何类型。一般用来定义一个函数没有任何返回值</p></li><li><p>Null 和 Undefined</p></li><li><p>Never never的函数必须存在无法达到的终点<br>function error(message: string): never {<br>  throw new Error(message);<br>}<br>function infiniteLoop(): never {<br>  while (true) {<br>  }<br>}</p></li></ul><h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><p>namespace Shapes {<br>  export namespace Polygons {<br>        export class Triangle { }<br>        export class Square { }<br>  }<br>}<br>import otherName &#x3D;  Shapes.Polygons<br>let sq &#x3D; new polygons.Square(); &#x2F;&#x2F; Same as “new Shapes.Polygons.Square()”</p>]]></content>
      
      
      <categories>
          
          <category> TS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>new Vue都做了什么</title>
      <link href="/2020/07/29/new-Vue%E9%83%BD%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/"/>
      <url>/2020/07/29/new-Vue%E9%83%BD%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<h1 id="new-Vue初始化流程"><a href="#new-Vue初始化流程" class="headerlink" title="new Vue初始化流程"></a>new Vue初始化流程</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  el:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment"># src/core/instance/index.js</span></span><br><span class="line">import &#123; initMixin &#125; from <span class="string">&#x27;./init&#x27;</span></span><br><span class="line">import &#123; stateMixin &#125; from <span class="string">&#x27;./state&#x27;</span></span><br><span class="line">import &#123; renderMixin &#125; from <span class="string">&#x27;./render&#x27;</span></span><br><span class="line">import &#123; eventsMixin &#125; from <span class="string">&#x27;./events&#x27;</span></span><br><span class="line">import &#123; lifecycleMixin &#125; from <span class="string">&#x27;./lifecycle&#x27;</span></span><br><span class="line">import &#123; warn &#125; from <span class="string">&#x27;../util/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Vue(options) &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">    !(this instanceof Vue)</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(<span class="string">&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  // new Vue的时候就执行到了这个_init函数</span><br><span class="line">  this._init(options)</span><br><span class="line">&#125;</span><br><span class="line">initMixin(Vue) // 其他的不看，先看这个函数</span><br><span class="line">stateMixin(Vue)</span><br><span class="line">eventsMixin(Vue)</span><br><span class="line">lifecycleMixin(Vue)</span><br><span class="line">renderMixin(Vue)</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default Vue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># _init 主要做了什么</span></span><br><span class="line">initLifecycle(vm)</span><br><span class="line">initEvents(vm) <span class="variable">$on</span> 、<span class="variable">$emit</span> :like @click</span><br><span class="line">initRender(vm) 用于初始化<span class="variable">$slots</span> 、<span class="variable">$attrs</span> 、<span class="variable">$listeners</span></span><br><span class="line">callHook(vm, <span class="string">&#x27;beforeCreate&#x27;</span>)</span><br><span class="line">initInjections(vm) // resolve injections before data/props</span><br><span class="line">initState(vm)</span><br><span class="line">initProvide(vm) // resolve provide after data/props</span><br><span class="line">callHook(vm, <span class="string">&#x27;created&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># mount阶段做了什么</span></span><br><span class="line">/**</span><br><span class="line">* 编译权重：</span><br><span class="line">* 优先看有没有render函数，如果有直接用</span><br><span class="line">* 如果没有render函数就看有没有template模板</span><br><span class="line">* 如果都没有就直接获取el的outerHTML作为渲染模板</span><br><span class="line">*/</span><br><span class="line"><span class="keyword">if</span> (!options.render) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!options.template) &#123;</span><br><span class="line">        template = el.outerHTML</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        template = vm.<span class="variable">$options</span>.template</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (template) &#123;</span><br><span class="line">    //用 template 生成 render 函数</span><br><span class="line">    <span class="built_in">let</span> render = compileToFunctions(template)</span><br><span class="line">    options.render = render</span><br><span class="line">&#125;</span><br><span class="line">//调用 mount 方法开始渲染页面。</span><br><span class="line"><span class="built_in">return</span> mount(this, el)</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> mountComponent(vm, el) &#123;</span><br><span class="line">//渲染之前调用 beforeMount 生命周期</span><br><span class="line">    callHook(vm, <span class="string">&#x27;beforeMount&#x27;</span>)</span><br><span class="line">    //创建一个更新渲染函数 （ 用来得到 Vnode 渲染真实 dom ）</span><br><span class="line">    <span class="built_in">let</span> updateComponent = () =&gt; &#123;</span><br><span class="line">        vm.update(vm._render())</span><br><span class="line">    &#125;</span><br><span class="line">    //生成一个渲染 watcher 每次页面依赖的数据更新后会调用 updateComponent 进行渲染</span><br><span class="line">    new Watcher(vm, updateComponent, () =&gt; &#123;&#125;,&#123;</span><br><span class="line">        <span class="function"><span class="title">before</span></span> () &#123;</span><br><span class="line">            callHook(vm, <span class="string">&#x27;beforeUpdate&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,<span class="literal">true</span>)</span><br><span class="line">    //渲染真实 dom 结束后调用 mounted 生命周期</span><br><span class="line">    callHook(vm, <span class="string">&#x27;mounted&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 创建了一个更新的渲染函数update，以及一个Watcher</span></span><br><span class="line"><span class="built_in">export</span> class Watcher &#123;</span><br><span class="line">    constructor(vm,expOrFn,cb,options) &#123;</span><br><span class="line">        <span class="keyword">if</span> (typeof expOrFn === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        // 保留 updateComponent 方法</span><br><span class="line">            this.getters = expOrFn</span><br><span class="line">        &#125;</span><br><span class="line">        this.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">get</span></span>() &#123;</span><br><span class="line">        pushTarget(this)</span><br><span class="line">        <span class="built_in">let</span> value</span><br><span class="line">        // 这里调用了 updateComponent 方法</span><br><span class="line">        value = this.getters.call(this.vm, this.vm);</span><br><span class="line">        popTarget()</span><br><span class="line">        <span class="built_in">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># watcher 主要监听 页面数据的变动，变动后调用updateComponent去更新视图</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 而update则基于diff算法去对比节点，与上一次的节点进行对比，diff主要基于递归和双指针去对比。然后patch到真实的节点上去更新视图</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>new Vue()主要做了 创建一个空对象，把Vue构造函数的原型指向该对象，通过apply继承的方式去执行该构造函数，并返回该执行结果</li><li>执行该构造函数的过程，主要是Vue初始化的过程</li></ol><ul><li>初始化生命周期 initLifecycle </li><li>初始化事件以及特殊操作符 $on,$attr…</li><li>执行beforeCreat钩子函数</li><li>依赖注入，初始化state，注入provider（props）</li><li>执行Created</li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue2 双向绑定原理</title>
      <link href="/2020/07/27/Vue2-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/"/>
      <url>/2020/07/27/Vue2-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="双向绑定的原理介绍"><a href="#双向绑定的原理介绍" class="headerlink" title="双向绑定的原理介绍"></a>双向绑定的原理介绍</h1><p>vue的双向绑定是数据和视图的同步变化，即当数据发生变化的时候，相关的视图会发生改变；<br>视图发生改变的时候，数据也会随之变化。它是通过 数据劫持 结合 发布订阅模式的方式来实现的。</p><h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><ul><li>将vue中的data里的所有属性通过实现Observer来完成数据劫持</li><li>Dep是一个容器来存放所有的订阅者Watcher，并解析页面的模板  ，执行相应方法将数据解析到页面上。</li><li>实现一个监听者Oberver来劫持并监听所有的属性，一旦有属性发生变化就通知订阅者Watcher。</li><li>订阅者watcher接受来自属性变化的通知(notify)并执行相应的方法，从而更新视图</li><li>实现一个解析器compile，可以扫描和解析每个节点的相关指令(v-xxx)，通过指令(v-xxx)去对DOM进行封装。当数据发生变化，指令修改对应的DOM，数据驱动DOM的变化。反向，Vue也会监听操作，修改视图时，Vue监听到变化后，改变数据。数据的双向变化形成</li></ul><h1 id="Observer，Dep，Watcher，Compile抽象出数据的双向绑定。"><a href="#Observer，Dep，Watcher，Compile抽象出数据的双向绑定。" class="headerlink" title="Observer，Dep，Watcher，Compile抽象出数据的双向绑定。"></a>Observer，Dep，Watcher，Compile抽象出数据的双向绑定。</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个容器类 来存放所有的订阅者</span></span><br><span class="line">class Dep &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>()&#123;</span><br><span class="line">    this.subs = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment"># 订阅</span></span><br><span class="line">  addSub(watcher)&#123;</span><br><span class="line">    this.subs.push(watcher)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment"># 发布</span></span><br><span class="line">  <span class="function"><span class="title">notify</span></span>()&#123;</span><br><span class="line">    this.subs.forEach((watcher)=&gt;watcher.update())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 观察者：将数据劫持和页面联系起来</span></span><br><span class="line">class Watcher&#123;</span><br><span class="line">  constructor(vm,<span class="built_in">expr</span>,cb)&#123;</span><br><span class="line">    this.vm = vm</span><br><span class="line">    this.expr = <span class="built_in">expr</span></span><br><span class="line">    this.cb = cb</span><br><span class="line"></span><br><span class="line">    this.oldValue = this.get()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">get</span></span>()&#123;</span><br><span class="line">    Dep.target = this</span><br><span class="line">    //取值，把观察者和数据联系起来</span><br><span class="line">    <span class="built_in">let</span> value = CompileUtil.getVal(this.vm,this.expr)</span><br><span class="line">    Dep.target = null;</span><br><span class="line">    <span class="built_in">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">update</span></span>() &#123;</span><br><span class="line">    //更新操作，数据变化后会调用观察者update方法</span><br><span class="line">    <span class="built_in">let</span> newVal = CompileUtil.getVal(this.vm, this.expr);</span><br><span class="line">    <span class="keyword">if</span> (newVal !== this.oldValue) &#123;</span><br><span class="line">      this.cb(newVal);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将data里的所有属性包括对象里的属性劫持</span></span><br><span class="line">class Observer &#123;</span><br><span class="line">  constructor(data) &#123;</span><br><span class="line">    this.observer(data);</span><br><span class="line">  &#125;</span><br><span class="line">  observer(data) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data &amp;&amp; typeof data == <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">        this.defineReactive(data, key, data[key]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  defineReactive(obj, key, value) &#123;</span><br><span class="line">    //value还是对象的话要继续,才会给全部都赋予get和<span class="built_in">set</span>方法</span><br><span class="line">    this.observer(value);</span><br><span class="line">    <span class="built_in">let</span> dep = new Dep(); //给每个属性都加上一个发布订阅功能</span><br><span class="line">    Object.defineProperty(obj, key, &#123;</span><br><span class="line">      <span class="function"><span class="title">get</span></span>() &#123;</span><br><span class="line">        //创建watcher时候，会取到对应内容，并且把watcher放到全局上</span><br><span class="line">        Dep.target &amp;&amp; dep.addSub(Dep.target);</span><br><span class="line">        <span class="built_in">return</span> value;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="built_in">set</span>(newVal) &#123;</span><br><span class="line">        //若赋值的是一个对象，还需要继续监控</span><br><span class="line">        <span class="keyword">if</span> (newVal != value) &#123;</span><br><span class="line">          this.observer(newVal);</span><br><span class="line">          value = newVal;</span><br><span class="line">          dep.notify();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">class Compiler &#123;</span><br><span class="line">  constructor(el, vm) &#123;</span><br><span class="line">    //判断el属性</span><br><span class="line">    this.el = this.isElementNode(el) ? el : document.querySelector(el);</span><br><span class="line">    this.vm = vm;</span><br><span class="line">    //把当前节点中的元素获取到，并放到内存中</span><br><span class="line">    <span class="built_in">let</span> fragment = this.node2fragment(this.el);</span><br><span class="line">    //把节点中内容进行替换</span><br><span class="line"></span><br><span class="line">    //编译模板，用数据编译</span><br><span class="line">    this.compile(fragment);</span><br><span class="line">    //把内容塞回页面</span><br><span class="line">    this.el.appendChild(fragment);</span><br><span class="line">  &#125;</span><br><span class="line">  //判断是不是指令</span><br><span class="line">  isDirective(attrName) &#123;</span><br><span class="line">    <span class="built_in">return</span> attrName.startsWith(<span class="string">&quot;v-&quot;</span>); //开头</span><br><span class="line">  &#125;</span><br><span class="line">//编译元素的方法</span><br><span class="line">  compileElement(node) &#123;</span><br><span class="line">    <span class="built_in">let</span> attributes = node.attributes; //类数组</span><br><span class="line">    [...attributes].forEach((attr) =&gt; &#123;</span><br><span class="line">      <span class="built_in">let</span> &#123; name, value: <span class="built_in">expr</span> &#125; = attr;</span><br><span class="line">      <span class="keyword">if</span> (this.isDirective(name)) &#123;</span><br><span class="line">        //v-model v-html v-bind</span><br><span class="line">        <span class="built_in">let</span> [, directive] = name.split(<span class="string">&quot;-&quot;</span>); //v-on:click</span><br><span class="line">        <span class="built_in">let</span> [directiveName, eventName] = directive.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">        //调用不同指令来处理</span><br><span class="line">        CompileUtil[directiveName](node, <span class="built_in">expr</span>, this.vm, eventName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Vue在初始化date数据的时候，通过对data的数据进行劫持，并</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Egg 的初步认识</title>
      <link href="/2020/07/26/Egg-%E7%9A%84%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/"/>
      <url>/2020/07/26/Egg-%E7%9A%84%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Egg-js-是什么"><a href="#Egg-js-是什么" class="headerlink" title="Egg.js 是什么?"></a>Egg.js 是什么?</h1><p>Egg.js 为企业级框架和应用而生，我们希望由 Egg.js 孕育出更多上层框架，帮助开发团队和开发人员降低开发和维护成本。<br>通过 Egg，团队的架构师和技术负责人可以非常容易地基于自身的技术架构在 Egg 基础上扩展出适合自身业务场景的框架。<br>Egg 的插件机制有很高的可扩展性，一个插件只做一件事（比如 Nunjucks 模板封装成了 egg-view-nunjucks、MySQL 数据库封装成了 egg-mysql）。Egg 通过框架聚合这些插件，并根据自己的业务场景定制配置，这样应用的开发成本就变得很低。</p><p>优势：</p><ul><li>Egg 奉行『约定优于配置』，按照一套统一的约定进行应用开发，减少开发人员的学习成本，</li><li>没有约定的团队，沟通成本是非常高的，比如有人会按目录分栈而其他人按目录分功能<br>特性： </li><li>提供基于 Egg 定制上层框架的能力</li><li>高度可扩展的插件机制</li><li>内置多进程管理</li><li>基于 Koa 开发，性能优异</li><li>框架稳定，测试覆盖率高</li><li>渐进式开发</li></ul><h1 id="主要约定文件目录"><a href="#主要约定文件目录" class="headerlink" title="主要约定文件目录"></a>主要约定文件目录</h1><ul><li>config 配置</li><li>middleware</li><li>Router</li><li>Controller</li><li>service</li></ul><h1 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h1><ul><li>Application</li><li>Context</li><li>Request &amp; Response</li><li>Controller（类）</li><li>Service</li><li>Helper</li><li>Config</li><li>Logger</li><li>Subscription</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>express 是基于nodejs开发的框架，但是会产生很多callback（回调地狱）<br>为了解决callback，koa支持async await的方式<br>而egg则基于koa集成多种内置对象，以及各种约定，让多人协作开发更友好，还可以安装各种各样的插件来实现想要功能</p>]]></content>
      
      
      <categories>
          
          <category> Node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Egg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react组件件的代码复用，以及为何弃用mixins的思考</title>
      <link href="/2020/07/17/react%E7%BB%84%E4%BB%B6%E4%BB%B6%E7%9A%84%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%BA%E4%BD%95%E5%BC%83%E7%94%A8mixins%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2020/07/17/react%E7%BB%84%E4%BB%B6%E4%BB%B6%E7%9A%84%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%BA%E4%BD%95%E5%BC%83%E7%94%A8mixins%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h1 id="为何弃用mixins，故事背景"><a href="#为何弃用mixins，故事背景" class="headerlink" title="为何弃用mixins，故事背景"></a>为何弃用mixins，故事背景</h1><p>“我如何在几个组件之间共享代码？” 是人们在学习 React 时首先提出的问题之一。我们的答案一直是使用组件组合来进行代码重用。您可以定义一个组件并在其他几个组件中使用它。<br>如何通过组合来解决某种模式并不总是很明显。React 受到函数式编程的影响，但它进入了由面向对象库主导的领域。<br>mixin 系统就是其中之一，它的目标是当你不确定如何用组合解决同样的问题时，它的目标是为你提供一种在组件之间重用代码的方法。<br>随着组件数量越来越多，使用 React 的一些代码逐渐变得难以理解。<br>这些组件太容易被意外破坏，让新开发人员感到困惑，最终也让最初编写它们的人感到困惑。这种混乱大部分是由 mixins 引起的。</p><p>Mixins 打破了常见且通常安全的假设，即您可以通过在组件文件中搜索其出现来重命名状态键或方法。您可能会编写一个有状态的组件，然后您的同事可能会添加一个读取此状态的 mixin。几个月后，您可能希望将该状态移至父组件，以便与兄弟姐妹共享。你会记得更新 mixin 来读取道具吗？如果现在其他组件也使用这个 mixin 怎么办？</p><p>有时候可能要修改mixin的部分功能，但是不知道在哪个地方哪个角落调用了这个方法。你不得不复制一份出来单独维护。<br>这就是mixin为何被弃用的主要原因。<br>当数量上来了，复用的功效就没那么明显，还可能是一种累赘。</p><p>每一个新的需求都会让 mixins 更难理解。随着时间的推移，使用相同 mixin 的组件变得越来越耦合。任何新功能都会被添加到使用该 mixin 的所有组件中。如果不复制代码或在 mixin 之间引入更多的依赖关系和间接性，就无法拆分 mixin 的“更简单”部分。逐渐地，封装边界被侵蚀，并且由于很难更改或删除现有的 mixin，它们变得越来越抽象，直到没有人了解它们是如何工作的。</p><h1 id="解决方案-之-高阶组件"><a href="#解决方案-之-高阶组件" class="headerlink" title="解决方案 之 高阶组件"></a>解决方案 之 高阶组件</h1><p>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式</p><p>具体而言，高阶组件是参数为组件，返回值为新组件的函数。</p><p>目的是为了数据与视图分离，所有操作数据的方法都封装在高阶组件的函数内部，视图的展示，通过传递的组件参数去表达</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 此函数接收一个组件...</span><br><span class="line"><span class="keyword">function</span> withSubscription(WrappedComponent, selectData) &#123;</span><br><span class="line">  // ...并返回另一个组件...</span><br><span class="line">  <span class="built_in">return</span> class extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">      super(props);</span><br><span class="line">      this.handleChange = this.handleChange.<span class="built_in">bind</span>(this);</span><br><span class="line">      this.state = &#123;</span><br><span class="line">        data: selectData(DataSource, props)</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span></span>() &#123;</span><br><span class="line">      // ...负责订阅相关的操作...</span><br><span class="line">      DataSource.addChangeListener(this.handleChange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentWillUnmount</span></span>() &#123;</span><br><span class="line">      DataSource.removeChangeListener(this.handleChange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">handleChange</span></span>() &#123;</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        data: selectData(DataSource, this.props)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">      // ... 并使用新数据渲染被包装的组件!</span><br><span class="line">      // 请注意，我们可能还会传递其他属性</span><br><span class="line">      <span class="built_in">return</span> &lt;WrappedComponent data=&#123;this.state.data&#125; &#123;...this.props&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HOC 不会修改传入的组件，也不会使用继承来复制其行为。相反，HOC 通过将组件包装在容器组件中来组成新组件。HOC 是纯函数，没有副作用</p><h1 id="HOC-约定：将不相关的-props-传递给被包裹的组件"><a href="#HOC-约定：将不相关的-props-传递给被包裹的组件" class="headerlink" title="HOC 约定：将不相关的 props 传递给被包裹的组件"></a>HOC 约定：将不相关的 props 传递给被包裹的组件</h1><p>HOC 为组件添加特性。自身不应该大幅改变约定。HOC 返回的组件与原组件应保持类似的接口。<br>HOC 应该透传与自身无关的 props。大多数 HOC 都应该包含一个类似于下面的 render 方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">  // 过滤掉非此 HOC 额外的 props，且不要进行透传</span><br><span class="line">  const &#123; extraProp, ...passThroughProps &#125; = this.props;</span><br><span class="line"></span><br><span class="line">  // 将 props 注入到被包装的组件中。</span><br><span class="line">  // 通常为 state 的值或者实例方法。</span><br><span class="line">  const injectedProp = someStateOrInstanceMethod;</span><br><span class="line"></span><br><span class="line">  // 将 props 传递给被包装组件</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    &lt;WrappedComponent</span><br><span class="line">      injectedProp=&#123;injectedProp&#125;</span><br><span class="line">      &#123;...passThroughProps&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="HOC约定：最大化可组合性"><a href="#HOC约定：最大化可组合性" class="headerlink" title="HOC约定：最大化可组合性"></a>HOC约定：最大化可组合性</h1><p>并不是所有的 HOC 都一样。有时候它仅接受一个参数，也就是被包裹的组件：<br>const NavbarWithRouter &#x3D; withRouter(Navbar);</p><p>HOC 通常可以接收多个参数。比如在 Relay 中，HOC 额外接收了一个配置对象用于指定组件的数据依赖：<br>const CommentWithRelay &#x3D; Relay.createContainer(Comment, config);</p><p>甚至可能是返回高阶组件的高阶函数！！！<br>&#x2F;&#x2F; React Redux 的 <code>connect</code> 函数<br>const ConnectedComment &#x3D; connect(commentSelector, commentActions)(CommentList);</p><p>类似于函数柯里化<br>把函数的参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> createCurry = (fn,...params)=&gt;&#123;</span><br><span class="line">  <span class="built_in">let</span> args = params || []</span><br><span class="line">  <span class="built_in">let</span> fnLen = fn.length</span><br><span class="line">  <span class="built_in">return</span> (...res)=&gt;&#123;</span><br><span class="line">    <span class="built_in">let</span> allArgs = args.slice(0)</span><br><span class="line">    allArgs.push(...res)</span><br><span class="line">    <span class="keyword">if</span>(allArgs.length &lt; fnLen&gt;)&#123;</span><br><span class="line">      <span class="built_in">return</span> createCurry.call(this,fn,...allArgs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">return</span> fn.apply(this,allArgs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul><li><p>不要在 render 方法中使用 HOC<br>React 的 diff 算法使用组件标识来确定它是应该更新现有子树还是将其丢弃并挂载新子树。 如果从 render 返回的组件与前一个渲染中的组件相同（&#x3D;&#x3D;&#x3D;），则 React 通过将子树与新子树进行区分来递归更新子树。 如果它们不相等，则完全卸载前一个子树。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">  // 每次调用 render 函数都会创建一个新的 EnhancedComponent</span><br><span class="line">  // EnhancedComponent1 !== EnhancedComponent2</span><br><span class="line">  const EnhancedComponent = enhance(MyComponent);</span><br><span class="line">  // 这将导致子树每次渲染都会进行卸载，和重新挂载的操作！</span><br><span class="line">  <span class="built_in">return</span> &lt;EnhancedComponent /&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在每次render时都会重新创建，重新挂载组件会导致该组件及其所有子组件的状态丢失。<br>如果在组件之外创建 HOC，这样一来组件只会创建一次。因此，每次 render 时都会是同一个组件。<br>在极少数情况下，你需要动态调用 HOC。你可以在组件的生命周期方法或其构造函数中进行调用。</p></li><li><p>务必复制静态方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 定义静态函数</span><br><span class="line">WrappedComponent.staticMethod = <span class="function"><span class="title">function</span></span>() &#123;/*...*/&#125;</span><br><span class="line">// 现在使用 HOC</span><br><span class="line">const EnhancedComponent = enhance(WrappedComponent);</span><br><span class="line"></span><br><span class="line">// 增强组件没有 staticMethod</span><br><span class="line">typeof EnhancedComponent.staticMethod === <span class="string">&#x27;undefined&#x27;</span> // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 传入组件的静态方法会随着被高阶组件聚合而丢失</span></span><br><span class="line"><span class="comment"># 可以通过在高阶组件内部复制一份</span></span><br><span class="line"><span class="keyword">function</span> enhance(WrappedComponent) &#123;</span><br><span class="line">  class Enhance extends React.Component &#123;/*...*/&#125;</span><br><span class="line">  // 必须准确知道应该拷贝哪些方法 :(</span><br><span class="line">  Enhance.staticMethod = WrappedComponent.staticMethod;</span><br><span class="line">  <span class="built_in">return</span> Enhance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 借用第三方库，无感拷贝 hoist-non-react-statics 自动拷贝所有非 React 静态方法:</span></span><br><span class="line"></span><br><span class="line">import hoistNonReactStatic from <span class="string">&#x27;hoist-non-react-statics&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> enhance(WrappedComponent) &#123;</span><br><span class="line">  class Enhance extends React.Component &#123;/*...*/&#125;</span><br><span class="line"></span><br><span class="line">  hoistNonReactStatic(Enhance, WrappedComponent);</span><br><span class="line">  <span class="built_in">return</span> Enhance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>Refs 不会被传递<br>那是因为 ref 实际上并不是一个 prop，它就像 key 一样，是由 React 专门处理的。如果将 ref 添加到 HOC 的返回组件中，则 ref 引用指向容器组件，而不是被包装组件。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mixins react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react基于content实现全局变量的方法</title>
      <link href="/2020/05/16/react%E5%9F%BA%E4%BA%8Econtext%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2020/05/16/react%E5%9F%BA%E4%BA%8Econtext%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="先生成一个context-js"><a href="#先生成一个context-js" class="headerlink" title="先生成一个context.js"></a>先生成一个context.js</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import React from <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="built_in">export</span> const fontSize = &#123;</span><br><span class="line">  small: <span class="string">&#x27;12px&#x27;</span>,</span><br><span class="line">  big: <span class="string">&#x27;36px&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">export</span> const ThemeContext = React.createContext(&#123;</span><br><span class="line">  fontSize: fontSize.small,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="创建一个组件-App-js-并导入context"><a href="#创建一个组件-App-js-并导入context" class="headerlink" title="创建一个组件 App.js,并导入context"></a>创建一个组件 App.js,并导入context</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import React from <span class="string">&#x27;react&#x27;</span></span><br><span class="line">import &#123; ThemeContext,fontSize&#125; from <span class="string">&#x27;./context&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个顶级组件,将context的变量同步到state，通过修改state去更新子组件的视图</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  constructor(props)&#123;</span><br><span class="line">    super(props)</span><br><span class="line">    // 该方法可以封装在fontSize对象里面，通过<span class="built_in">bind</span>(this)挂载到state上面</span><br><span class="line">    this.handleFontSize = () =&gt; &#123;</span><br><span class="line">      this.setState(state =&gt; (&#123;</span><br><span class="line">        fontSize: state.fontSize === fontSize.small</span><br><span class="line">            ? fontSize.big</span><br><span class="line">            : fontSize.small,</span><br><span class="line">      &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    // State 也包含了更新函数，因此它会被传递进 context provider。</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      fontSize: fontSize.small,</span><br><span class="line">      handleFontSize: this.handleFontSize,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment"># 通过 ThemeContext.Provider 将该state往里面的组件传递</span></span><br><span class="line">  <span class="function"><span class="title">render</span></span>()&#123;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">       &lt;ThemeContext.Provider value=&#123;this.state&#125;&gt;</span><br><span class="line">          &lt;div&gt;</span><br><span class="line">            &lt;ChangeFontSizeBtn /&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">        &lt;/ThemeContext.Provider&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义使用该全局变量的组件 ChangeFontSizeBtn</span></span><br><span class="line"><span class="comment"># 通过 &lt;ThemeContext.Consumer&gt; &#123;(state)=&gt;()&#125;&lt;/ThemeContext.Consumer&gt;组件获取该state</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">ChangeFontSizeBtn</span></span>()&#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    &lt;ThemeContext.Consumer&gt;</span><br><span class="line">      &#123;(&#123;fontSize,handleFontSize&#125;)=&gt;(</span><br><span class="line">        &lt;button</span><br><span class="line">          onClick=&#123;handleFontSize&#125;</span><br><span class="line">          style=&#123;&#123;fontSize: fontSize&#125;&#125;  </span><br><span class="line">        &gt;</span><br><span class="line">          change</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/ThemeContext.Consumer&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最终完成某层子组件修改全局变量的方法</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>定义一个context对象，通过React.creatContext({fontSize: ‘12px’})暴露出来</li><li>在全局组件中引入该context，用state去同步context对象的数据，并创建一个修改数据的方法</li><li>定义一个ThemeContext.Provider组件可以，并将state作为value的值传递进去 &lt;ThemeContext.Provider value&#x3D;{this.state}&gt;&lt;&#x2F;ThemeContext.Provider&gt;</li><li>在某个需要修改该数据的组件中，通过ThemeContext.Consumer去获取state的数据 &lt;ThemeContext.Consumer&gt; {(state)&#x3D;&gt;()}&lt;&#x2F;ThemeContext.Consumer&gt;</li></ul>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue Diff算法详解</title>
      <link href="/2020/04/27/Diff%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/04/27/Diff%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="vue2-递归-双指针"><a href="#vue2-递归-双指针" class="headerlink" title="vue2: 递归+双指针"></a>vue2: 递归+双指针</h1><ul><li>判断是否是同一个元素<br>不是同一个元素，直接替换<br>是同一个元素-》比对属性-》比对下级</li></ul><ol><li>旧的有下级，新的没有 直接删除</li><li>新的有下级，旧的没有 直接插入</li><li>是文本的情况 直接插入</li><li>都有下级 双指针比较，对比查找之后复用</li></ol><h1 id="vue3：-采用最长递增子序列"><a href="#vue3：-采用最长递增子序列" class="headerlink" title="vue3： 采用最长递增子序列"></a>vue3： 采用最长递增子序列</h1>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redux 手记</title>
      <link href="/2020/04/14/Redux-%E6%89%8B%E8%AE%B0/"/>
      <url>/2020/04/14/Redux-%E6%89%8B%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Redux"><a href="#什么是Redux" class="headerlink" title="什么是Redux"></a>什么是Redux</h1><p>Redux 是 JavaScript 状态容器，提供可预测化的状态管理<br>可以让你构建一致化的应用，运行于不同的环境（客户端、服务器、原生应用），并且易于测试。</p><h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先用一个普通的对象来描述 state</span></span><br><span class="line">&#123;</span><br><span class="line">  visibilityFilter: <span class="string">&#x27;SHOW_COMPLETED&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 想要更新state中的数据，你需要发起一个action（Action 就是一个普通 JavaScript 对象）</span></span><br><span class="line">&#123; <span class="built_in">type</span>: <span class="string">&#x27;SET_VISIBILITY_FILTER&#x27;</span>, filter: <span class="string">&#x27;SHOW_ALL&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此刻的action 和 state 并没有任何关联。reducer 可以一个接收 state 和 action，并返回新的 state 的函数。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> visibilityFilter(state = <span class="string">&#x27;SHOW_ALL&#x27;</span>, action) &#123;</span><br><span class="line">  <span class="keyword">if</span> (action.type === <span class="string">&#x27;SET_VISIBILITY_FILTER&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">return</span> action.filter;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="三大原则"><a href="#三大原则" class="headerlink" title="三大原则"></a>三大原则</h1><ul><li>单一数据源 整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。</li><li>State 是只读的。 唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。</li><li>使用纯函数来执行修改。 为了描述 action 如何改变 state tree ，你需要编写reducers。</li></ul>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP 详解</title>
      <link href="/2020/04/14/TCP-IP-%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/04/14/TCP-IP-%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-TCP-和-UDP"><a href="#1-TCP-和-UDP" class="headerlink" title="1. TCP 和 UDP"></a>1. TCP 和 UDP</h1><h3 id="用户数据报协议-UDP"><a href="#用户数据报协议-UDP" class="headerlink" title="用户数据报协议 UDP"></a>用户数据报协议 UDP</h3><ul><li>UDP 在传送数据之前不需要先建立连接，远程主机在收到 UDP 报文后，不需要给出任何确认。</li><li>虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如：QQ 语音、 QQ 视频 、直播等等</li></ul><h1 id="2-传输控制协议-TCP"><a href="#2-传输控制协议-TCP" class="headerlink" title="2.传输控制协议 TCP"></a>2.传输控制协议 TCP</h1><ul><li>TCP 提供 面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。</li><li>TCP 不提供广播或多播服务。由于 TCP 要提供 可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、流量控制、拥塞控制机制，在数据传完后，还会四次挥手断开连接用来节约系统资源），这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源</li><li>TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</li></ul><h1 id="TCP-三次握手建立连接"><a href="#TCP-三次握手建立连接" class="headerlink" title="TCP 三次握手建立连接"></a>TCP 三次握手建立连接</h1><ul><li><ol><li>第一次握手：客户端向服务端发送一个 SYN 报文（SYN &#x3D; 1），此时客户端处于 SYN_Send 状态（在发送连接请求后等待匹配的连接请求）。</li></ol></li><li><ol start="2"><li>第二次握手：服务器收到客户端的 SYN 报文之后，会发送 ACK 通知客户端我已收到。 此时服务器处于 SYN_REVD 的状态（收到和发送一个连接请求后等待对连接请求的确认）。</li></ol></li><li><ol start="3"><li>客户端收到服务器端响应的 ACK 报文之后，会发送一个 ack 报文，，表示已经收到了服务端发来的通知，此时客户端处于 Establised 状态。服务器收到 ack 报文之后，也处于 Establised 状态（代表一个打开的连接，数据可以传送给用户），至此，双方建立起了 TCP 连接。</li></ol></li></ul><h1 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h1><p>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</p><h1 id="三次握手过程中可以携带数据吗"><a href="#三次握手过程中可以携带数据吗" class="headerlink" title="三次握手过程中可以携带数据吗"></a>三次握手过程中可以携带数据吗</h1><p>第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手绝对不可以携带数据假如第一次握手可以携带数据的话，容易被攻击。<br>SYN 洪泛攻击<br>就是 Client 在短时间内伪造大量不存在的 IP 地址，并向 Server 不断地发送 SYN 包，Server 则回复确认包，并等待 Client 确认，由于源地址不存在，因此 Server 需要不断重发直至超时，这些伪造的 SYN 包将长时间占用半连接队列，导致正常的 SYN 请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。</p><h1 id="TCP-四次挥手释放连接"><a href="#TCP-四次挥手释放连接" class="headerlink" title="TCP 四次挥手释放连接"></a>TCP 四次挥手释放连接</h1><p>建立一个 TCP 连接需要三次握手，而终止一个 TCP 连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这是由于 TCP 的半关闭（half-close）特性造成的，TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p><ul><li>第一次挥手：客户端发送一个 FIN 报文主动关闭 TCP 连接。此时客户端处于 FIN_WAIT1 状态（等待远程TCP的连接中断请求，或先前的连接中断请求的确认；），等待服务端的确认。</li><li>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态（等待从本地用户发来的连接中断请求）。</li></ul><h2 id="此时的-TCP-处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN-WAIT2（终止等待-2）状态，等待服务端发出的连接释放报文段。"><a href="#此时的-TCP-处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN-WAIT2（终止等待-2）状态，等待服务端发出的连接释放报文段。" class="headerlink" title="此时的 TCP 处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待 2）状态，等待服务端发出的连接释放报文段。"></a>此时的 TCP 处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待 2）状态，等待服务端发出的连接释放报文段。</h2><ul><li>第三次挥手：如果服务端也想断开连接了（没有要向客户端发出的数据），和客户端的第一次挥手一样，发送 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态，等待客户端的确认</li><li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答（ack &#x3D; w+1），且把服务端的序列值 +1 作为自己 ACK 报文的序号值（seq&#x3D;u+1），此时客户端处于 TIME_WAIT（时间等待）状态。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>三次握手，为了测试双方能够正常发送，接收<br>第一次握手： 客户端发送SYN服务器 ，服务器正常接受   客户端发送正常 服务器接收正常<br>第二次握手： 服务器发送ACK到客户端，客户端正常接受  服务器发送正常 客户端接收正常<br>第三次握手： 客户端向服务器发送正式链接，至此，双方建立起了 TCP 连接</p><p>四次挥手，因为TCP半关闭的特性<br>TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。<br>A 和 B 打电话，通话即将结束后，A 说 “我没啥要说的了”，B 回答 “我知道了”，于是 A 向 B 的连接释放了。但是 B 可能还会有要说的话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，于是 B 向 A 的连接释放了，</p>]]></content>
      
      
      <categories>
          
          <category> Http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue v-model的实践</title>
      <link href="/2020/04/13/Vue-v-model%E7%9A%84%E5%AE%9E%E8%B7%B5/"/>
      <url>/2020/04/13/Vue-v-model%E7%9A%84%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue-v-model的实践"><a href="#Vue-v-model的实践" class="headerlink" title="Vue v-model的实践"></a>Vue v-model的实践</h1><p>v-model 只是语法糖，主要是通过input事件来触发input标签value值来实现我们说的“双向数据绑定”,其实它还是单向数据流。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;value&quot;</span> /&gt;</span><br><span class="line"><span class="comment">#等价于</span></span><br><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">&quot;text&quot;</span> :value=<span class="string">&quot;value&quot;</span> @input=v=&gt;<span class="variable">$emit</span>(<span class="string">&#x27;input&#x27;</span>, v)/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义组件实现v-model</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">&quot;text&quot;</span> :value=<span class="string">&quot;value&quot;</span> @input=<span class="string">&quot;handleInput&quot;</span> :placeholder=<span class="string">&quot;placehodler&quot;</span> /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="built_in">export</span> default &#123;</span><br><span class="line">    name: <span class="string">&#x27;kInput&#x27;</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">        value: [<span class="string">&#x27;String&#x27;</span>, <span class="string">&#x27;Number&#x27;</span>],</span><br><span class="line">        placeholder: String</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        handleInput(<span class="variable">$event</span>) &#123;</span><br><span class="line">            // 通过input标签的原生事件input将值emit出去，以达到值得改变实现双向绑定</span><br><span class="line">            this.<span class="variable">$emit</span>(<span class="string">&#x27;input&#x27;</span>, <span class="variable">$event</span>.target.value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue v-model </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>reactAPI全局props</title>
      <link href="/2020/04/07/reactAPI%E5%85%A8%E5%B1%80props/"/>
      <url>/2020/04/07/reactAPI%E5%85%A8%E5%B1%80props/</url>
      
        <content type="html"><![CDATA[<h1 id="createContext"><a href="#createContext" class="headerlink" title="createContext"></a>createContext</h1><p>Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用传统props蹈入props</span></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &lt;Toolbar theme=<span class="string">&quot;dark&quot;</span> /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> Toolbar(props) &#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ThemedButton theme=&#123;props.theme&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ThemedButton extends React.Component &#123;</span><br><span class="line">  <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &lt;Button theme=&#123;this.props.theme&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># ---------------------------------------------------</span></span><br><span class="line"><span class="comment"># 使用 context, 我们可以避免通过中间元素传递 props：</span></span><br><span class="line"><span class="comment"># 为当前的 theme 创建一个 context（“light”为默认值）。</span></span><br><span class="line">const ThemeContext = React.createContext(<span class="string">&#x27;light&#x27;</span>);</span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">    // 使用一个 Provider 来将当前的 theme 传递给以下的组件树。</span><br><span class="line">    // 无论多深，任何组件都能读取这个值。</span><br><span class="line">    // 在这个例子中，我们将 “dark” 作为当前的值传递下去。</span><br><span class="line">    <span class="built_in">return</span> (</span><br><span class="line">      &lt;ThemeContext.Provider value=<span class="string">&quot;dark&quot;</span>&gt;</span><br><span class="line">        &lt;Toolbar /&gt;</span><br><span class="line">      &lt;/ThemeContext.Provider&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 中间的组件再也不必指明往下传递 theme 了。</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Toolbar</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ThemedButton /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">class ThemedButton extends React.Component &#123;</span><br><span class="line">  // 指定 contextType 读取当前的 theme context。</span><br><span class="line">  // React 会往上找到最近的 theme Provider，然后使用它的值。</span><br><span class="line">  // 在这个例子中，当前的 theme 值为 “dark”。</span><br><span class="line">  static contextType = ThemeContext;</span><br><span class="line">  <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &lt;Button theme=&#123;this.context&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react Context </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 设置深度属性</title>
      <link href="/2019/08/24/Vue-%E8%AE%BE%E7%BD%AE%E6%B7%B1%E5%BA%A6%E5%B1%9E%E6%80%A7/"/>
      <url>/2019/08/24/Vue-%E8%AE%BE%E7%BD%AE%E6%B7%B1%E5%BA%A6%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="set的使用原理"><a href="#set的使用原理" class="headerlink" title="$set的使用原理"></a>$set的使用原理</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="built_in">set</span>(target,key,val)&#123;</span><br><span class="line">  <span class="comment"># 先进行一个判断，判断target不是undefined、null、string、number、symbol、boolean类型。</span></span><br><span class="line">  <span class="comment"># 是的话就抛出异常</span></span><br><span class="line">  <span class="keyword">if</span>(isUndef(target) || isPrimitive(target)) &#123;</span><br><span class="line">    warn(...)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment"># 如果target是一个数组，那么根据key值及数组长度更改数组的长度(取其中较大者)，然后直接使用splice函数修改数组，虽然vue没有监听数组变化，但是监听了数组的push,pop,shift,unshift,splice,sort,reverse函数，所以使用splice也可以达到更新dom的目的</span></span><br><span class="line">  <span class="keyword">if</span>(Array.isArray(target) &amp;&amp; isValidArrayIndex(key))&#123;</span><br><span class="line">    target.length = Math.max(target.length,key)</span><br><span class="line">    target.splice(key,1,val)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment"># 如果target是一个对象，且key是对象已存在的私有属性，那么直接赋值就可以了，因为这个key必然是被监听过的</span></span><br><span class="line">  <span class="keyword">if</span>(key <span class="keyword">in</span> target &amp;&amp; !(key <span class="keyword">in</span> Object.prototype))&#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="built_in">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment"># 如果这个key目前没有存在于对象中，那么会进行赋值并监听。这里省略了ob的判断，那么ob是什么呢，vue中初始化的数据(比如data中的数据)在页面初始化的时候都会被监听，而被监听的属性都会被绑定__ob__属性，这里就是判断这个数据有没有被监听的。如果这个数据没有被监听，那么就默认你不想监听这个数据，所以直接赋值并返回</span></span><br><span class="line">  var ob = (target)._ob_</span><br><span class="line">  <span class="keyword">if</span>(target._isVue || (ob &amp;&amp; ob.vmCount))&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!ob)&#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="built_in">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  defineReactive(ob.value,key,val)</span><br><span class="line">  ob.dep.notify()</span><br><span class="line">  <span class="built_in">return</span> val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 已经定义的对象属性会在初始化的时候监听</span></span><br><span class="line"><span class="function"><span class="title">data</span></span>()&#123;</span><br><span class="line">  <span class="built_in">return</span> &#123;</span><br><span class="line">    visit: &#123;</span><br><span class="line">      name: <span class="string">&#x27;already&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 通过handleVal添加的属性是没有被监听的</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  <span class="function"><span class="title">handleVal</span></span>()&#123;</span><br><span class="line">    this.visit.addVal = <span class="string">&#x27;noVisit&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 除非在把data修改为</span></span><br><span class="line"><span class="function"><span class="title">data</span></span>()&#123;</span><br><span class="line">  <span class="built_in">return</span> &#123;</span><br><span class="line">    visit: &#123;</span><br><span class="line">      name: <span class="string">&#x27;already&#x27;</span>，</span><br><span class="line">      addVal: null,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 又或者通$set设置</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  <span class="function"><span class="title">handleVal</span></span>()&#123;</span><br><span class="line">    this.<span class="variable">$set</span>(<span class="string">&#x27;visit&#x27;</span>,<span class="string">&#x27;addVal&#x27;</span>,<span class="string">&#x27;noVisit&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> $set </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Ant Design 的使用</title>
      <link href="/2019/08/21/React-Ant-Design-%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/08/21/React-Ant-Design-%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在项目根目录 执行</span></span><br><span class="line">yarn add antd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在入口文件index.js 全局引入css 一般是 ./src/index.js</span></span><br><span class="line">import <span class="string">&#x27;antd/dist/antd.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#在某个页面局部导入需要使用的组件</span></span><br><span class="line">import &#123; DatePicker &#125; from <span class="string">&#x27;antd&#x27;</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;DatePicker /&gt;, mountNode);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AntDesign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>首屏白屏问题</title>
      <link href="/2019/06/25/%E9%A6%96%E5%B1%8F%E7%99%BD%E5%B1%8F%E9%97%AE%E9%A2%98/"/>
      <url>/2019/06/25/%E9%A6%96%E5%B1%8F%E7%99%BD%E5%B1%8F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="白屏原因"><a href="#白屏原因" class="headerlink" title="白屏原因"></a>白屏原因</h1><ul><li>js&#x2F;css依赖包过于庞大，导致spa应用首次进入页面白屏</li><li>浏览器兼容问题，vue代码在ie中显示白屏</li><li>URL 网址无效或者含有中文字符</li><li>缓存导致 vue项目打包后，在非首次线上替换dist文件时，某些手机&#x2F;浏览器在之后首次打开页面，可能出现白屏情况</li></ul><h1 id="js-x2F-css依赖包过于庞大，导致spa应用首次进入页面白屏"><a href="#js-x2F-css依赖包过于庞大，导致spa应用首次进入页面白屏" class="headerlink" title="js&#x2F;css依赖包过于庞大，导致spa应用首次进入页面白屏"></a>js&#x2F;css依赖包过于庞大，导致spa应用首次进入页面白屏</h1><p>这个就是要做首屏优化 请求优化</p><ul><li>js，css分包加载</li><li>大型插件依赖用cdn链接的方式</li><li>请求gzip压缩</li></ul><p>代码层优化</p><ul><li>路由按需加载 </li><li>webpack 启用摇树优化</li><li>图片懒加载 lazy<br>…</li></ul><h1 id="缓存导致-vue项目打包后，在非首次线上替换dist文件时，某些手机-x2F-浏览器在之后首次打开页面，可能出现白屏情况"><a href="#缓存导致-vue项目打包后，在非首次线上替换dist文件时，某些手机-x2F-浏览器在之后首次打开页面，可能出现白屏情况" class="headerlink" title="缓存导致 vue项目打包后，在非首次线上替换dist文件时，某些手机&#x2F;浏览器在之后首次打开页面，可能出现白屏情况"></a>缓存导致 vue项目打包后，在非首次线上替换dist文件时，某些手机&#x2F;浏览器在之后首次打开页面，可能出现白屏情况</h1><p>客户端: 解决方案一般是强制刷新页面或者清除缓存重新加载。<br>服务端：直接在网站后台清除缓存。或者链接服务器，去清理缓存文件</p><p>原因：在用户端会默认缓存index.html入口文件，而由于vue打包生成的css&#x2F;js都是哈希值，跟上次的文件名都不同，因此会出现找不到css&#x2F;js的情况，导致白屏的产生。在服务端更新包之后，由于旧的文件被删除，而index.html所链接的路径依然是旧文件路径，因此会找不到文件，从而白屏。</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JS微任务和宏任务的执行顺序</title>
      <link href="/2019/06/14/JS%E5%BE%AE%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%AE%8F%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
      <url>/2019/06/14/JS%E5%BE%AE%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%AE%8F%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>浏览器是多线程的，JS是单线程的（浏览器只分配一个线程来执行JS）意味着js每次只能执行一个任务，那么，遇到异步任务首先会放到任务队列中（执行栈），先执行主线程中的任务，当主线程中的任务被执行完后，在回过来依次将执行任务队列中任务放入主线程去执行。</p><p>js中的任务分为：同步任务和异步任务，而异步任务又可以分为微任务和宏任务</p><p>宏任务：macro task</p><ul><li>定时器(setTimeout,setInterval,setImmediate)</li><li>事件绑定(onClick)</li><li>ajax</li><li>回调函数    </li><li>nodejs中的fs I&#x2F;O操作</li></ul><p>微任务: micro task</p><ul><li>Promsie(async&#x2F;await)</li><li>process.nextTick</li><li>MutationObserver</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">asy1</span></span>()&#123;</span><br><span class="line">  await console.log(<span class="string">&#x27;asy1&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">console.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">  console.log(<span class="string">&#x27;time out&#x27;</span>)</span><br><span class="line">&#125;,0)</span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">  setTimeout(()=&gt;&#123;</span><br><span class="line">    console.log(<span class="string">&#x27;宏任务中的宏任务&#x27;</span>)</span><br><span class="line">  &#125;,0)</span><br><span class="line">  Promise.resolve().<span class="keyword">then</span>(()=&gt;&#123;</span><br><span class="line">    console.log(<span class="string">&#x27;timeOut+promise1&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  console.log(<span class="string">&#x27;timeOut+promise1之前还是之后&#x27;</span>)</span><br><span class="line">&#125;,0)</span><br><span class="line"></span><br><span class="line">asy1()</span><br><span class="line">Promise.resolve().<span class="keyword">then</span>(()=&gt;&#123;</span><br><span class="line">  console.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">&#125;).<span class="keyword">then</span>(()=&gt;&#123;</span><br><span class="line">  Promise.resolve().<span class="keyword">then</span>(()=&gt;&#123;</span><br><span class="line">    console.log(<span class="string">&#x27;promise1+promise1&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  setTimeout(()=&gt;&#123;</span><br><span class="line">    console.log(<span class="string">&#x27;promise time out&#x27;</span>)</span><br><span class="line">  &#125;,0)</span><br><span class="line">  console.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># script start</span></span><br><span class="line"><span class="comment"># asy1</span></span><br><span class="line"><span class="comment"># script end</span></span><br><span class="line"><span class="comment"># promise1</span></span><br><span class="line"><span class="comment"># promise2</span></span><br><span class="line"><span class="comment"># promise1+promise1</span></span><br><span class="line"><span class="comment"># time out</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先执行微任务，执行完所有微任务之后（微任务中产生的微任务也要执行完），再执行宏任务，（宏任务中产生的微任务要优先执行）</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微任务 宏任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器重排和重绘</title>
      <link href="/2019/05/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8D%E6%8E%92%E5%92%8C%E9%87%8D%E7%BB%98/"/>
      <url>/2019/05/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8D%E6%8E%92%E5%92%8C%E9%87%8D%E7%BB%98/</url>
      
        <content type="html"><![CDATA[<h1 id="重排和重绘区别"><a href="#重排和重绘区别" class="headerlink" title="重排和重绘区别"></a>重排和重绘区别</h1><p>重排顾名思义就是重新排列，意味着重新计算文档中元素的位置和几何信息（元素的位置、大小），会影响部分或整个页面的布局。元素的重排将导致DOM中所有子元素和其他兄弟元素重新排列。<br>重绘是更改元素的可见性，但是不影响元素的布局。例如可见性、背景色、轮廓等。</p><h1 id="什么会触发重排和重绘？"><a href="#什么会触发重排和重绘？" class="headerlink" title="什么会触发重排和重绘？"></a>什么会触发重排和重绘？</h1><ul><li>添加、删除、更新DOM节点都会触发重排</li><li>使用 display: none 隐藏元素会触发重排和重绘</li><li>使用 visibility:hidden 只会引起重绘，因为没有布局和位置的变更</li><li>移动节点、添加动画都会触发重排和重绘</li><li>改变浏览器窗口大小会触发重排</li><li>更改元素字体大小会触发重排</li><li>添加或者删除样式会触发重排和重绘</li><li>操作 DOM 脚本是昂贵的操作，因为每次 document 或者 document的部分改变时，它们都会重新计算</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var bodyStyle = document.body.style; // cache</span><br><span class="line"></span><br><span class="line">bodyStyle.padding = <span class="string">&quot;20px&quot;</span>; // reflow, repaint</span><br><span class="line">bodyStyle.border = <span class="string">&quot;10px solid red&quot;</span>; // reflow, repaint</span><br><span class="line"></span><br><span class="line">bodyStyle.color = <span class="string">&quot;blue&quot;</span>; // repaint only, no dimensions changed</span><br><span class="line">bstyle.backgroundColor = <span class="string">&quot;#cc0000&quot;</span>; // repaint</span><br><span class="line"></span><br><span class="line">bodyStyle.fontSize = <span class="string">&quot;2em&quot;</span>; // reflow, repaint</span><br><span class="line"></span><br><span class="line">// new DOM element - reflow, repaint</span><br><span class="line">document.body.appendChild(document.createTextNode(<span class="string">&#x27;Hello!&#x27;</span>));</span><br></pre></td></tr></table></figure><h1 id="重排一定触发重绘，重绘不一定触发重排"><a href="#重排一定触发重绘，重绘不一定触发重排" class="headerlink" title="重排一定触发重绘，重绘不一定触发重排"></a>重排一定触发重绘，重绘不一定触发重排</h1><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><ul><li>尽量批次改变元素css属性</li><li>将动画的元素设置position属性为absolute或fixed，这样使元素脱离文本流，不会影响渲染树。</li><li>当多个添加DOM元素时，使用文本碎片fragment（隐藏的元素不再渲染树中，）只触发一次重排重绘</li></ul>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重排 重绘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 与 CSS 是否阻塞 DOM</title>
      <link href="/2019/04/14/JS-%E4%B8%8E-CSS-%E6%98%AF%E5%90%A6%E9%98%BB%E5%A1%9E-DOM/"/>
      <url>/2019/04/14/JS-%E4%B8%8E-CSS-%E6%98%AF%E5%90%A6%E9%98%BB%E5%A1%9E-DOM/</url>
      
        <content type="html"><![CDATA[<p>浏览器的解析渲染过程，解析DOM生成DOM Tree，解析CSS生成CSSOM Tree，两者结合生成render tree渲染树，最后浏览器根据渲染树渲染至页面。</p><h1 id="所以CSS不会阻塞DOM的解析，因为两者是并行解析的。"><a href="#所以CSS不会阻塞DOM的解析，因为两者是并行解析的。" class="headerlink" title="所以CSS不会阻塞DOM的解析，因为两者是并行解析的。"></a>所以CSS不会阻塞DOM的解析，因为两者是并行解析的。</h1><p>但是由于render tree的生成是依赖DOM Tree和CSSOM Tree的，因此CSS必然会阻塞DOM的渲染。<br>最终生成页面依赖的渲染数 是由DOM Tree和CSSOM Tree组成的，如果CSSOM Tree阻塞了，那么DOM的渲染也就没那么快完成</p><h1 id="JS-会阻塞-DOM-解析"><a href="#JS-会阻塞-DOM-解析" class="headerlink" title="JS 会阻塞 DOM 解析"></a>JS 会阻塞 DOM 解析</h1><p>首先浏览器无法知晓JS的具体内容，倘若先解析DOM，万一JS内部全部删除掉DOM，那么浏览器就白忙活了，所以就干脆暂停解析DOM，等到JS执行完成再继续解析。<br>开发者可以优先考虑使用defer的方式，其次是async方式让页面的JS进行异步执行，</p><ul><li>defer 异步加载， 加载完后会等待Html标签全部解析完才去执行<br>比如第三方sdk 不影响页面形式的js 都可以延时解析</li></ul>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器缓存机制</title>
      <link href="/2019/04/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/04/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h1><h3 id="浏览器缓存分为强缓存和协商缓存，浏览器加载一个页面的简单流程如下："><a href="#浏览器缓存分为强缓存和协商缓存，浏览器加载一个页面的简单流程如下：" class="headerlink" title="浏览器缓存分为强缓存和协商缓存，浏览器加载一个页面的简单流程如下："></a>浏览器缓存分为强缓存和协商缓存，浏览器加载一个页面的简单流程如下：</h3><ul><li>浏览器先根据这个资源的http头信息来判断是否命中强缓存。如果命中则直接加在缓存中的资源，并不会将请求发送到服务器。（强缓存）</li><li>如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。服务器来判断浏览器本地缓存是否失效。若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源。（协商缓存）</li><li>如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。（新的请求）</li></ul><h3 id="命中强缓存时，浏览器并不会将请求发送给服务器。code-200-Size：from-cache"><a href="#命中强缓存时，浏览器并不会将请求发送给服务器。code-200-Size：from-cache" class="headerlink" title="命中强缓存时，浏览器并不会将请求发送给服务器。code: 200 Size：from cache"></a>命中强缓存时，浏览器并不会将请求发送给服务器。code: 200 Size：from cache</h3><h3 id="利用http的返回头中的Expires或者Cache-Control两个字段来控制的缓存的过期时间"><a href="#利用http的返回头中的Expires或者Cache-Control两个字段来控制的缓存的过期时间" class="headerlink" title="利用http的返回头中的Expires或者Cache-Control两个字段来控制的缓存的过期时间"></a>利用http的返回头中的Expires或者Cache-Control两个字段来控制的缓存的过期时间</h3><h3 id="若未命中强缓存，则浏览器会将请求发送至服务器。服务器根据http头信息中的Last-Modify-x2F-If-Modify-Since或Etag-x2F-If-None-Match来判断是否命中协商缓存。如果命中，则http返回码为304，浏览器从缓存中加载资源。"><a href="#若未命中强缓存，则浏览器会将请求发送至服务器。服务器根据http头信息中的Last-Modify-x2F-If-Modify-Since或Etag-x2F-If-None-Match来判断是否命中协商缓存。如果命中，则http返回码为304，浏览器从缓存中加载资源。" class="headerlink" title="若未命中强缓存，则浏览器会将请求发送至服务器。服务器根据http头信息中的Last-Modify&#x2F;If-Modify-Since或Etag&#x2F;If-None-Match来判断是否命中协商缓存。如果命中，则http返回码为304，浏览器从缓存中加载资源。"></a>若未命中强缓存，则浏览器会将请求发送至服务器。服务器根据http头信息中的Last-Modify&#x2F;If-Modify-Since或Etag&#x2F;If-None-Match来判断是否命中协商缓存。如果命中，则http返回码为304，浏览器从缓存中加载资源。</h3>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强缓存 协商缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuex详解</title>
      <link href="/2019/02/25/Vuex%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/02/25/Vuex%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Vuex-是什么"><a href="#Vuex-是什么" class="headerlink" title="Vuex 是什么"></a>Vuex 是什么</h1><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><code>yarn add vuex</code></p><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个 store，全局数据状态管理中心 store.js</span></span><br><span class="line">import Vue from <span class="string">&#x27;vue&#x27;</span></span><br><span class="line">import Vuex from <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  action: &#123;</span><br><span class="line">    async handleAsync(state, <span class="built_in">date</span>)&#123;</span><br><span class="line">      <span class="comment"># date 是dispatch传递的第二个参数</span></span><br><span class="line">      <span class="comment"># 这里可以操作异步</span></span><br><span class="line">      <span class="comment"># const result = await axios.get(url,params)</span></span><br><span class="line">      <span class="comment"># 然后根据结果触发mutations</span></span><br><span class="line">      state.commit(<span class="string">&#x27;increment&#x27;</span>,<span class="built_in">date</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment(state,<span class="built_in">date</span>) &#123;</span><br><span class="line">      state.count = state.count + <span class="built_in">date</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在入口文件 new Vue 实例化的时候注入进去 index.js</span></span><br><span class="line">import store from <span class="string">&#x27;./store&#x27;</span></span><br><span class="line">...</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  store: store,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在组件内部调用</span></span><br><span class="line">...</span><br><span class="line">methods: &#123;</span><br><span class="line">  <span class="function"><span class="title">handleAction</span></span>()&#123;</span><br><span class="line">    this.<span class="variable">$store</span>.state.dispatch(<span class="string">&#x27;handleAsync&#x27;</span>,1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>创建一个store，里面有action，mutation方法</li><li>全局注入到Vue的实例</li><li>通过this.$store.state.dispatch(‘actionName’,params) 触发action</li><li>action方法内部可以执行异步，通过在action 触发state.commit(‘mutationName’,params) 去修改state的值</li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 开发一个按钮组件</title>
      <link href="/2019/02/13/Vue-%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E6%8C%89%E9%92%AE%E7%BB%84%E4%BB%B6/"/>
      <url>/2019/02/13/Vue-%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E6%8C%89%E9%92%AE%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue-开发一个按钮组件"><a href="#Vue-开发一个按钮组件" class="headerlink" title="Vue 开发一个按钮组件"></a>Vue 开发一个按钮组件</h1><p>解决思路：<br>通过父子组件通讯（$refs 和 props）<br>props接受参数, $refs调用子组件的方法<br>来达到点击提交改变按钮状态，如果不成功则取消按钮状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;!-- use plane  --&gt;</span><br><span class="line">&lt;!-- 传入bgColor改变按钮背景色 --&gt;</span><br><span class="line">&lt;!-- state切换button的状态 调用cancel()可以切换 --&gt;</span><br><span class="line">&lt;!-- text为按钮文字 --&gt;</span><br><span class="line">  &lt;div class=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">    &lt;button  </span><br><span class="line">      @click=<span class="string">&quot;confirm&quot;</span></span><br><span class="line">      :disabled=<span class="string">&quot;state&quot;</span> </span><br><span class="line">      class=<span class="string">&quot;confirm&quot;</span> </span><br><span class="line">      :style=<span class="string">&quot;&#123;background: btnData.bgColor&#125;&quot;</span></span><br><span class="line">    &gt;&#123;&#123;text&#125;&#125;&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      text: this.btnData.text,</span><br><span class="line">      state: <span class="literal">false</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    btnData: &#123;</span><br><span class="line">      types: Array,</span><br><span class="line">      <span class="function"><span class="title">default</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">          text: <span class="string">&#x27;确认&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">confirm</span></span>()&#123;</span><br><span class="line">      this.text += <span class="string">&#x27;...&#x27;</span></span><br><span class="line">      this.state = <span class="literal">true</span></span><br><span class="line">      //这里是激活父组件的事件，因为子组件是不会冒泡到父组件上的，必须手动调用<span class="variable">$emit</span></span><br><span class="line">      //相对应父组件要在调用该组件的时候，将其挂载到上面</span><br><span class="line">      this.<span class="variable">$emit</span>(<span class="string">&quot;confirm&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">cancel</span></span>()&#123;</span><br><span class="line">      this.text = this.btnData.text</span><br><span class="line">      this.state = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style lang=<span class="string">&quot;less&quot;</span> scoped&gt;</span><br><span class="line">.confirm &#123;</span><br><span class="line">  border: none;</span><br><span class="line">  color: <span class="comment">#fff;</span></span><br><span class="line">  width: 100%;</span><br><span class="line">  padding: 1rem 0;</span><br><span class="line">  border-radius: 4px;</span><br><span class="line">  font-size: 1.6rem;</span><br><span class="line">  background: <span class="comment">#5da1fd;</span></span><br><span class="line">  &amp;:focus &#123;</span><br><span class="line">    outline: none;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>在页面中调用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=<span class="string">&quot;btn-box&quot;</span>&gt;</span><br><span class="line">      &lt;Btn </span><br><span class="line">        :btnData=<span class="string">&quot;&#123;text: &#x27;确认注册&#x27;&#125;&quot;</span></span><br><span class="line">        &lt;!--这里就要挂载<span class="variable">$emit</span>调用的事件 @confirm=<span class="string">&quot;想要调用事件的名字&quot;</span>--&gt;</span><br><span class="line">        @confirm=<span class="string">&quot;confirm&quot;</span></span><br><span class="line">        ref=<span class="string">&quot;btn&quot;</span></span><br><span class="line">      &gt;&lt;/Btn&gt;</span><br><span class="line">    &lt;/div&gt; </span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Btn from <span class="string">&#x27;@/components/button&#x27;</span></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Btn</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">confirm</span></span>()&#123;</span><br><span class="line">      <span class="keyword">if</span>(!this.companyName)&#123;</span><br><span class="line">        this.<span class="variable">$toast</span>(<span class="string">&quot;公司名不能为空&quot;</span>)  </span><br><span class="line">        this.<span class="variable">$refs</span>.btn.cancel()</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在这里，要注意一些细节：</p><ul><li><ol><li>button组件形成之后和其它div元素的间距，如果是在组件内定死是很难复用的。</li></ol></li><li><ol start="2"><li>在复用的时候，在父组件中是改变不了子组件的样式的，如果要强制更改，单独写一个并去掉scoped。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue button </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>New操作符详解</title>
      <link href="/2018/12/25/New%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/12/25/New%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="new操作符做了什么"><a href="#new操作符做了什么" class="headerlink" title="new操作符做了什么"></a>new操作符做了什么</h1><ul><li>创建一个空的简单JavaScript对象（即{}）；</li><li>链接该对象（即设置该对象的构造函数）到另一个对象 ；</li><li>将步骤1新创建的对象作为this的上下文 ；</li><li>判断返回值 返回对象就用该对象,没有的话就创建一个对象</li></ul><p>new是用来做继承的，而创建对象的其实是Object.create(null)。 在new操作符的作用下，我们使用新创建的对象去继承了他的构造函数上的属性和方法、以及他的原型链上的属性和方法</p><h1 id="手写一个new函数"><a href="#手写一个new函数" class="headerlink" title="手写一个new函数"></a>手写一个new函数</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> new(Func,args)&#123;</span><br><span class="line">  <span class="built_in">let</span> obj = obj.create(null)</span><br><span class="line">  obj._protp_ = Func.prototype</span><br><span class="line">  const result = Func.apply(obj,args)</span><br><span class="line">  <span class="built_in">return</span> result instanceof Object ? result : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> New </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端1px像素</title>
      <link href="/2018/05/26/%E7%A7%BB%E5%8A%A8%E7%AB%AF1px%E5%83%8F%E7%B4%A0/"/>
      <url>/2018/05/26/%E7%A7%BB%E5%8A%A8%E7%AB%AF1px%E5%83%8F%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="移动端1px像素起源"><a href="#移动端1px像素起源" class="headerlink" title="移动端1px像素起源"></a>移动端1px像素起源</h1><p>在移动端，css中的1px并不等于移动设备的1px，因为手机屏幕有不同的像素密度。window中的devicePixelRatio就是反应css中像素与真实像素的比例，也就是设备物理像素和设备独立像素的比例，也就是 devicePixelRatio &#x3D; 物理像素 &#x2F; 独立像素。所以造成了通过css设置1px，在移动端屏幕上会变粗。</p><h1 id="解决方案一：使用伪类缩放"><a href="#解决方案一：使用伪类缩放" class="headerlink" title="解决方案一：使用伪类缩放"></a>解决方案一：使用伪类缩放</h1><p>使用伪类缩放需要主要的是：</p><ul><li>设置全边框的时候，box-sizing要设置为border-box，否则伪元素上下左右各会多1px</li><li>需要将父元素设置为relative</li><li>注意 transform 的起点，上边距要用左上角，下边距用左下角</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* 下边框 */</span><br><span class="line">.one-px-border2:after &#123;</span><br><span class="line">  content: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  position: absolute;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  left: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  border-bottom: 1px solid red;</span><br><span class="line">  transform: scaleY(.5);</span><br><span class="line">  transform-origin: left bottom;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Issue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 1px </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rem em px详解</title>
      <link href="/2018/05/25/rem-em-px%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/05/25/rem-em-px%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="rem-em-px详解"><a href="#rem-em-px详解" class="headerlink" title="rem em px详解"></a>rem em px详解</h1><ul><li>px相对长度单位，相对于显示器屏幕分辨率来的</li><li>em相对长度单位，相对于当前对象内文本的字体尺寸来的，值不固定，会继承父级元素字体的大小，未经调整浏览器：16px &#x3D; 1em 假如父元素为2em，子元素为2em字体实际大小为4em</li><li>rem是css3新增的相对单位，使用rem为元素设置大小时，是相对大小，相对的是html根元素，修改根元素就可以调整所有字体大小，还可以避免字体大小逐层复合的连锁反应，未经调整浏览器：16px &#x3D; 1rem。</li></ul><h1 id="移动端适配-相关知识储备"><a href="#移动端适配-相关知识储备" class="headerlink" title="移动端适配 相关知识储备"></a>移动端适配 相关知识储备</h1><p>响应式 —— 在css中，针对不同大小的浏览器窗口，用不同的方式相应更新页面的样式。<br>1inch（英寸） &#x3D; 25.4mm（毫米） &#x3D; 6pc（pica，印刷术语，长度为12points） &#x3D; 72pt（点） &#x3D; 96px（像素）</p><p>em —— 基准是 当前元素的字号（font-size）大小，实际值取决于在哪个元素上应用。</p><ul><li>基准是当前元素的font-size</li><li>如果当前元素的字号用的是em，那么当前元素字号的基准是其父元素</li><li>先算出当前元素的font-size的像素值，再计算其他使用em作为单位的属性值大小</li></ul><p>rem —— 是根em的缩写，基准是根元素的字号大小**</p><p>视口viewport —— 浏览器窗口中用来渲染页面的可视区域，不包括浏览器的地址栏、工具栏、状态栏等。<br>相关单位</p><ul><li>vh ——视口高度的1&#x2F;100</li><li>vw——视口宽度的1&#x2F;100</li><li>vmin——视口宽度或者高度较小值的1&#x2F;100</li><li>vmax——视口官渡或者高度较大值的1&#x2F;100（横竖屏时可以用这两个值）</li></ul><p>flexible源码解读</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// 立即执行函数，入参是window和document</span><br><span class="line">(<span class="keyword">function</span> flexible (window, document) &#123;</span><br><span class="line">  var docEl = document.documentElement</span><br><span class="line">  // 文档的root元素</span><br><span class="line">  var dpr = window.devicePixelRatio || 1</span><br><span class="line">  // 获取设备的dpr（返回当前显示设备的物理像素分辨率与css像素分辨率之比），它告诉浏览器应该使用多少屏幕实际像素来绘制单个css像素，</span><br><span class="line"></span><br><span class="line">  // adjust body font size</span><br><span class="line">  // 调整body标签的fontsize，fontsize = (12 * dpr) + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">  // 设置默认字体大小，默认的字体大小继承自body，如果子元素没有设置font-size就继承父元素设置的这个默认字号（这个地方有个疑问，为什么以12位基准，是因为浏览器的最小显示的字号是12吗？）</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">setBodyFontSize</span></span> () &#123;</span><br><span class="line">    <span class="keyword">if</span> (document.body) &#123;</span><br><span class="line">      document.body.style.fontSize = (12 * dpr) + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      document.addEventListener(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, setBodyFontSize)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  setBodyFontSize();</span><br><span class="line"></span><br><span class="line">  // <span class="built_in">set</span> 1rem = viewWidth / 10</span><br><span class="line">  // 设置根元素的fontsize为clientwidth/10（除以10纯粹是为了计算方便）这个地方也可以直接写10vw（表示可视窗口的宽度的十分之一）</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">setRemUnit</span></span> () &#123;</span><br><span class="line">    var rem = docEl.clientWidth / 10</span><br><span class="line">    docEl.style.fontSize = rem + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setRemUnit()</span><br><span class="line"></span><br><span class="line">  // reset rem unit on page resize</span><br><span class="line">  // 当页面展示或重新设置大小的时候，重新对rem的px值进行计算</span><br><span class="line">  window.addEventListener(<span class="string">&#x27;resize&#x27;</span>, setRemUnit)</span><br><span class="line">  window.addEventListener(<span class="string">&#x27;pageshow&#x27;</span>, <span class="keyword">function</span> (e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.persisted) &#123;</span><br><span class="line">      setRemUnit()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  // detect 0.5px supports</span><br><span class="line">  <span class="keyword">if</span> (dpr &gt;= 2) &#123;</span><br><span class="line">    var fakeBody = document.createElement(<span class="string">&#x27;body&#x27;</span>)</span><br><span class="line">    var testElement = document.createElement(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">    testElement.style.border = <span class="string">&#x27;.5px solid transparent&#x27;</span></span><br><span class="line">    fakeBody.appendChild(testElement)</span><br><span class="line">    docEl.appendChild(fakeBody)</span><br><span class="line">    <span class="keyword">if</span> (testElement.offsetHeight === 1) &#123;</span><br><span class="line">      docEl.classList.add(<span class="string">&#x27;hairlines&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    docEl.removeChild(fakeBody)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(window, document))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rem em px </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS3 新增常用特性</title>
      <link href="/2018/05/23/CSS3-%E6%96%B0%E5%A2%9E%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7/"/>
      <url>/2018/05/23/CSS3-%E6%96%B0%E5%A2%9E%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># border新增border-img, border-radius</span></span><br><span class="line">* border-image-source 用于指定要用于绘制边框的图像的位置</span><br><span class="line">* border-image-slice 图像边界向内偏移</span><br><span class="line">* border-image-width 图像边界的宽度</span><br><span class="line">* border-image-outset 用于指定在边框外部绘制 border-image-area 的量</span><br><span class="line">* border-image-repeat 用于设置图像边界是否应重复（repeat）、拉伸（stretch）或铺满（round）。</span><br><span class="line">border-image: <span class="built_in">source</span> slice width outset repeat|initial|inherit;</span><br><span class="line"></span><br><span class="line"><span class="comment"># box-shadow </span></span><br><span class="line">box-shadow:-10px -10px 20px 20px gold;</span><br><span class="line"><span class="comment"># text-shadow</span></span><br><span class="line">text-shadow: 0 0 5px <span class="comment">#fff;</span></span><br><span class="line"><span class="comment"># background 新增background-image，background-size background-repeat</span></span><br><span class="line"><span class="comment"># 媒体查询 制作响应式设计</span></span><br><span class="line">@media screen and (max-width: 300px) &#123;</span><br><span class="line">    body &#123;</span><br><span class="line">        background-color:lightblue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (min-width: 300px) and (max-width: 500px)&#123;</span><br><span class="line">    <span class="comment">#wrap div&#123;</span></span><br><span class="line">        width: 20%;</span><br><span class="line">    &#125;            </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5 新增语义化标签</title>
      <link href="/2018/05/22/HTML5-%E6%96%B0%E5%A2%9E%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE/"/>
      <url>/2018/05/22/HTML5-%E6%96%B0%E5%A2%9E%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML5-新增语义化标签"><a href="#HTML5-新增语义化标签" class="headerlink" title="HTML5 新增语义化标签"></a>HTML5 新增语义化标签</h1><p>这种语义化标签主要是针对搜索引擎的<br>这些新标签页面中可以使用多次</p><ul><li>header 头部标签</li><li>nav 导航标签</li><li>content 内容标签</li><li>section 定义文档某个区域</li><li>aside 侧边栏标签</li><li>footer 尾部标签</li><li>video 视频标签</li><li>audio 音频标签</li><li>user-select:none;禁止鼠标移动选择文字</li><li>background-image:liner-gradient(to right,red,green); 设置背景颜色渐变</li></ul>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器BOM和JS中的DOM</title>
      <link href="/2018/05/14/%E6%B5%8F%E8%A7%88%E5%99%A8BOM%E5%92%8CJS%E4%B8%AD%E7%9A%84DOM/"/>
      <url>/2018/05/14/%E6%B5%8F%E8%A7%88%E5%99%A8BOM%E5%92%8CJS%E4%B8%AD%E7%9A%84DOM/</url>
      
        <content type="html"><![CDATA[<p>JavaScript是一种运行在客户端的脚本语言 （Script 是脚本的意思）,它有三部分组成 ：ECMAScript 语法 ， DOM(页面文档对象模型) ，BOM(浏览器对象模型)而Web API则包含了DOM和BOM</p><h1 id="什么是BOM"><a href="#什么是BOM" class="headerlink" title="什么是BOM"></a>什么是BOM</h1><p>BOM（Browser Object Model）即浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是 window。</p><p>BOM 由一系列相关的对象构成，并且每个对象都提供了很多方法与属性 ，但是BOM 缺乏标准，JavaScript 语法的标准化组织是 ECMA，DOM 的标准化组织是 W3C，BOM 最初是Netscape 浏览器标准的一部分。</p><h1 id="BOM的构成部分"><a href="#BOM的构成部分" class="headerlink" title="BOM的构成部分"></a>BOM的构成部分</h1><p>是window顶级对象 ，也是JS访问浏览器窗口的一个接口。<br>其中包含： document location navigator screen history</p><h1 id="window对象的常见的事件"><a href="#window对象的常见的事件" class="headerlink" title="window对象的常见的事件"></a>window对象的常见的事件</h1><ul><li>窗口加载事件 window.onload 当文档内容完全加载完成会触发该事件(包括图像、脚本文件、CSS 文件等), 就调用的处理函数。(JS代码都写在加载事件里面)</li><li>调整窗口大小的事件 window.onresize window.innerWidth 获取当前屏幕的宽度</li><li>window.setTimeout(调用函数， [延迟的毫秒数]) window.clearTimeout(timeoutID) setInterval clearInterval</li></ul><h1 id="什么是-DOM"><a href="#什么是-DOM" class="headerlink" title="什么是 DOM"></a>什么是 DOM</h1><p>DOM 英文全称“Document Object Model”，译为“文档对象模型”。<br>DOM 是一个与平台和编程语言无关的接口，通过这个接口程序和脚本可以动态的访问和修改文档的内容、结构和样式。</p><h1 id="DOM-的组成"><a href="#DOM-的组成" class="headerlink" title="DOM 的组成"></a>DOM 的组成</h1><p>核心DOM - 针对任何结构化文档的标准模型。<br>XML DOM - 针对 XML 文档的标准模型。<br>HTML DOM - 针对 HTML 文档的标准模型。</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BOM DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS浏览器事件循环机制</title>
      <link href="/2018/05/12/JS%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/05/12/JS%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript-单线程-非阻塞"><a href="#JavaScript-单线程-非阻塞" class="headerlink" title="JavaScript 单线程 非阻塞"></a>JavaScript 单线程 非阻塞</h1><p>定义：单线程（代码执行时只有一个主线程来处理所有任务），非阻塞（当代码需要进行一项异步任务时不会等待，主线程会挂起这个任务，在异步任务返回结果时再执行相应的回调）的脚本语言<br>用途：与浏览器交互</p><h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><p>用途：js引擎（网页浏览器中专门处理js脚本的虚拟机）实现非阻塞</p><h1 id="浏览器环境下js引擎的事件循环机制"><a href="#浏览器环境下js引擎的事件循环机制" class="headerlink" title="浏览器环境下js引擎的事件循环机制"></a>浏览器环境下js引擎的事件循环机制</h1><p>js代码执行时将不同变量存于内存中的不同位置<br>堆：放对象 栈：基础类型变量，对象指针</p><h1 id="执行栈：存放执行环境并依次调用执行的地方"><a href="#执行栈：存放执行环境并依次调用执行的地方" class="headerlink" title="执行栈：存放执行环境并依次调用执行的地方"></a>执行栈：存放执行环境并依次调用执行的地方</h1><p>当调用一个方法时，js会生成一个与这个方法对应的执行环境（也叫执行上下文，存放这个方法的私有作用域，上层作用域指向，参数，变量，this对象）。这些方法都被存放在执行栈中，依次调用</p><h1 id="执行栈执行同步代码"><a href="#执行栈执行同步代码" class="headerlink" title="执行栈执行同步代码"></a>执行栈执行同步代码</h1><p>按照执行顺序将执行环境依次加入执行栈中并进入环境执行代码，若有调用，在执行栈中再添加一个执行环境（往上垒），执行环境中的代码执行完毕并返回结果后，js会退出这个执行环境并将其销毁，回到上一个方法的执行环境。反复进行，直到代码全部执行完毕</p><h3 id="执行栈执行异步代码（如发送ajax请求数据）事件队列–实现非阻塞"><a href="#执行栈执行异步代码（如发送ajax请求数据）事件队列–实现非阻塞" class="headerlink" title="执行栈执行异步代码（如发送ajax请求数据）事件队列–实现非阻塞"></a>执行栈执行异步代码（如发送ajax请求数据）事件队列–实现非阻塞</h3><h3 id="js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕，-主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码…，如此反复，这样就形成了一个无限的循环"><a href="#js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕，-主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码…，如此反复，这样就形成了一个无限的循环" class="headerlink" title="js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码…，如此反复，这样就形成了一个无限的循环"></a>js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码…，如此反复，这样就形成了一个无限的循环</h3><h3 id="因为形成了无限循环，所以这个过程被叫做事件循环"><a href="#因为形成了无限循环，所以这个过程被叫做事件循环" class="headerlink" title="因为形成了无限循环，所以这个过程被叫做事件循环"></a>因为形成了无限循环，所以这个过程被叫做<code>事件循环</code></h3><h3 id="不同的异步任务依据执行优先级被分为两类：微任务（micro-task）和宏任务（macro-task）"><a href="#不同的异步任务依据执行优先级被分为两类：微任务（micro-task）和宏任务（macro-task）" class="headerlink" title="不同的异步任务依据执行优先级被分为两类：微任务（micro task）和宏任务（macro task）"></a>不同的异步任务依据执行优先级被分为两类：微任务（micro task）和宏任务（macro task）</h3><ul><li>宏任务：setInterval() setTimeout()</li><li>微任务：new Promise() new MutaionObserver()</li></ul><h3 id="当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行（先微再宏）"><a href="#当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行（先微再宏）" class="headerlink" title="当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行（先微再宏）"></a>当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行（先微再宏）</h3>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS BOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS事件机制与相关问题</title>
      <link href="/2018/04/20/JS%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E4%B8%8E%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2018/04/20/JS%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E4%B8%8E%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是事件代理-x2F-事件委托？"><a href="#什么是事件代理-x2F-事件委托？" class="headerlink" title="什么是事件代理&#x2F;事件委托？"></a>什么是事件代理&#x2F;事件委托？</h2><h4 id="事件代理-x2F-事件委托是利用事件冒泡的特性，将本应该绑定在多个元素上的事件绑定在他们的祖先元素上，尤其在动态添加子元素的时候，可以非常方便的提高程序性能，减小内存空间。"><a href="#事件代理-x2F-事件委托是利用事件冒泡的特性，将本应该绑定在多个元素上的事件绑定在他们的祖先元素上，尤其在动态添加子元素的时候，可以非常方便的提高程序性能，减小内存空间。" class="headerlink" title="事件代理&#x2F;事件委托是利用事件冒泡的特性，将本应该绑定在多个元素上的事件绑定在他们的祖先元素上，尤其在动态添加子元素的时候，可以非常方便的提高程序性能，减小内存空间。"></a>事件代理&#x2F;事件委托是利用事件冒泡的特性，将本应该绑定在多个元素上的事件绑定在他们的祖先元素上，尤其在动态添加子元素的时候，可以非常方便的提高程序性能，减小内存空间。</h4><h2 id="什么是事件冒泡？什么是事件捕获？"><a href="#什么是事件冒泡？什么是事件捕获？" class="headerlink" title="什么是事件冒泡？什么是事件捕获？"></a>什么是事件冒泡？什么是事件捕获？</h2><ul><li>冒泡型事件：事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。</li><li>捕获型事件：事件从最不精确的对象(document 对象)开始触发，然后到最精确(也可以在窗口级别捕获事件，不过必须由开发人员特别指定)。</li></ul><h4 id="在添加事件时用addEventListener-event-fn-useCapture-方法，基中第3个参数useCapture是一个Boolean值，用来设置事件是在事件捕获时执行，还是事件冒泡时执行-Vue-中-click默认是冒泡的"><a href="#在添加事件时用addEventListener-event-fn-useCapture-方法，基中第3个参数useCapture是一个Boolean值，用来设置事件是在事件捕获时执行，还是事件冒泡时执行-Vue-中-click默认是冒泡的" class="headerlink" title="在添加事件时用addEventListener(event,fn,useCapture)方法，基中第3个参数useCapture是一个Boolean值，用来设置事件是在事件捕获时执行，还是事件冒泡时执行 Vue 中 @click默认是冒泡的"></a>在添加事件时用addEventListener(event,fn,useCapture)方法，基中第3个参数useCapture是一个Boolean值，用来设置事件是在事件捕获时执行，还是事件冒泡时执行 Vue 中 @click默认是冒泡的</h4><h4 id="e-stopPropagation-阻止事件冒泡"><a href="#e-stopPropagation-阻止事件冒泡" class="headerlink" title="e.stopPropagation() 阻止事件冒泡"></a>e.stopPropagation() 阻止事件冒泡</h4><h2 id="DOM-事件有哪些阶段？谈谈对事件代理的理解"><a href="#DOM-事件有哪些阶段？谈谈对事件代理的理解" class="headerlink" title="DOM 事件有哪些阶段？谈谈对事件代理的理解"></a>DOM 事件有哪些阶段？谈谈对事件代理的理解</h2><h4 id="分为三大阶段：捕获阶段–目标阶段–冒泡阶段"><a href="#分为三大阶段：捕获阶段–目标阶段–冒泡阶段" class="headerlink" title="分为三大阶段：捕获阶段–目标阶段–冒泡阶段"></a>分为三大阶段：捕获阶段–目标阶段–冒泡阶段</h4><h4 id="事件代理简单说就是：事件不直接绑定到某元素上，而是绑定到该元素的父元素上，进行触发事件操作时-例如’click’-，再通过条件判断，执行事件触发后的语句-例如’alert-e-target-innerhtml-’"><a href="#事件代理简单说就是：事件不直接绑定到某元素上，而是绑定到该元素的父元素上，进行触发事件操作时-例如’click’-，再通过条件判断，执行事件触发后的语句-例如’alert-e-target-innerhtml-’" class="headerlink" title="事件代理简单说就是：事件不直接绑定到某元素上，而是绑定到该元素的父元素上，进行触发事件操作时(例如’click’)，再通过条件判断，执行事件触发后的语句(例如’alert(e.target.innerhtml)’)"></a>事件代理简单说就是：事件不直接绑定到某元素上，而是绑定到该元素的父元素上，进行触发事件操作时(例如’click’)，再通过条件判断，执行事件触发后的语句(例如’alert(e.target.innerhtml)’)</h4><h2 id="闭包的概念？优缺点？使用场景？"><a href="#闭包的概念？优缺点？使用场景？" class="headerlink" title="闭包的概念？优缺点？使用场景？"></a>闭包的概念？优缺点？使用场景？</h2><h4 id="闭包的概念：闭包就是能读取其他函数内部变量的函数。"><a href="#闭包的概念：闭包就是能读取其他函数内部变量的函数。" class="headerlink" title="闭包的概念：闭包就是能读取其他函数内部变量的函数。"></a>闭包的概念：闭包就是能读取其他函数内部变量的函数。</h4><h4 id="优点：-避免全局变量的污染，希望一个变量长期存储在内存中（缓存变量）"><a href="#优点：-避免全局变量的污染，希望一个变量长期存储在内存中（缓存变量）" class="headerlink" title="优点： 避免全局变量的污染，希望一个变量长期存储在内存中（缓存变量）"></a>优点： 避免全局变量的污染，希望一个变量长期存储在内存中（缓存变量）</h4><h4 id="缺点：-内存泄露（消耗），常驻内存，增加内存使用量"><a href="#缺点：-内存泄露（消耗），常驻内存，增加内存使用量" class="headerlink" title="缺点： 内存泄露（消耗），常驻内存，增加内存使用量"></a>缺点： 内存泄露（消耗），常驻内存，增加内存使用量</h4><h4 id="使用场景：封装功能时-需要使用私有的属性和方法-，函数防抖、函数节流、函数柯里化、给元素伪数组添加事件需要使用元素的索引值。"><a href="#使用场景：封装功能时-需要使用私有的属性和方法-，函数防抖、函数节流、函数柯里化、给元素伪数组添加事件需要使用元素的索引值。" class="headerlink" title="使用场景：封装功能时(需要使用私有的属性和方法)，函数防抖、函数节流、函数柯里化、给元素伪数组添加事件需要使用元素的索引值。"></a>使用场景：封装功能时(需要使用私有的属性和方法)，函数防抖、函数节流、函数柯里化、给元素伪数组添加事件需要使用元素的索引值。</h4><h2 id="new操作符具体干了什么呢"><a href="#new操作符具体干了什么呢" class="headerlink" title="new操作符具体干了什么呢?"></a>new操作符具体干了什么呢?</h2><ul><li>1.创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。</li><li>2.属性和方法被加入到 this 引用的对象中。</li><li>3.新创建的对象由 this 所引用，并且最后隐式的返回 this 。</li></ul><h2 id="javascript中this的指向"><a href="#javascript中this的指向" class="headerlink" title="javascript中this的指向"></a>javascript中this的指向</h2><h4 id="this永远指向函数运行时所在的对象，而不是函数被创建时所在的对象。"><a href="#this永远指向函数运行时所在的对象，而不是函数被创建时所在的对象。" class="headerlink" title="this永远指向函数运行时所在的对象，而不是函数被创建时所在的对象。"></a>this永远指向函数运行时所在的对象，而不是函数被创建时所在的对象。</h4><h4 id="普通的函数调用，函数被谁调用，this就是谁"><a href="#普通的函数调用，函数被谁调用，this就是谁" class="headerlink" title="普通的函数调用，函数被谁调用，this就是谁"></a>普通的函数调用，函数被谁调用，this就是谁</h4><h4 id="构造函数的话，如果不用new操作符而直接调用，那即this指向window。用new操作符生成对象实例后，this就指向了新生成的对象。"><a href="#构造函数的话，如果不用new操作符而直接调用，那即this指向window。用new操作符生成对象实例后，this就指向了新生成的对象。" class="headerlink" title="构造函数的话，如果不用new操作符而直接调用，那即this指向window。用new操作符生成对象实例后，this就指向了新生成的对象。"></a>构造函数的话，如果不用new操作符而直接调用，那即this指向window。用new操作符生成对象实例后，this就指向了新生成的对象。</h4><h4 id="匿名函数或不处于任何对象中的函数指向window"><a href="#匿名函数或不处于任何对象中的函数指向window" class="headerlink" title="匿名函数或不处于任何对象中的函数指向window"></a>匿名函数或不处于任何对象中的函数指向window</h4><h4 id="如果是call，apply等，指定的this是谁，就是谁。"><a href="#如果是call，apply等，指定的this是谁，就是谁。" class="headerlink" title="如果是call，apply等，指定的this是谁，就是谁。"></a>如果是call，apply等，指定的this是谁，就是谁。</h4><h2 id="Javascript作用链域"><a href="#Javascript作用链域" class="headerlink" title="Javascript作用链域"></a>Javascript作用链域</h2><h4 id="作用域链的原理和原型链很类似，如果这个变量在自己的作用域中没有，那么它会寻找父级的，直到最顶层。"><a href="#作用域链的原理和原型链很类似，如果这个变量在自己的作用域中没有，那么它会寻找父级的，直到最顶层。" class="headerlink" title="作用域链的原理和原型链很类似，如果这个变量在自己的作用域中没有，那么它会寻找父级的，直到最顶层。"></a>作用域链的原理和原型链很类似，如果这个变量在自己的作用域中没有，那么它会寻找父级的，直到最顶层。</h4><h2 id="js如何处理防抖和节流"><a href="#js如何处理防抖和节流" class="headerlink" title="js如何处理防抖和节流"></a>js如何处理防抖和节流</h2><h4 id="在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。"><a href="#在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。" class="headerlink" title="在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。"></a>在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数防抖（debounce）：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。如下，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> debounce(fn, <span class="built_in">wait</span>) &#123; </span><br><span class="line">  var <span class="built_in">timeout</span> = null; </span><br><span class="line">  <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>() &#123; </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">timeout</span> !== null) clearTimeout(<span class="built_in">timeout</span>);</span><br><span class="line">    <span class="built_in">timeout</span> = setTimeout(fn, <span class="built_in">wait</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line">// 处理函数 </span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">handle</span></span>() &#123; console.log(Math.random()); &#125; // 滚动事件</span><br><span class="line">window.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, debounce(handle, 1000)); 函数节流函数节流（throttle）：</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当持续触发事件时，保证一定时间段内只调用一次事件处理函数。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。如下，持续触发scroll事件时，并不立即执行handle函数，每隔1000毫秒才会执行一次handle函数。</span></span><br><span class="line">var throttle = <span class="keyword">function</span>(func, delay) &#123; </span><br><span class="line">  var prev = Date.now(); </span><br><span class="line">  <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    var context = this;</span><br><span class="line">    var args = arguments; </span><br><span class="line">    var now = Date.now(); </span><br><span class="line">    <span class="keyword">if</span> (now - prev &gt;= delay) &#123; </span><br><span class="line">      func.apply(context, args);</span><br><span class="line">      prev = Date.now(); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">handle</span></span>() &#123; console.log(Math.random()); &#125; </span><br><span class="line">window.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, throttle(handle, 1000));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="JS里垃圾回收机制是什么，常用的是哪种，怎么处理的？"><a href="#JS里垃圾回收机制是什么，常用的是哪种，怎么处理的？" class="headerlink" title="JS里垃圾回收机制是什么，常用的是哪种，怎么处理的？"></a>JS里垃圾回收机制是什么，常用的是哪种，怎么处理的？</h2><h4 id="JS的垃圾回收机制是为了以防内存泄漏，内存泄漏的含义就是当已经不需要某块内存时这块内存还存在着，垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向的内存。JS中最常见的垃圾回收方式是标记清除。工作原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。"><a href="#JS的垃圾回收机制是为了以防内存泄漏，内存泄漏的含义就是当已经不需要某块内存时这块内存还存在着，垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向的内存。JS中最常见的垃圾回收方式是标记清除。工作原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。" class="headerlink" title="JS的垃圾回收机制是为了以防内存泄漏，内存泄漏的含义就是当已经不需要某块内存时这块内存还存在着，垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向的内存。JS中最常见的垃圾回收方式是标记清除。工作原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。"></a>JS的垃圾回收机制是为了以防内存泄漏，内存泄漏的含义就是当已经不需要某块内存时这块内存还存在着，垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向的内存。JS中最常见的垃圾回收方式是标记清除。工作原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。</h4><h4 id="那些操作会造成内存泄漏"><a href="#那些操作会造成内存泄漏" class="headerlink" title="那些操作会造成内存泄漏"></a>那些操作会造成内存泄漏</h4><h4 id="全局变量、闭包、DOM清空或删除时，事件未清除、子元素存在引用"><a href="#全局变量、闭包、DOM清空或删除时，事件未清除、子元素存在引用" class="headerlink" title="全局变量、闭包、DOM清空或删除时，事件未清除、子元素存在引用"></a>全局变量、闭包、DOM清空或删除时，事件未清除、子元素存在引用</h4><h2 id="什么是虚拟DOM"><a href="#什么是虚拟DOM" class="headerlink" title="什么是虚拟DOM"></a>什么是虚拟DOM</h2><h4 id="文档对象模型或-DOM-定义了一个接口，该接口允许-JavaScript-之类的语言访问和操作-HTML-文档。元素由树中的节点表示，并且接口允许我们操纵它们。但是此接口需要付出代价，大量非常频繁的-DOM-操作会使页面速度变慢。为了减少重排和重绘，虚拟dom应运而生。"><a href="#文档对象模型或-DOM-定义了一个接口，该接口允许-JavaScript-之类的语言访问和操作-HTML-文档。元素由树中的节点表示，并且接口允许我们操纵它们。但是此接口需要付出代价，大量非常频繁的-DOM-操作会使页面速度变慢。为了减少重排和重绘，虚拟dom应运而生。" class="headerlink" title="文档对象模型或 DOM 定义了一个接口，该接口允许 JavaScript 之类的语言访问和操作 HTML 文档。元素由树中的节点表示，并且接口允许我们操纵它们。但是此接口需要付出代价，大量非常频繁的 DOM 操作会使页面速度变慢。为了减少重排和重绘，虚拟dom应运而生。"></a>文档对象模型或 DOM 定义了一个接口，该接口允许 JavaScript 之类的语言访问和操作 HTML 文档。元素由树中的节点表示，并且接口允许我们操纵它们。但是此接口需要付出代价，大量非常频繁的 DOM 操作会使页面速度变慢。为了减少重排和重绘，虚拟dom应运而生。</h4><h3 id="JS延迟加载的方式有哪些？"><a href="#JS延迟加载的方式有哪些？" class="headerlink" title="JS延迟加载的方式有哪些？"></a>JS延迟加载的方式有哪些？</h3><h4 id="defer和async、动态创建DOM方式（用得最多）、按需异步载入JS"><a href="#defer和async、动态创建DOM方式（用得最多）、按需异步载入JS" class="headerlink" title="defer和async、动态创建DOM方式（用得最多）、按需异步载入JS"></a>defer和async、动态创建DOM方式（用得最多）、按需异步载入JS</h4><ul><li>defer：延迟脚本。立即下载，但延迟执行（延迟到整个页面都解析完毕后再运行），按照脚本出现的先后顺序执行。</li><li>async：异步脚本。下载完立即执行，但不保证按照脚本出现的先后顺序执行。</li></ul><h2 id="JS为什么要区分微任务和宏任务"><a href="#JS为什么要区分微任务和宏任务" class="headerlink" title="JS为什么要区分微任务和宏任务"></a>JS为什么要区分微任务和宏任务</h2><ul><li>（1）js是单线程的，但是分同步异步</li><li>（2）微任务和宏任务皆为异步任务，它们都属于一个队列</li><li>（3）宏任务一般是：script，setTimeout，setInterval、setImmediate</li><li>（4）微任务：原生Promise</li><li>（5）遇到微任务，先执行微任务，执行完后如果没有微任务，就执行下一个宏任务，如果有微任务，就按顺序一个一个执行微任务</li></ul>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS经典问题指南</title>
      <link href="/2018/04/18/JS%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E6%8C%87%E5%8D%97/"/>
      <url>/2018/04/18/JS%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript的数据类型"><a href="#JavaScript的数据类型" class="headerlink" title="JavaScript的数据类型"></a>JavaScript的数据类型</h2><ul><li>值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol（独一无二的值</li><li>引用数据类型：对象(Object)、数组(Array)、函数(Function)。</li></ul><h2 id="基本数据类型与引用类型在存储上有什么区别"><a href="#基本数据类型与引用类型在存储上有什么区别" class="headerlink" title="基本数据类型与引用类型在存储上有什么区别?"></a>基本数据类型与引用类型在存储上有什么区别?</h2><h3 id="1-存储位置不同"><a href="#1-存储位置不同" class="headerlink" title="1.存储位置不同:"></a>1.存储位置不同:</h3><ul><li>基本数据类型：以栈的形式存储, 保存与赋值指向数据本身, 用typeof 来判断类型</li><li>引用类型：以堆的形式存储, 保存于赋值指向对象的一个指针, 用instanceof 来判断类型</li></ul><h3 id="2-传值方式不同："><a href="#2-传值方式不同：" class="headerlink" title="2.传值方式不同："></a>2.传值方式不同：</h3><ul><li>基本数据类型按值传递，无法改变一个基本数据类型的值</li><li>引用类型按引用传递，应用类型值可以改变</li></ul><h2 id="判断-js-类型的方式"><a href="#判断-js-类型的方式" class="headerlink" title="判断 js 类型的方式"></a>判断 js 类型的方式</h2><ul><li><ol><li>typeof<h3 id="可以判断出’string’-’number’-’boolean’-’undefined’-’symbol’但判断-typeof-null-时值为-‘object’-判断数组和对象时值均为-‘object’"><a href="#可以判断出’string’-’number’-’boolean’-’undefined’-’symbol’但判断-typeof-null-时值为-‘object’-判断数组和对象时值均为-‘object’" class="headerlink" title="可以判断出’string’,’number’,’boolean’,’undefined’,’symbol’但判断 typeof(null) 时值为 ‘object’; 判断数组和对象时值均为 ‘object’"></a>可以判断出’string’,’number’,’boolean’,’undefined’,’symbol’但判断 typeof(null) 时值为 ‘object’; 判断数组和对象时值均为 ‘object’</h3></li></ol></li><li><ol start="2"><li>instanceof<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">functionA</span></span>() &#123;&#125;</span><br><span class="line"><span class="built_in">let</span> a = new A();</span><br><span class="line">a instanceof A //true</span><br><span class="line">// 因为 Object.getPrototypeOf(a) === A.prototype;</span><br></pre></td></tr></table></figure></li></ol></li><li><ol start="3"><li>Object.prototype.toString.call() 可以判断所有类型<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call(null)//<span class="string">&quot;[object Null]&quot;</span></span><br><span class="line">Object.prototype.toString.call(undefined)//<span class="string">&quot;[object Undefined]&quot;</span></span><br><span class="line">Object.prototype.toString.call(Object)//<span class="string">&quot;[object Function]&quot;</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="描述以下变量的区别：null，undefined或undeclared"><a href="#描述以下变量的区别：null，undefined或undeclared" class="headerlink" title="描述以下变量的区别：null，undefined或undeclared"></a>描述以下变量的区别：null，undefined或undeclared</h2><ul><li>null 表示”没有对象”</li><li>undefined 表示”缺少值”，就是此处应该有一个值，但是还没有定义</li></ul><h4 id="变量被声明了，但没有赋值时，就等于undefined。"><a href="#变量被声明了，但没有赋值时，就等于undefined。" class="headerlink" title="变量被声明了，但没有赋值时，就等于undefined。"></a>变量被声明了，但没有赋值时，就等于undefined。</h4><h4 id="调用函数时，应该提供的参数没有提供，该参数等于undefined。"><a href="#调用函数时，应该提供的参数没有提供，该参数等于undefined。" class="headerlink" title="调用函数时，应该提供的参数没有提供，该参数等于undefined。"></a>调用函数时，应该提供的参数没有提供，该参数等于undefined。</h4><h4 id="对象没有赋值的属性，该属性的值为undefined。"><a href="#对象没有赋值的属性，该属性的值为undefined。" class="headerlink" title="对象没有赋值的属性，该属性的值为undefined。"></a>对象没有赋值的属性，该属性的值为undefined。</h4><h4 id="函数没有返回值时，默认返回undefined。"><a href="#函数没有返回值时，默认返回undefined。" class="headerlink" title="函数没有返回值时，默认返回undefined。"></a>函数没有返回值时，默认返回undefined。</h4><ul><li>undeclared :js语法错误，没有申明直接使用，js无法找到对应的上下文。</li></ul><h2 id="for-in-和-object-keys的区别"><a href="#for-in-和-object-keys的区别" class="headerlink" title="for..in 和 object.keys的区别"></a>for..in 和 object.keys的区别</h2><ul><li>Object.keys不会遍历继承的原型属性</li><li>for…in 会遍历继承的原型属性</li></ul><h2 id="JS-中的函数提升"><a href="#JS-中的函数提升" class="headerlink" title="JS 中的函数提升"></a>JS 中的函数提升</h2><h4 id="JS允许将声明移动到顶部的默认行为称为提升。JS中创建函数的两种方法是函数声明和函数表达式。"><a href="#JS允许将声明移动到顶部的默认行为称为提升。JS中创建函数的两种方法是函数声明和函数表达式。" class="headerlink" title="JS允许将声明移动到顶部的默认行为称为提升。JS中创建函数的两种方法是函数声明和函数表达式。"></a>JS允许将声明移动到顶部的默认行为称为提升。JS中创建函数的两种方法是函数声明和函数表达式。</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数声明</span></span><br><span class="line">hoisted();</span><br><span class="line">// logs <span class="string">&quot;foo&quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">hoisted</span></span>() &#123;console.log(<span class="string">&#x27;foo&#x27;</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数表达式</span></span><br><span class="line">notHoisted(); </span><br><span class="line"><span class="comment">#TypeError: notHoisted is not a function</span></span><br><span class="line">var notHoisted = <span class="function"><span class="title">function</span></span>() &#123;console.log(<span class="string">&#x27;bar&#x27;</span>);&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Js隐式转换"><a href="#Js隐式转换" class="headerlink" title="Js隐式转换"></a>Js隐式转换</h2><h4 id="在js中，当运算符在运算时，如果两边数据不统一，CPU就无法计算，这时我们编译器会自动将运算符两边的数据做一个数据类型转换，转成一样的数据类型再计算"><a href="#在js中，当运算符在运算时，如果两边数据不统一，CPU就无法计算，这时我们编译器会自动将运算符两边的数据做一个数据类型转换，转成一样的数据类型再计算" class="headerlink" title="在js中，当运算符在运算时，如果两边数据不统一，CPU就无法计算，这时我们编译器会自动将运算符两边的数据做一个数据类型转换，转成一样的数据类型再计算"></a>在js中，当运算符在运算时，如果两边数据不统一，CPU就无法计算，这时我们编译器会自动将运算符两边的数据做一个数据类型转换，转成一样的数据类型再计算</h4><h4 id="这种无需程序员手动转换，而由编译器自动转换的方式就称为隐式转换"><a href="#这种无需程序员手动转换，而由编译器自动转换的方式就称为隐式转换" class="headerlink" title="这种无需程序员手动转换，而由编译器自动转换的方式就称为隐式转换"></a>这种无需程序员手动转换，而由编译器自动转换的方式就称为隐式转换</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 隐式转换规则：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 转成string类型： +（字符串连接符） 2..转成number类型：++/--(自增自减运算符) + - * / %(算术运算符) &gt; &lt; &gt;= &lt;= == != === !=== (关系运算符)</span></span><br><span class="line"><span class="comment"># 2. 转成boolean类型：!（逻辑非运算符）</span></span><br><span class="line">console.log([] == []) // <span class="literal">false</span> </span><br><span class="line">console.log([] == ![]) // <span class="literal">true</span></span><br><span class="line">console.log([] !== []) // <span class="literal">true</span></span><br><span class="line">console.log(NaN != NaN) // <span class="literal">true</span></span><br><span class="line">console.log(null == undefined) // <span class="literal">true</span></span><br><span class="line">console.log(null === undefined) // <span class="literal">false</span></span><br><span class="line">console.log(1 == <span class="literal">true</span>) // <span class="literal">true</span></span><br><span class="line">console.log(null &gt; 0) // <span class="literal">false</span></span><br><span class="line">console.log(<span class="literal">true</span> + 1) // 2</span><br><span class="line">console.log(undefined + 1) // NaN</span><br><span class="line">console.log(&#123;&#125; + 1) // [object Object]1</span><br><span class="line">console.log([] + &#123;&#125;) // [object Object]</span><br><span class="line">console.log([2,3] + [1,2]) // 2,31,2</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="JS-中-x3D-x3D-和-x3D-x3D-x3D-区别是什么？"><a href="#JS-中-x3D-x3D-和-x3D-x3D-x3D-区别是什么？" class="headerlink" title="JS 中 &#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; 区别是什么？"></a>JS 中 &#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; 区别是什么？</h2><ul><li>两等号判等，会在比较时进行类型转换；</li><li>三等号判等(判断严格)，比较时不进行隐式类型转换，(类 型不同则会返回false)；</li></ul><h2 id="ES5-和-ES6-分别几种方式声明变量"><a href="#ES5-和-ES6-分别几种方式声明变量" class="headerlink" title="ES5 和 ES6 分别几种方式声明变量"></a>ES5 和 ES6 分别几种方式声明变量</h2><ul><li>ES5 有俩种：var 和 function</li><li>ES6 有六种：增加四种，let、const、class 和 import</li></ul>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS经典规则</title>
      <link href="/2018/04/16/CSS%E7%BB%8F%E5%85%B8%E8%A7%84%E5%88%99/"/>
      <url>/2018/04/16/CSS%E7%BB%8F%E5%85%B8%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS经典规则"><a href="#CSS经典规则" class="headerlink" title="CSS经典规则"></a>CSS经典规则</h1><h3 id="使用方式-及-权重"><a href="#使用方式-及-权重" class="headerlink" title="使用方式 及 权重"></a>使用方式 及 权重</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.内联：直接在HTML元素上使用</span><br><span class="line">&lt;p style=<span class="string">&quot;color: red&quot;</span>&gt;&lt;/p&gt;</span><br><span class="line">2.外部:在工作空间中创建单独的CSS文件，然后在创建的每个web页面中链接它们</span><br><span class="line">&lt;<span class="built_in">head</span>&gt;</span><br><span class="line">&lt;<span class="built_in">link</span> rel=<span class="string">&quot;text/css&quot;</span> href=<span class="string">&quot;url&quot;</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">3. web 页面的 <span class="built_in">head</span> 元素在其中实现了内部 CSS。</span><br><span class="line">&lt;<span class="built_in">head</span>&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">p&#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 权重优先级 !important -&gt; 内联 -&gt; 最后读取的</span></span><br></pre></td></tr></table></figure><h3 id="伪类和伪元素是什么？如何区分？"><a href="#伪类和伪元素是什么？如何区分？" class="headerlink" title="伪类和伪元素是什么？如何区分？"></a>伪类和伪元素是什么？如何区分？</h3><ul><li>伪类是用来定义元素特殊状态的，他可以用来设置鼠标悬停样式、元素获取焦点样式、设置链接样式等。如常见的 hover、active、link 等都是伪类</li><li>伪元素也称为伪对象，它不存在于 DOM 文档中、是一个虚拟的元素。它可以用来代表某个元素的子元素，但是这个子元素并不存在于文档树中。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 伪类和伪元素的根本区别在于：是否创造了新的元素。</span></span><br><span class="line"><span class="comment"># html </span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;p class=<span class="string">&quot;one&quot;</span>&gt;红色&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;黑色&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="comment">#css 伪类</span></span><br><span class="line">p:first-child&#123;</span><br><span class="line">  color:red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># css 伪元素</span></span><br><span class="line">.one &#123;</span><br><span class="line">  color:red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="BFC-规范（块级格式化上下文：block-formatting-context）"><a href="#BFC-规范（块级格式化上下文：block-formatting-context）" class="headerlink" title="BFC 规范（块级格式化上下文：block formatting context）"></a>BFC 规范（块级格式化上下文：block formatting context）</h3><h4 id="BFC指的是块级格式化上下文，一个元素形成了BFC之后，那么它内部元素产生的布局不会影响到外部元素，外部元素的布局也不会影响到BFC中的内部元素。一个BFC就像是一个隔离区域，和其他区域互不影响。"><a href="#BFC指的是块级格式化上下文，一个元素形成了BFC之后，那么它内部元素产生的布局不会影响到外部元素，外部元素的布局也不会影响到BFC中的内部元素。一个BFC就像是一个隔离区域，和其他区域互不影响。" class="headerlink" title="BFC指的是块级格式化上下文，一个元素形成了BFC之后，那么它内部元素产生的布局不会影响到外部元素，外部元素的布局也不会影响到BFC中的内部元素。一个BFC就像是一个隔离区域，和其他区域互不影响。"></a>BFC指的是块级格式化上下文，一个元素形成了BFC之后，那么它内部元素产生的布局不会影响到外部元素，外部元素的布局也不会影响到BFC中的内部元素。一个BFC就像是一个隔离区域，和其他区域互不影响。</h4><h4 id="使得当前bfc区域内的元素都变为行内元素（块级格式化上下文）"><a href="#使得当前bfc区域内的元素都变为行内元素（块级格式化上下文）" class="headerlink" title="使得当前bfc区域内的元素都变为行内元素（块级格式化上下文）"></a>使得当前bfc区域内的元素都变为行内元素（块级格式化上下文）</h4><ul><li>1.浮动元素不为none；</li><li>2.position不为static；</li><li>3.display:inline-block；display:table-cell；display:table-caption；</li><li>4.overflow 计算值(Computed)不为 visible 的块元素</li><li>5.display:inline-flex;</li></ul><h3 id="IFC指的是行级格式化上下文，它有这样的一些布局规则："><a href="#IFC指的是行级格式化上下文，它有这样的一些布局规则：" class="headerlink" title="IFC指的是行级格式化上下文，它有这样的一些布局规则："></a>IFC指的是行级格式化上下文，它有这样的一些布局规则：</h3><ul><li>（1）行级上下文内部的盒子会在水平方向，一个接一个地放置。</li><li>（2）当一行不够的时候会自动切换到下一行。</li><li>（3）行级上下文的高度由内部最高的内联盒子的高度决定。</li></ul>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS常用垂直居中布局</title>
      <link href="/2018/04/15/CSS%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80/"/>
      <url>/2018/04/15/CSS%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS垂直居中布局"><a href="#CSS垂直居中布局" class="headerlink" title="CSS垂直居中布局"></a>CSS垂直居中布局</h1><h3 id="line-height-text-align-文字垂直居中"><a href="#line-height-text-align-文字垂直居中" class="headerlink" title="line-height + text-align 文字垂直居中"></a>line-height + text-align 文字垂直居中</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># html</span></span><br><span class="line">&lt;div class=<span class="string">&quot;example&quot;</span>&gt;Lorem ipsam.&lt;/div&gt;</span><br><span class="line"><span class="comment">#css</span></span><br><span class="line">.example&#123;</span><br><span class="line">  width: 400px;</span><br><span class="line">  background: <span class="comment">#afddf3;</span></span><br><span class="line">  line-height: 50px;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="absolute-margin"><a href="#absolute-margin" class="headerlink" title="absolute + margin"></a>absolute + margin</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># html</span></span><br><span class="line">&lt;div class=<span class="string">&quot;parant&quot;</span>&gt;</span><br><span class="line">  &lt;div class=<span class="string">&quot;child&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="comment">#css</span></span><br><span class="line">.parant &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 0;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  left: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  margin: auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#  原理：当元素设置为绝对定位后，假设它是抓不到整体可运用的空间范围，所以margin: auto会失效，但当你设置了top:0;bottom:0;时，绝对定位元素就抓到了可运用的空间了，这时你的margin:auto就生效了。</span></span><br></pre></td></tr></table></figure><h3 id="absolute-translate"><a href="#absolute-translate" class="headerlink" title="absolute + translate"></a>absolute + translate</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># html</span></span><br><span class="line">&lt;div class=<span class="string">&quot;parant&quot;</span>&gt;</span><br><span class="line">  &lt;div class=<span class="string">&quot;child&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="comment">#css</span></span><br><span class="line">.parant &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  left: 50%;</span><br><span class="line">  top: 50%;</span><br><span class="line">  transform: translate(-50%, -50%);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 原理：利用绝对定位时的top 与right设置元素的上方跟左方各为50%，再利用transform: translate(-50%, -50%);位移居中元素自身宽与高的50%就能达成居中的目的了。</span></span><br></pre></td></tr></table></figure><h3 id="Flex-align-items"><a href="#Flex-align-items" class="headerlink" title="Flex + align-items"></a>Flex + align-items</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># html</span></span><br><span class="line">&lt;div class=<span class="string">&quot;parant&quot;</span>&gt;</span><br><span class="line">  &lt;div class=<span class="string">&quot;child&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="comment">#css</span></span><br><span class="line">.parant &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  justify-content: center;</span><br><span class="line">  align-item: center</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS字符串常用的操作方法</title>
      <link href="/2018/04/14/JS%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/"/>
      <url>/2018/04/14/JS%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="JS字符串常用的操作方法"><a href="#JS字符串常用的操作方法" class="headerlink" title="JS字符串常用的操作方法"></a>JS字符串常用的操作方法</h1><ul><li>str.charAt(index) 返回指定index下标的字符 下标从0开始</li><li>str.includes(str1) 方法用于判断str1是否包含在str中，根据情况返回 true 或 false。</li><li>str.indexOf(str1) 方法用于判断str1是否包含在str中，返回存在的下标，无则-1</li><li>str.replace(regx,str) 按照regx的规则，将符合的替换成str</li><li>str.split(‘分隔符’) 将str按照分隔符转化成数组</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">var anyString = <span class="string">&quot;Brave new world&quot;</span>;</span><br><span class="line">console.log(<span class="string">&quot;The character at index 0   is &#x27;&quot;</span> + anyString.charAt(0)   + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">// The character at index 0 is <span class="string">&#x27;B&#x27;</span></span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">// str.includes(str1) 方法用于判断str1是否包含在str中，根据情况返回 <span class="literal">true</span> 或 <span class="literal">false</span>。 区分大小写</span><br><span class="line"><span class="string">&#x27;Blue Whale&#x27;</span>.includes(<span class="string">&#x27;blue&#x27;</span>); // returns <span class="literal">false</span></span><br><span class="line"><span class="string">&#x27;Blue Whale&#x27;</span>.includes(<span class="string">&#x27;Blue&#x27;</span>); // returns <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">//str.indexOf(str1) 方法用于判断str1是否包含在str中，返回存在的下标，无则-1</span><br><span class="line">const paragraph = <span class="string">&#x27;The quick brown fox jumps over the lazy dog. If the dog barked, was it really lazy?&#x27;</span>;</span><br><span class="line"></span><br><span class="line">const searchTerm = <span class="string">&#x27;dog&#x27;</span>;</span><br><span class="line">const indexOfFirst = paragraph.indexOf(searchTerm);</span><br><span class="line">console.log(indexOfFirst); // expected output: <span class="string">&quot;40&quot;</span></span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">// str.replace(regx,str) 按照regx的规则，将符合的替换成str</span><br><span class="line">const p = <span class="string">&#x27;The quick brown fox jumps over the lazy dog. If the dog reacted, was it really lazy?&#x27;</span>;</span><br><span class="line"></span><br><span class="line">console.log(p.replace(<span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;monkey&#x27;</span>));</span><br><span class="line">// expected output: <span class="string">&quot;The quick brown fox jumps over the lazy monkey. If the dog reacted, was it really lazy?&quot;</span></span><br><span class="line">const regex = /Dog/i;</span><br><span class="line">console.log(p.replace(regex, <span class="string">&#x27;ferret&#x27;</span>));</span><br><span class="line">// expected output: <span class="string">&quot;The quick brown fox jumps over the lazy ferret. If the dog reacted, was it really lazy?&quot;</span></span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">//str.split(<span class="string">&#x27;分隔符&#x27;</span>) 将str按照分隔符转化成数组</span><br><span class="line">const str = <span class="string">&#x27;The quick brown fox jumps over the lazy dog.&#x27;</span>;</span><br><span class="line">const words = str.split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">console.log(words[3]);// expected output: <span class="string">&quot;fox&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS数组常用的操作方法</title>
      <link href="/2018/04/13/JS%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/"/>
      <url>/2018/04/13/JS%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="JS数组常用的操作方法"><a href="#JS数组常用的操作方法" class="headerlink" title="JS数组常用的操作方法"></a>JS数组常用的操作方法</h2><ul><li>Array.length 获取数组长度</li><li>Array.shift() Array.unshift()  Array.push() Array.pop()</li><li>Array.concat(a1,a2….) 数组合并</li><li>Array.reverse() 数组元素颠倒</li><li>Array.join(‘拼接字符’) 数组转字符串</li><li>Array.indexOf(item) ||  Array.includes(item) 判断Item 是否存在数组里面 </li><li>Array.fill(填充val，下标1，下标2) 数组填充</li><li>[…new Set(arr)]数组去重 || Array.from(new Set(arr))</li><li>Array.slice(begin,end) 这一对象是一个由 begin 和 end 决定的原数组的浅拷贝</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">// Array.length 获取数组长度</span><br><span class="line">const clothing = [<span class="string">&#x27;shoes&#x27;</span>, <span class="string">&#x27;shirts&#x27;</span>, <span class="string">&#x27;socks&#x27;</span>, <span class="string">&#x27;sweaters&#x27;</span>];</span><br><span class="line">console.log(clothing.length); // 4</span><br><span class="line"></span><br><span class="line">// ---------------------------------------</span><br><span class="line"></span><br><span class="line">// Array.<span class="built_in">shift</span>() Array.unshift()  Array.push() Array.pop()</span><br><span class="line">const array1 = [1, 2, 3];</span><br><span class="line">// 往头部插入</span><br><span class="line">array1.unshift(4, 5); </span><br><span class="line">// array1: [4,5,1,2,3] </span><br><span class="line">// 往头部删除</span><br><span class="line">array1.shift() </span><br><span class="line">// array1: [5,1,2,3] </span><br><span class="line">// 往尾部插入</span><br><span class="line">array1.push(4)</span><br><span class="line">//  array1: [5,1,2,3,4] </span><br><span class="line">// 往尾部删除</span><br><span class="line">array1.pop()</span><br><span class="line">// array1: [5,1,2,3]</span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------</span><br><span class="line"></span><br><span class="line">//Array.reverse() 数组元素颠倒</span><br><span class="line">const array1 = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>];</span><br><span class="line">array1.reverse() // [<span class="string">&quot;three&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;one&quot;</span>]</span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------</span><br><span class="line"></span><br><span class="line">// Array.<span class="built_in">join</span>(<span class="string">&#x27;拼接字符&#x27;</span>) 数组转字符串</span><br><span class="line">const elements = [<span class="string">&#x27;Fire&#x27;</span>, <span class="string">&#x27;Air&#x27;</span>, <span class="string">&#x27;Water&#x27;</span>];</span><br><span class="line">console.log(elements.join());</span><br><span class="line">// expected output: <span class="string">&quot;Fire,Air,Water&quot;</span></span><br><span class="line"></span><br><span class="line">console.log(elements.join(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line">// expected output: <span class="string">&quot;FireAirWater&quot;</span></span><br><span class="line"></span><br><span class="line">console.log(elements.join(<span class="string">&#x27;-&#x27;</span>));</span><br><span class="line">// expected output: <span class="string">&quot;Fire-Air-Water&quot;</span></span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------</span><br><span class="line"></span><br><span class="line">// Array.indexOf(item) ||  Array.includes(item) 判断Item 是否存在数组里面</span><br><span class="line">const beasts = [<span class="string">&#x27;ant&#x27;</span>, <span class="string">&#x27;bison&#x27;</span>, <span class="string">&#x27;camel&#x27;</span>, <span class="string">&#x27;duck&#x27;</span>, <span class="string">&#x27;bison&#x27;</span>];</span><br><span class="line"></span><br><span class="line">console.log(beasts.indexOf(<span class="string">&#x27;bison&#x27;</span>));// expected output: 1</span><br><span class="line">console.log(beasts.includes(<span class="string">&#x27;bison&#x27;</span>));// expected output: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------</span><br><span class="line"></span><br><span class="line">// Array.concat(a1,a2....) 数组合并</span><br><span class="line">const array1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">const array2 = [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>];</span><br><span class="line">const array3 = array1.concat(array2);</span><br><span class="line"></span><br><span class="line">console.log(array3);// [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>]</span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------</span><br><span class="line"></span><br><span class="line">// Array.fill(填充val，下标1，下标2) 数组填充</span><br><span class="line">const array1 = [1, 2, 3, 4];</span><br><span class="line">console.log(array1.fill(0, 2, 4)); // [1, 2, 0, 0]</span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------</span><br><span class="line"></span><br><span class="line">//*[...new Set(arr)]数组去重 || Array.from(new Set(arr))</span><br><span class="line"><span class="keyword">function</span> unique (arr) &#123;</span><br><span class="line">  <span class="built_in">return</span> Array.from(new Set(arr))</span><br><span class="line">&#125;</span><br><span class="line">var arr = [1,1,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,15,15,<span class="literal">false</span>,<span class="literal">false</span>, undefined,undefined, null,null, NaN, NaN,<span class="string">&#x27;NaN&#x27;</span>, 0, 0, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line">console.log(unique(arr)) //[1, <span class="string">&quot;true&quot;</span>, <span class="literal">true</span>, 15, <span class="literal">false</span>, undefined, null, NaN, <span class="string">&quot;NaN&quot;</span>, 0, <span class="string">&quot;a&quot;</span>, &#123;&#125;, &#123;&#125;]</span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------</span><br><span class="line"></span><br><span class="line">// Array.slice(begin,end) 这一对象是一个由 begin 和 end 决定的原数组的浅拷贝</span><br><span class="line">const animals = [<span class="string">&#x27;ant&#x27;</span>, <span class="string">&#x27;bison&#x27;</span>, <span class="string">&#x27;camel&#x27;</span>, <span class="string">&#x27;duck&#x27;</span>, <span class="string">&#x27;elephant&#x27;</span>];</span><br><span class="line"></span><br><span class="line">console.log(animals.slice(2));</span><br><span class="line">// expected output: Array [<span class="string">&quot;camel&quot;</span>, <span class="string">&quot;duck&quot;</span>, <span class="string">&quot;elephant&quot;</span>]</span><br><span class="line"></span><br><span class="line">console.log(animals.slice(2, 4));</span><br><span class="line">// expected output: Array [<span class="string">&quot;camel&quot;</span>, <span class="string">&quot;duck&quot;</span>]</span><br><span class="line"></span><br><span class="line">console.log(animals.slice(1, 5));</span><br><span class="line">// expected output: Array [<span class="string">&quot;bison&quot;</span>, <span class="string">&quot;camel&quot;</span>, <span class="string">&quot;duck&quot;</span>, <span class="string">&quot;elephant&quot;</span>]</span><br><span class="line"></span><br><span class="line">console.log(animals.slice(-2));</span><br><span class="line">// expected output: Array [<span class="string">&quot;duck&quot;</span>, <span class="string">&quot;elephant&quot;</span>]</span><br><span class="line"></span><br><span class="line">console.log(animals.slice(2, -1));</span><br><span class="line">// expected output: Array [<span class="string">&quot;camel&quot;</span>, <span class="string">&quot;duck&quot;</span>]</span><br><span class="line"></span><br><span class="line">console.log(animals.slice());</span><br><span class="line">// expected output: Array [<span class="string">&quot;ant&quot;</span>, <span class="string">&quot;bison&quot;</span>, <span class="string">&quot;camel&quot;</span>, <span class="string">&quot;duck&quot;</span>, <span class="string">&quot;elephant&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Http版本区别与用户认证</title>
      <link href="/2018/04/12/Http-Description/"/>
      <url>/2018/04/12/Http-Description/</url>
      
        <content type="html"><![CDATA[<h1 id="Http版本区别与用户认证"><a href="#Http版本区别与用户认证" class="headerlink" title="Http版本区别与用户认证"></a><a href="">Http版本区别与用户认证</a></h1><p>HTTP协议(HyperTextTransferProtocol超文本传输协议)基于TCP&#x2F;IP通信协议来传递数据</p><h1 id="内容摘要："><a href="#内容摘要：" class="headerlink" title="内容摘要："></a>内容摘要：</h1><ul><li>Http版本</li><li>Session Cookie</li><li>Token</li><li>单点登陆</li><li>浏览器的缓存机制</li></ul><h2 id="Http版本"><a href="#Http版本" class="headerlink" title="Http版本"></a><strong>Http版本</strong></h2><h3 id="HTTP-x2F-1-0"><a href="#HTTP-x2F-1-0" class="headerlink" title="HTTP&#x2F;1.0"></a>HTTP&#x2F;1.0</h3><h4 id="每次请求都会打开一个新的TCP链接，收到响应后立即断开"><a href="#每次请求都会打开一个新的TCP链接，收到响应后立即断开" class="headerlink" title="每次请求都会打开一个新的TCP链接，收到响应后立即断开"></a>每次请求都会打开一个新的TCP链接，收到响应后立即断开</h4><h3 id="HTTP-x2F-1-1（增加了缓存控制策略）"><a href="#HTTP-x2F-1-1（增加了缓存控制策略）" class="headerlink" title="HTTP&#x2F;1.1（增加了缓存控制策略）"></a>HTTP&#x2F;1.1（增加了缓存控制策略）</h3><h4 id="1-0主要用Last-Modified和Expires做缓存判断，1-1引入了更多，如-Etag-Cache-Control-keep-alive"><a href="#1-0主要用Last-Modified和Expires做缓存判断，1-1引入了更多，如-Etag-Cache-Control-keep-alive" class="headerlink" title="1.0主要用Last-Modified和Expires做缓存判断，1.1引入了更多，如:Etag Cache-Control keep-alive"></a>1.0主要用Last-Modified和Expires做缓存判断，1.1引入了更多，如:Etag Cache-Control keep-alive</h4><h4 id="1-1默认开启持久连接（同一个TCP连接发送和接受多个http请求-x2F-应答），1-0需要手动开启connection-true"><a href="#1-1默认开启持久连接（同一个TCP连接发送和接受多个http请求-x2F-应答），1-0需要手动开启connection-true" class="headerlink" title="1.1默认开启持久连接（同一个TCP连接发送和接受多个http请求&#x2F;应答），1.0需要手动开启connection:true"></a>1.1默认开启持久连接（同一个TCP连接发送和接受多个http请求&#x2F;应答），1.0需要手动开启connection:true</h4><h4 id="http-pipeline-管道化-，允许在持久连接上可选地使用请求管道。在响应到达之前，可以将多条请求放入队列。当第一条请求通过网络流向服务器时，第二、第三条请求也可以开始发送。在高时延网络条件下，可以减低网络的环回时间提高性能"><a href="#http-pipeline-管道化-，允许在持久连接上可选地使用请求管道。在响应到达之前，可以将多条请求放入队列。当第一条请求通过网络流向服务器时，第二、第三条请求也可以开始发送。在高时延网络条件下，可以减低网络的环回时间提高性能" class="headerlink" title="http pipeline(管道化)，允许在持久连接上可选地使用请求管道。在响应到达之前，可以将多条请求放入队列。当第一条请求通过网络流向服务器时，第二、第三条请求也可以开始发送。在高时延网络条件下，可以减低网络的环回时间提高性能"></a>http pipeline(管道化)，允许在持久连接上可选地使用请求管道。在响应到达之前，可以将多条请求放入队列。当第一条请求通过网络流向服务器时，第二、第三条请求也可以开始发送。在高时延网络条件下，可以减低网络的环回时间提高性能</h4><h4 id="致命缺点-目前大部分浏览器和Web服务器，都关闭了管道化，采用非管道化模式"><a href="#致命缺点-目前大部分浏览器和Web服务器，都关闭了管道化，采用非管道化模式" class="headerlink" title="致命缺点(目前大部分浏览器和Web服务器，都关闭了管道化，采用非管道化模式)"></a>致命缺点(目前大部分浏览器和Web服务器，都关闭了管道化，采用非管道化模式)</h4><h4 id="造成队头阻塞，前一个响应未及时返回，后面的响应会被阻塞"><a href="#造成队头阻塞，前一个响应未及时返回，后面的响应会被阻塞" class="headerlink" title="造成队头阻塞，前一个响应未及时返回，后面的响应会被阻塞"></a><strong>造成队头阻塞，前一个响应未及时返回，后面的响应会被阻塞</strong></h4><h4 id="非管道化-完全串行执行，后一个请求必须在前一个响应之后发送，阻塞发生在客户端，http请求阻塞"><a href="#非管道化-完全串行执行，后一个请求必须在前一个响应之后发送，阻塞发生在客户端，http请求阻塞" class="headerlink" title="非管道化:完全串行执行，后一个请求必须在前一个响应之后发送，阻塞发生在客户端，http请求阻塞"></a>非管道化:完全串行执行，后一个请求必须在前一个响应之后发送，阻塞发生在客户端，http请求阻塞</h4><h4 id="管道化-请求可以并行发出，但响应必须串行返回。后一个响应必须在前一个响应之后。因没有序号表明顺序，只能串行接受。阻塞发生在服务端，http响应阻塞"><a href="#管道化-请求可以并行发出，但响应必须串行返回。后一个响应必须在前一个响应之后。因没有序号表明顺序，只能串行接受。阻塞发生在服务端，http响应阻塞" class="headerlink" title="管道化:请求可以并行发出，但响应必须串行返回。后一个响应必须在前一个响应之后。因没有序号表明顺序，只能串行接受。阻塞发生在服务端，http响应阻塞"></a>管道化:请求可以并行发出，但响应必须串行返回。后一个响应必须在前一个响应之后。因没有序号表明顺序，只能串行接受。阻塞发生在服务端，http响应阻塞</h4><h4 id="管道化的限制。只有幂等的请求比如-GET、HEAD-才能使用-pipelining"><a href="#管道化的限制。只有幂等的请求比如-GET、HEAD-才能使用-pipelining" class="headerlink" title="管道化的限制。只有幂等的请求比如 GET、HEAD 才能使用 pipelining"></a>管道化的限制。只有幂等的请求比如 GET、HEAD 才能使用 pipelining</h4><h3 id="解决"><a href="#解决" class="headerlink" title="解决:"></a><strong>解决:</strong></h3><h4 id="并发TCP连接-浏览器一个域名采用6-8个TCP链接，并发卜请求-一般中小型网站基本用不上，一个页面最多就2-3个接口"><a href="#并发TCP连接-浏览器一个域名采用6-8个TCP链接，并发卜请求-一般中小型网站基本用不上，一个页面最多就2-3个接口" class="headerlink" title="并发TCP连接(浏览器一个域名采用6-8个TCP链接，并发卜请求) 一般中小型网站基本用不上，一个页面最多就2-3个接口"></a>并发TCP连接(浏览器一个域名采用6-8个TCP链接，并发卜请求) 一般中小型网站基本用不上，一个页面最多就2-3个接口</h4><h4 id="域名分片-多个域名，可以建立更多的TCP链接，从而提高LTT请求的并发"><a href="#域名分片-多个域名，可以建立更多的TCP链接，从而提高LTT请求的并发" class="headerlink" title="域名分片(多个域名，可以建立更多的TCP链接，从而提高LTT请求的并发)"></a>域名分片(多个域名，可以建立更多的TCP链接，从而提高LTT请求的并发)</h4><h3 id="Http2-0-（引入帧和流）"><a href="#Http2-0-（引入帧和流）" class="headerlink" title="Http2.0 （引入帧和流）"></a>Http2.0 （引入帧和流）</h3><h4 id="新的二进制格式。-1-x基于文本"><a href="#新的二进制格式。-1-x基于文本" class="headerlink" title="新的二进制格式。 1.x基于文本"></a>新的二进制格式。 1.x基于文本</h4><h4 id="2-0方式-多路复用特性-将多个请求复用同一个tcp通道中，通过二进制分帧并且给每个帧打上流的-ID-去避免依次响应的问题，对方接收到帧之后根据-ID-拼接出流，这样就可以做到乱序响应从而避免请求时的队首阻塞问题"><a href="#2-0方式-多路复用特性-将多个请求复用同一个tcp通道中，通过二进制分帧并且给每个帧打上流的-ID-去避免依次响应的问题，对方接收到帧之后根据-ID-拼接出流，这样就可以做到乱序响应从而避免请求时的队首阻塞问题" class="headerlink" title="2.0方式(多路复用特性) 将多个请求复用同一个tcp通道中，通过二进制分帧并且给每个帧打上流的 ID 去避免依次响应的问题，对方接收到帧之后根据 ID 拼接出流，这样就可以做到乱序响应从而避免请求时的队首阻塞问题"></a>2.0方式(多路复用特性) 将多个请求复用同一个tcp通道中，通过二进制分帧并且给每个帧打上流的 ID 去避免依次响应的问题，对方接收到帧之后根据 ID 拼接出流，这样就可以做到乱序响应从而避免请求时的队首阻塞问题</h4><h4 id="头部压缩-使用encoder压缩"><a href="#头部压缩-使用encoder压缩" class="headerlink" title="头部压缩 使用encoder压缩"></a>头部压缩 使用encoder压缩</h4><h4 id="服务端推送，把客户端index-html需要的资源推送到浏览器并存在缓存中，等index加载时直接会优先读取缓存，而不用向服务器发起请求了"><a href="#服务端推送，把客户端index-html需要的资源推送到浏览器并存在缓存中，等index加载时直接会优先读取缓存，而不用向服务器发起请求了" class="headerlink" title="服务端推送，把客户端index.html需要的资源推送到浏览器并存在缓存中，等index加载时直接会优先读取缓存，而不用向服务器发起请求了"></a>服务端推送，把客户端index.html需要的资源推送到浏览器并存在缓存中，等index加载时直接会优先读取缓存，而不用向服务器发起请求了</h4><h4 id="缺陷：-为了向下兼容，服务端需要确认客户端是http1-x还是2-0，多做了一次TLS链接"><a href="#缺陷：-为了向下兼容，服务端需要确认客户端是http1-x还是2-0，多做了一次TLS链接" class="headerlink" title="缺陷： 为了向下兼容，服务端需要确认客户端是http1.x还是2.0，多做了一次TLS链接"></a><strong>缺陷：</strong> 为了向下兼容，服务端需要确认客户端是http1.x还是2.0，多做了一次TLS链接</h4><h4 id="多个请求是在同一个-TCP-管道中，这样当-HTTP-2-0-出现丢包时，整个-TCP-都要开始等待重传，那么就会阻塞该-TCP。连接中的所有请求。"><a href="#多个请求是在同一个-TCP-管道中，这样当-HTTP-2-0-出现丢包时，整个-TCP-都要开始等待重传，那么就会阻塞该-TCP。连接中的所有请求。" class="headerlink" title="多个请求是在同一个 TCP 管道中，这样当 HTTP 2.0 出现丢包时，整个 TCP 都要开始等待重传，那么就会阻塞该 TCP。连接中的所有请求。"></a>多个请求是在同一个 TCP 管道中，这样当 HTTP 2.0 出现丢包时，整个 TCP 都要开始等待重传，那么就会阻塞该 TCP。连接中的所有请求。</h4><h2 id="Session-Cookie"><a href="#Session-Cookie" class="headerlink" title="Session Cookie"></a><strong>Session Cookie</strong></h2><h4 id="Session-是存储在服务器端的文件里面，借助请求的响应在cookie上携带sessionId，服务器存在有一个sessionId与userId的映射表"><a href="#Session-是存储在服务器端的文件里面，借助请求的响应在cookie上携带sessionId，服务器存在有一个sessionId与userId的映射表" class="headerlink" title="Session 是存储在服务器端的文件里面，借助请求的响应在cookie上携带sessionId，服务器存在有一个sessionId与userId的映射表"></a>Session 是存储在服务器端的文件里面，借助请求的响应在cookie上携带sessionId，服务器存在有一个sessionId与userId的映射表</h4><h4 id="在多机部署的情况下，可用redies做中间层，缓存session，缺点是所有请求都要去redis获取session，为保障redies高可用性，必须做集群"><a href="#在多机部署的情况下，可用redies做中间层，缓存session，缺点是所有请求都要去redis获取session，为保障redies高可用性，必须做集群" class="headerlink" title="在多机部署的情况下，可用redies做中间层，缓存session，缺点是所有请求都要去redis获取session，为保障redies高可用性，必须做集群"></a>在多机部署的情况下，可用redies做中间层，缓存session，缺点是所有请求都要去redis获取session，为保障redies高可用性，必须做集群</h4><h4 id="Cookie-在发起请求和响应请求都会携带已存在的数据往返"><a href="#Cookie-在发起请求和响应请求都会携带已存在的数据往返" class="headerlink" title="Cookie 在发起请求和响应请求都会携带已存在的数据往返"></a>Cookie 在发起请求和响应请求都会携带已存在的数据往返</h4><h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a><strong>Token</strong></h2><h4 id="Token是由前端缓存在浏览器一段密文，一般通过设置请求头传递给后端，后端经过JWT去认证"><a href="#Token是由前端缓存在浏览器一段密文，一般通过设置请求头传递给后端，后端经过JWT去认证" class="headerlink" title="Token是由前端缓存在浏览器一段密文，一般通过设置请求头传递给后端，后端经过JWT去认证"></a>Token是由前端缓存在浏览器一段密文，一般通过设置请求头传递给后端，后端经过JWT去认证</h4><h2 id="单点登陆"><a href="#单点登陆" class="headerlink" title="单点登陆"></a><strong>单点登陆</strong></h2><h4 id="简称SSO，一般定义在多个应用系统中，用户只需登陆一次就可以访问所有互相信任的应用系统"><a href="#简称SSO，一般定义在多个应用系统中，用户只需登陆一次就可以访问所有互相信任的应用系统" class="headerlink" title="简称SSO，一般定义在多个应用系统中，用户只需登陆一次就可以访问所有互相信任的应用系统"></a>简称SSO，一般定义在多个应用系统中，用户只需登陆一次就可以访问所有互相信任的应用系统</h4><h4 id="一般是由登陆中间层应用去控制用户的登陆，一旦登陆成功，以后其它系统携带该用户信息访问进来时重定向并携带该用户的token返回去，再用当前应用系统验证token，向客户端响应当前用户信息"><a href="#一般是由登陆中间层应用去控制用户的登陆，一旦登陆成功，以后其它系统携带该用户信息访问进来时重定向并携带该用户的token返回去，再用当前应用系统验证token，向客户端响应当前用户信息" class="headerlink" title="一般是由登陆中间层应用去控制用户的登陆，一旦登陆成功，以后其它系统携带该用户信息访问进来时重定向并携带该用户的token返回去，再用当前应用系统验证token，向客户端响应当前用户信息"></a>一般是由登陆中间层应用去控制用户的登陆，一旦登陆成功，以后其它系统携带该用户信息访问进来时重定向并携带该用户的token返回去，再用当前应用系统验证token，向客户端响应当前用户信息</h4><h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a><strong>浏览器缓存</strong></h2><h4 id="Web-缓存大致可以分为：数据库缓存、服务器端缓存（代理服务器缓存、CDN-缓存）、浏览器缓存。"><a href="#Web-缓存大致可以分为：数据库缓存、服务器端缓存（代理服务器缓存、CDN-缓存）、浏览器缓存。" class="headerlink" title="Web 缓存大致可以分为：数据库缓存、服务器端缓存（代理服务器缓存、CDN 缓存）、浏览器缓存。"></a>Web 缓存大致可以分为：数据库缓存、服务器端缓存（代理服务器缓存、CDN 缓存）、浏览器缓存。</h4><h4 id="浏览器缓存也包含很多内容：-HTTP-缓存、indexDB、cookie、localstorage-等等。这里我们只讨论-HTTP-缓存相关内容"><a href="#浏览器缓存也包含很多内容：-HTTP-缓存、indexDB、cookie、localstorage-等等。这里我们只讨论-HTTP-缓存相关内容" class="headerlink" title="浏览器缓存也包含很多内容： HTTP 缓存、indexDB、cookie、localstorage 等等。这里我们只讨论 HTTP 缓存相关内容"></a>浏览器缓存也包含很多内容： HTTP 缓存、indexDB、cookie、localstorage 等等。这里我们只讨论 HTTP 缓存相关内容</h4><h4 id="HTTP-缓存术语："><a href="#HTTP-缓存术语：" class="headerlink" title="HTTP 缓存术语："></a>HTTP 缓存术语：</h4><h4 id="缓存命中率：从缓存中得到数据的请求数与所有请求数的比率。理想状态是越高越好。"><a href="#缓存命中率：从缓存中得到数据的请求数与所有请求数的比率。理想状态是越高越好。" class="headerlink" title="* 缓存命中率：从缓存中得到数据的请求数与所有请求数的比率。理想状态是越高越好。"></a>* 缓存命中率：从缓存中得到数据的请求数与所有请求数的比率。理想状态是越高越好。</h4><h4 id="过期内容：超过设置的有效时间，被标记为“陈旧”的内容。通常过期内容不能用于回复客户端的请求，必须重新向源服务器请求新的内容或者验证缓存的内容是否仍然准备。"><a href="#过期内容：超过设置的有效时间，被标记为“陈旧”的内容。通常过期内容不能用于回复客户端的请求，必须重新向源服务器请求新的内容或者验证缓存的内容是否仍然准备。" class="headerlink" title="* 过期内容：超过设置的有效时间，被标记为“陈旧”的内容。通常过期内容不能用于回复客户端的请求，必须重新向源服务器请求新的内容或者验证缓存的内容是否仍然准备。"></a>* 过期内容：超过设置的有效时间，被标记为“陈旧”的内容。通常过期内容不能用于回复客户端的请求，必须重新向源服务器请求新的内容或者验证缓存的内容是否仍然准备。</h4><h4 id="验证：验证缓存中的过期内容是否仍然有效，验证通过的话刷新过期时间。"><a href="#验证：验证缓存中的过期内容是否仍然有效，验证通过的话刷新过期时间。" class="headerlink" title="* 验证：验证缓存中的过期内容是否仍然有效，验证通过的话刷新过期时间。"></a>* 验证：验证缓存中的过期内容是否仍然有效，验证通过的话刷新过期时间。</h4><h4 id="失效：失效就是把内容从缓存中移除。当内容发生改变时就必须移除失效的内容。"><a href="#失效：失效就是把内容从缓存中移除。当内容发生改变时就必须移除失效的内容。" class="headerlink" title="* 失效：失效就是把内容从缓存中移除。当内容发生改变时就必须移除失效的内容。"></a>* 失效：失效就是把内容从缓存中移除。当内容发生改变时就必须移除失效的内容。</h4><h4 id="浏览器缓存主要是-HTTP-协议定义的缓存机制。HTML-meta-标签，例如"><a href="#浏览器缓存主要是-HTTP-协议定义的缓存机制。HTML-meta-标签，例如" class="headerlink" title="浏览器缓存主要是 HTTP 协议定义的缓存机制。HTML meta 标签，例如"></a>浏览器缓存主要是 HTTP 协议定义的缓存机制。HTML meta 标签，例如</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;META HTTP-EQUIV=<span class="string">&quot;Pragma&quot;</span> CONTENT=<span class="string">&quot;no-store&quot;</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="含义是让浏览器不缓存当前页面。但是代理服务器不解析-HTML-内容，一般应用广泛的是用-HTTP-头信息控制缓存"><a href="#含义是让浏览器不缓存当前页面。但是代理服务器不解析-HTML-内容，一般应用广泛的是用-HTTP-头信息控制缓存" class="headerlink" title="含义是让浏览器不缓存当前页面。但是代理服务器不解析 HTML 内容，一般应用广泛的是用 HTTP 头信息控制缓存"></a>含义是让浏览器不缓存当前页面。但是代理服务器不解析 HTML 内容，一般应用广泛的是用 HTTP 头信息控制缓存</h4><h4 id="浏览器缓存分为强缓存和协商缓存，浏览器加载一个页面的简单流程如下："><a href="#浏览器缓存分为强缓存和协商缓存，浏览器加载一个页面的简单流程如下：" class="headerlink" title="浏览器缓存分为强缓存和协商缓存，浏览器加载一个页面的简单流程如下："></a>浏览器缓存分为强缓存和协商缓存，浏览器加载一个页面的简单流程如下：</h4><h4 id="1-浏览器先根据这个资源的http头信息来判断是否命中强缓存。如果命中则直接加在缓存中的资源，并不会将请求发送到服务器。（强缓存）"><a href="#1-浏览器先根据这个资源的http头信息来判断是否命中强缓存。如果命中则直接加在缓存中的资源，并不会将请求发送到服务器。（强缓存）" class="headerlink" title="1. 浏览器先根据这个资源的http头信息来判断是否命中强缓存。如果命中则直接加在缓存中的资源，并不会将请求发送到服务器。（强缓存）"></a>1. 浏览器先根据这个资源的http头信息来判断是否命中强缓存。如果命中则直接加在缓存中的资源，并不会将请求发送到服务器。（强缓存）</h4><h4 id="2-如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。服务器来判断浏览器本地缓存是否失效。若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源。（协商缓存）"><a href="#2-如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。服务器来判断浏览器本地缓存是否失效。若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源。（协商缓存）" class="headerlink" title="2. 如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。服务器来判断浏览器本地缓存是否失效。若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源。（协商缓存）"></a>2. 如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。服务器来判断浏览器本地缓存是否失效。若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源。（协商缓存）</h4><h4 id="3-如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。（新的请求）"><a href="#3-如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。（新的请求）" class="headerlink" title="3. 如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。（新的请求）"></a>3. 如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。（新的请求）</h4><h4 id="命中强缓存时，浏览器并不会将请求发送给服务器。在Chrome的开发者工具中看到http的返回码是200，但是在Size列会显示为-from-cache-。"><a href="#命中强缓存时，浏览器并不会将请求发送给服务器。在Chrome的开发者工具中看到http的返回码是200，但是在Size列会显示为-from-cache-。" class="headerlink" title="命中强缓存时，浏览器并不会将请求发送给服务器。在Chrome的开发者工具中看到http的返回码是200，但是在Size列会显示为(from cache)。"></a>命中强缓存时，浏览器并不会将请求发送给服务器。在Chrome的开发者工具中看到http的返回码是200，但是在Size列会显示为(from cache)。</h4><h4 id="疑问解答"><a href="#疑问解答" class="headerlink" title="疑问解答"></a><strong>疑问解答</strong></h4><h4 id="为什么我更新我更新前端资源文件，从新打开链接需要刷新一下才能生效呢？"><a href="#为什么我更新我更新前端资源文件，从新打开链接需要刷新一下才能生效呢？" class="headerlink" title="为什么我更新我更新前端资源文件，从新打开链接需要刷新一下才能生效呢？"></a>为什么我更新我更新前端资源文件，从新打开链接需要刷新一下才能生效呢？</h4><h4 id="因为这时候由于你客户端近期在你更新之前是已经访问过该链接，而且缓存过期时间还没失效，这时候命中的是强缓存，当刷新网页时，跳过强缓存，但是会检查协商缓存；浏览器会将资源加载请求发送到服务器，服务器检测到当前加载资源已更新，则将完整的资源返回给浏览器。"><a href="#因为这时候由于你客户端近期在你更新之前是已经访问过该链接，而且缓存过期时间还没失效，这时候命中的是强缓存，当刷新网页时，跳过强缓存，但是会检查协商缓存；浏览器会将资源加载请求发送到服务器，服务器检测到当前加载资源已更新，则将完整的资源返回给浏览器。" class="headerlink" title="因为这时候由于你客户端近期在你更新之前是已经访问过该链接，而且缓存过期时间还没失效，这时候命中的是强缓存，当刷新网页时，跳过强缓存，但是会检查协商缓存；浏览器会将资源加载请求发送到服务器，服务器检测到当前加载资源已更新，则将完整的资源返回给浏览器。"></a>因为这时候由于你客户端近期在你更新之前是已经访问过该链接，而且缓存过期时间还没失效，这时候命中的是强缓存，当刷新网页时，跳过强缓存，但是会检查协商缓存；浏览器会将资源加载请求发送到服务器，服务器检测到当前加载资源已更新，则将完整的资源返回给浏览器。</h4><h4 id="强制刷新页面，浏览器会直接忽略本地的缓存（有缓存也会认为本地没有缓存），在请求中加上字段：Cache-Control-no-cache（或-Pragma-no-cache），发包向服务重新拉取文件。"><a href="#强制刷新页面，浏览器会直接忽略本地的缓存（有缓存也会认为本地没有缓存），在请求中加上字段：Cache-Control-no-cache（或-Pragma-no-cache），发包向服务重新拉取文件。" class="headerlink" title="强制刷新页面，浏览器会直接忽略本地的缓存（有缓存也会认为本地没有缓存），在请求中加上字段：Cache-Control:no-cache（或 Pragma:no-cache），发包向服务重新拉取文件。"></a>强制刷新页面，浏览器会直接忽略本地的缓存（有缓存也会认为本地没有缓存），在请求中加上字段：Cache-Control:no-cache（或 Pragma:no-cache），发包向服务重新拉取文件。</h4><h4 id="Dom-Storage-存储机制"><a href="#Dom-Storage-存储机制" class="headerlink" title="Dom Storage 存储机制"></a>Dom Storage 存储机制</h4><h4 id="sessionStorage浏览器缓存（浏览器关闭则移除）-和-localStorage本地存储（不清楚则永久存在）（5M）"><a href="#sessionStorage浏览器缓存（浏览器关闭则移除）-和-localStorage本地存储（不清楚则永久存在）（5M）" class="headerlink" title="sessionStorage浏览器缓存（浏览器关闭则移除） 和 localStorage本地存储（不清楚则永久存在）（5M）"></a>sessionStorage浏览器缓存（浏览器关闭则移除） 和 localStorage本地存储（不清楚则永久存在）（5M）</h4><h4 id="应用场景：-页面意外关闭的数据恢复"><a href="#应用场景：-页面意外关闭的数据恢复" class="headerlink" title="应用场景： 页面意外关闭的数据恢复"></a>应用场景： 页面意外关闭的数据恢复</h4><h4 id="Application-Cache-机制"><a href="#Application-Cache-机制" class="headerlink" title="Application Cache 机制"></a>Application Cache 机制</h4><h4 id="浏览器在首次加载-HTML-文件时，会解析-manifest-属性，-lt-html-manifest-quot-demo-html-appcache-quot-gt-并读取-manifest-文件，获取-Section：CACHE-MANIFEST-下要缓存的文件列表，再对文件缓存。（一般游戏的应用的比较多）"><a href="#浏览器在首次加载-HTML-文件时，会解析-manifest-属性，-lt-html-manifest-quot-demo-html-appcache-quot-gt-并读取-manifest-文件，获取-Section：CACHE-MANIFEST-下要缓存的文件列表，再对文件缓存。（一般游戏的应用的比较多）" class="headerlink" title="浏览器在首次加载 HTML 文件时，会解析 manifest 属性，&lt;html manifest=&quot;demo_html.appcache&quot;&gt; 并读取 manifest 文件，获取 Section：CACHE MANIFEST 下要缓存的文件列表，再对文件缓存。（一般游戏的应用的比较多）"></a>浏览器在首次加载 HTML 文件时，会解析 manifest 属性，<code>&lt;html manifest=&quot;demo_html.appcache&quot;&gt;</code> 并读取 manifest 文件，获取 Section：CACHE MANIFEST 下要缓存的文件列表，再对文件缓存。（一般游戏的应用的比较多）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line"><span class="comment"># 2012-02-21 v1.0.0</span></span><br><span class="line">/theme.css</span><br><span class="line">/logo.gif</span><br><span class="line">/main.js</span><br><span class="line"> </span><br><span class="line">NETWORK:</span><br><span class="line">login.asp</span><br><span class="line"> </span><br><span class="line">FALLBACK:</span><br><span class="line">/html/ /offline.html </span><br></pre></td></tr></table></figure><h4 id="AppCache-在首次加载生成后，也有更新机制。被缓存的文件如果要更新，需要更新-manifest-文件。因为浏览器在下次加载时，除了会默认使用缓存外，还会在后台检查-manifest-文件有没有修改（byte-by-byte-。发现有修改，就会重新获取-manifest-文件，对-Section：CACHE-MANIFEST-下文件列表检查更新。manifest-文件与缓存文件的检查更新也遵守浏览器缓存机制。"><a href="#AppCache-在首次加载生成后，也有更新机制。被缓存的文件如果要更新，需要更新-manifest-文件。因为浏览器在下次加载时，除了会默认使用缓存外，还会在后台检查-manifest-文件有没有修改（byte-by-byte-。发现有修改，就会重新获取-manifest-文件，对-Section：CACHE-MANIFEST-下文件列表检查更新。manifest-文件与缓存文件的检查更新也遵守浏览器缓存机制。" class="headerlink" title="AppCache 在首次加载生成后，也有更新机制。被缓存的文件如果要更新，需要更新 manifest 文件。因为浏览器在下次加载时，除了会默认使用缓存外，还会在后台检查 manifest 文件有没有修改（byte by byte)。发现有修改，就会重新获取 manifest 文件，对 Section：CACHE MANIFEST 下文件列表检查更新。manifest 文件与缓存文件的检查更新也遵守浏览器缓存机制。"></a>AppCache 在首次加载生成后，也有更新机制。被缓存的文件如果要更新，需要更新 manifest 文件。因为浏览器在下次加载时，除了会默认使用缓存外，还会在后台检查 manifest 文件有没有修改（byte by byte)。发现有修改，就会重新获取 manifest 文件，对 Section：CACHE MANIFEST 下文件列表检查更新。manifest 文件与缓存文件的检查更新也遵守浏览器缓存机制。</h4><h3 id="移动端-Web-加载性能（缓存）优化"><a href="#移动端-Web-加载性能（缓存）优化" class="headerlink" title="移动端 Web 加载性能（缓存）优化"></a><strong>移动端 Web 加载性能（缓存）优化</strong></h3><h4 id="通过对一些-H5页面进行调试及抓包发现，每次加载一个-H5页面，都会有较多的请求。除了-HTML-主-URL-自身的请求外，HTML外部引用的-JS、CSS、字体文件、图片都是一个独立的-HTTP-请求，每一个请求都串行的（可能有连接复用）。这么多请求串起来，再加上浏览器解析、渲染的时间，Web-整体的加载时间变得较长；请求文件越多，消耗的流量也会越多。我们可综合使用上面说到几种缓存机制，来帮助我们优化-Web-的加载性能。"><a href="#通过对一些-H5页面进行调试及抓包发现，每次加载一个-H5页面，都会有较多的请求。除了-HTML-主-URL-自身的请求外，HTML外部引用的-JS、CSS、字体文件、图片都是一个独立的-HTTP-请求，每一个请求都串行的（可能有连接复用）。这么多请求串起来，再加上浏览器解析、渲染的时间，Web-整体的加载时间变得较长；请求文件越多，消耗的流量也会越多。我们可综合使用上面说到几种缓存机制，来帮助我们优化-Web-的加载性能。" class="headerlink" title="通过对一些 H5页面进行调试及抓包发现，每次加载一个 H5页面，都会有较多的请求。除了 HTML 主 URL 自身的请求外，HTML外部引用的 JS、CSS、字体文件、图片都是一个独立的 HTTP 请求，每一个请求都串行的（可能有连接复用）。这么多请求串起来，再加上浏览器解析、渲染的时间，Web 整体的加载时间变得较长；请求文件越多，消耗的流量也会越多。我们可综合使用上面说到几种缓存机制，来帮助我们优化 Web 的加载性能。"></a>通过对一些 H5页面进行调试及抓包发现，每次加载一个 H5页面，都会有较多的请求。除了 HTML 主 URL 自身的请求外，HTML外部引用的 JS、CSS、字体文件、图片都是一个独立的 HTTP 请求，每一个请求都串行的（可能有连接复用）。这么多请求串起来，再加上浏览器解析、渲染的时间，Web 整体的加载时间变得较长；请求文件越多，消耗的流量也会越多。我们可综合使用上面说到几种缓存机制，来帮助我们优化 Web 的加载性能。</h4>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Http Https Session Cookie Token </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS对象常用的操作方法</title>
      <link href="/2018/04/11/JS%E5%AF%B9%E8%B1%A1%E5%B8%B8%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/"/>
      <url>/2018/04/11/JS%E5%AF%B9%E8%B1%A1%E5%B8%B8%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="JS对象常用的操作方法"><a href="#JS对象常用的操作方法" class="headerlink" title="JS对象常用的操作方法"></a>JS对象常用的操作方法</h2><ul><li>Object.assign(obj1,obj2) 对象合并，相同key后者替换前者</li><li>JSON.parse(JSON.stringify(obj1))对象深拷贝</li><li>Object.values(obj) 枚举对象属性值的数组 Object.keys(obj) 枚举对象keys的数组</li><li>Object.prototype.toString.call(obj) &#x3D;&#x3D;&#x3D; ‘[object object] 判断对象 || constructor</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 复制一个对象</span><br><span class="line">const obj = &#123; a: 1 &#125;;</span><br><span class="line">const copy = Object.assign(&#123;&#125;, obj);</span><br><span class="line">console.log(copy); // &#123; a: 1 &#125;</span><br><span class="line"></span><br><span class="line">// 对象深拷贝Deep Clone</span><br><span class="line">const  obj1 = &#123; a: 0 , b: &#123; c: 0&#125;&#125;;</span><br><span class="line"><span class="built_in">let</span> obj3 = JSON.parse(JSON.stringify(obj1));</span><br><span class="line">obj1.a = 4;</span><br><span class="line">obj1.b.c = 4;</span><br><span class="line"></span><br><span class="line">//obj3: &#123; a: 0, b: &#123; c: 0&#125;&#125;</span><br><span class="line"></span><br><span class="line">// Object.values(obj) Object.keys(obj)</span><br><span class="line">var obj = &#123; 0: <span class="string">&#x27;a&#x27;</span>, 1: <span class="string">&#x27;b&#x27;</span>, 2: <span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line">console.log(Object.values(obj)); // [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>] </span><br><span class="line">console.log(Object.keys(obj)); // [<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>]</span><br><span class="line"></span><br><span class="line">// Object.prototype.toString.call(obj) === <span class="string">&#x27;[object object]&#x27;</span></span><br><span class="line">var o = &#123;&#125;;</span><br><span class="line">o.constructor === Object; // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">var o = new Object;</span><br><span class="line">o.constructor === Object; // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">var a = [];</span><br><span class="line">a.constructor === Array; // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">var a = new Array;</span><br><span class="line">a.constructor === Array // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">var n = new Number(3);</span><br><span class="line">n.constructor === Number; // <span class="literal">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Object </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS操作DOM的方法与实践</title>
      <link href="/2018/04/11/JS%E6%93%8D%E4%BD%9CDOM%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
      <url>/2018/04/11/JS%E6%93%8D%E4%BD%9CDOM%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="DOM的基本介绍（提纲）"><a href="#DOM的基本介绍（提纲）" class="headerlink" title="DOM的基本介绍（提纲）"></a>DOM的基本介绍（提纲）</h2><h3 id="html文档中的内容以”树形结构”呈现-即大家常说的-文档树"><a href="#html文档中的内容以”树形结构”呈现-即大家常说的-文档树" class="headerlink" title="html文档中的内容以”树形结构”呈现,即大家常说的: 文档树;"></a>html文档中的内容以”树形结构”呈现,即大家常说的: 文档树;</h3><h3 id="文档树中的每个组成部分-称为之”节点”-即-Node类型-文档中的每一个具体的节点-都是一个Node对象-节点对象"><a href="#文档树中的每个组成部分-称为之”节点”-即-Node类型-文档中的每一个具体的节点-都是一个Node对象-节点对象" class="headerlink" title="文档树中的每个组成部分,称为之”节点”, 即 Node类型,文档中的每一个具体的节点,都是一个Node对象:节点对象;"></a>文档树中的每个组成部分,称为之”节点”, 即 Node类型,文档中的每一个具体的节点,都是一个Node对象:节点对象;</h3><h3 id="文档树中-最重要的三类节点是-Document文档节点-Element元素节点-Text文本节点"><a href="#文档树中-最重要的三类节点是-Document文档节点-Element元素节点-Text文本节点" class="headerlink" title="文档树中,最重要的三类节点是: Document文档节点, Element元素节点, Text文本节点"></a>文档树中,最重要的三类节点是: Document文档节点, Element元素节点, Text文本节点</h3><h2 id="选择页面元素的方法"><a href="#选择页面元素的方法" class="headerlink" title="选择页面元素的方法"></a>选择页面元素的方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// html</span><br><span class="line">&lt;h3 <span class="built_in">id</span>=<span class="string">&quot;header&quot;</span> class=<span class="string">&quot;red&quot;</span> style=<span class="string">&quot;color:green;&quot;</span> title=<span class="string">&quot;php.cn&quot;</span>&gt;Text&lt;/h3&gt;</span><br><span class="line">// js</span><br><span class="line">//获取当前ID为header的节点</span><br><span class="line">document.getElementById(<span class="string">&#x27;header&#x27;</span>);</span><br><span class="line">// 获取当前class为red的所有节点，返回一个数组</span><br><span class="line">document.getElementByClassName(<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line"></span><br><span class="line">// 获取当前h3所有节点，返回一个数组</span><br><span class="line">document.getElementByTagName(<span class="string">&#x27;h3&#x27;</span>)</span><br><span class="line">// 获取当前input标签 name为username所有节点，返回一个数组</span><br><span class="line">document.getElementByName(<span class="string">&#x27;username&#x27;</span>);</span><br><span class="line"></span><br><span class="line">document.querySelector(); //返回第一个匹配元素</span><br><span class="line">document.querySelectorAll(); //返回所有匹配元素</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="DOM元素的基本操作"><a href="#DOM元素的基本操作" class="headerlink" title="DOM元素的基本操作"></a>DOM元素的基本操作</h2><ul><li>创建:createElement(‘p’);</li><li>插入:parentNode.appendChild(‘p’);</li><li>删除:removeChild(‘p’);</li><li>更新:replaceChild(‘p’,old);</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;<span class="built_in">head</span>&gt;</span><br><span class="line">&lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;实战热身&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;info&quot;</span>&gt;</span><br><span class="line">&lt;button&gt;提交&lt;/button&gt;</span><br><span class="line">&lt;br&gt;&lt;br&gt;</span><br><span class="line">&lt;ul&gt;&lt;/ul&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">//美化样式</span><br><span class="line">    <span class="built_in">let</span> a = document.getElementsByTagName(<span class="string">&#x27;input&#x27;</span>)[0];</span><br><span class="line">    <span class="built_in">let</span> b = document.getElementsByTagName(<span class="string">&#x27;button&#x27;</span>)[0];</span><br><span class="line">    console.log(a)</span><br><span class="line">    a.setAttribute(<span class="string">&#x27;style&#x27;</span>,<span class="string">&#x27;height: 8px;width: 258px;border: 1px solid #ccc;margin-top: 6px;font-size: 16px;padding: 20px;float: left;&#x27;</span>);</span><br><span class="line">b.setAttribute(<span class="string">&#x27;style&#x27;</span>,<span class="string">&#x27;height: 50px;width: 100px;border: 1px solid #ccc;margin-top: 6px;font-size: 20px;background: #FF6A00;color: white;border: none;float: left;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">//获取元素</span><br><span class="line">  <span class="built_in">let</span> input = document.getElementsByName(<span class="string">&#x27;info&#x27;</span>)[0];</span><br><span class="line">  <span class="built_in">let</span> button = document.getElementsByTagName(<span class="string">&#x27;button&#x27;</span>)[0];</span><br><span class="line">  <span class="built_in">let</span> ul = document.getElementsByTagName(<span class="string">&#x27;ul&#x27;</span>)[0];</span><br><span class="line"></span><br><span class="line">  button.onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">   <span class="built_in">let</span> li = document.createElement(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">   li.innerHTML = input.value; //文本框的内容</span><br><span class="line">   ul.appendChild(li); //将用户信息显示到列表中</span><br><span class="line">   input.value = <span class="string">&#x27;&#x27;</span>; //将文本框内容清空</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS遍历数组的方法</title>
      <link href="/2018/04/10/JS%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2018/04/10/JS%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="js遍历数组的几种方法"><a href="#js遍历数组的几种方法" class="headerlink" title="js遍历数组的几种方法"></a>js遍历数组的几种方法</h1><ul><li>for 最快</li><li>forEach (不产生新的数组，效率没有map快)</li><li>map （产生新的数组）</li><li>for…….of </li><li>for….in(效率最慢，一般用与遍历对象)</li><li>some and every (返回布尔值)</li><li>filter （返回符合条件的某一项） findIndex （返回符合条件的下标，无则-1）</li><li>while (条件循环)</li></ul><h2 id="第一种：for循环，也是最常见的"><a href="#第一种：for循环，也是最常见的" class="headerlink" title="第一种：for循环，也是最常见的"></a>第一种：for循环，也是最常见的</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">  console.log(arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach(<span class="keyword">function</span>(item)&#123;</span><br><span class="line">  console.log(item)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const newArr = arr.map(<span class="keyword">function</span>(item)&#123;</span><br><span class="line">  console.log(item)</span><br><span class="line">  <span class="built_in">return</span> item</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> item of arr)&#123;</span><br><span class="line">  console.log(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for…-in-遍历对象"><a href="#for…-in-遍历对象" class="headerlink" title="for…..in 遍历对象"></a>for…..in 遍历对象</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">  console.log(key + <span class="string">&#x27;---&#x27;</span> + obj[key] )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="some-and-every-返回布尔值"><a href="#some-and-every-返回布尔值" class="headerlink" title="some and every (返回布尔值)"></a>some and every (返回布尔值)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const array = [1, 2, 3, 4, 5];</span><br><span class="line">const someBool = array.some((item)=&gt;&#123;</span><br><span class="line">  <span class="keyword">if</span>(item &gt; 2) &#123;</span><br><span class="line">    // 满足条件中止循环</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// someBool 为<span class="literal">true</span></span><br><span class="line">const everyBool = array.every((item)=&gt;&#123;</span><br><span class="line">  <span class="keyword">if</span>(item &gt; 2) </span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  // 只要有一项不符合就中止循环 <span class="built_in">return</span> <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line">// everyBool为<span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="filter-（返回符合条件的所有项）-findIndex-（返回符合条件的下标，无则-1）"><a href="#filter-（返回符合条件的所有项）-findIndex-（返回符合条件的下标，无则-1）" class="headerlink" title="filter （返回符合条件的所有项） findIndex （返回符合条件的下标，无则-1）"></a>filter （返回符合条件的所有项） findIndex （返回符合条件的下标，无则-1）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const array = [1, 2, 3, 4, 5];</span><br><span class="line">const filterItem = array.filter((item)=&gt;&#123;</span><br><span class="line">  <span class="keyword">if</span>(item &gt; 2) &#123;</span><br><span class="line">    <span class="built_in">return</span> item</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// filterItem: [3,4,5]</span><br><span class="line">const findIndex = array.findIndex((item)=&gt;&#123;</span><br><span class="line">  <span class="keyword">if</span>(item &gt; 2) &#123;</span><br><span class="line">    <span class="built_in">return</span> item</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// findIndex: 2</span><br></pre></td></tr></table></figure><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> i = 0</span><br><span class="line"><span class="keyword">while</span>(i &lt; arr.length)&#123;</span><br><span class="line">  i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建我的博客</title>
      <link href="/2018/04/10/First-Blog/"/>
      <url>/2018/04/10/First-Blog/</url>
      
        <content type="html"><![CDATA[<h1 id="从零开始搭建我的博客"><a href="#从零开始搭建我的博客" class="headerlink" title="从零开始搭建我的博客"></a><a href="https://github.com/13725102796/13725102796.github.io">从零开始搭建我的博客</a></h1><h3 id="node-v16-14-0-npm-8-3-1"><a href="#node-v16-14-0-npm-8-3-1" class="headerlink" title="node v16.14.0 npm 8.3.1"></a><code>node v16.14.0</code> <code>npm 8.3.1</code></h3><h1 id="搭建步骤："><a href="#搭建步骤：" class="headerlink" title="搭建步骤："></a>搭建步骤：</h1><ul><li>GitHub创建个人仓库</li><li>安装Hexo</li><li>使用Hexo</li><li>命令简写</li></ul><h2 id="GitHub创建个人仓库"><a href="#GitHub创建个人仓库" class="headerlink" title="GitHub创建个人仓库"></a><strong>GitHub创建个人仓库</strong></h2><h4 id="在Github创建新仓库，仓库名应该为：用户名-github-io-比如我的仓库名为13725102796-github-io"><a href="#在Github创建新仓库，仓库名应该为：用户名-github-io-比如我的仓库名为13725102796-github-io" class="headerlink" title="在Github创建新仓库，仓库名应该为：用户名.github.io 比如我的仓库名为13725102796.github.io"></a>在Github创建新仓库，仓库名应该为：<code>用户名.github.io</code> 比如我的仓库名为<code>13725102796.github.io</code></h4><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a><strong>安装Hexo</strong></h2><h4 id="Hexo-是一个快速、简单、强大的博客框架。你可以用Markdown-（或其他标记语言）写帖子，Hexo-会在几秒钟内生成带有漂亮主题的静态文件。非常快捷，方便。"><a href="#Hexo-是一个快速、简单、强大的博客框架。你可以用Markdown-（或其他标记语言）写帖子，Hexo-会在几秒钟内生成带有漂亮主题的静态文件。非常快捷，方便。" class="headerlink" title="Hexo 是一个快速、简单、强大的博客框架。你可以用Markdown （或其他标记语言）写帖子，Hexo 会在几秒钟内生成带有漂亮主题的静态文件。非常快捷，方便。"></a>Hexo 是一个快速、简单、强大的博客框架。你可以用Markdown （或其他标记语言）写帖子，Hexo 会在几秒钟内生成带有漂亮主题的静态文件。非常快捷，方便。</h4><h4 id="我们先来全局安装-Hexo-初始化项目，在切进对应目录："><a href="#我们先来全局安装-Hexo-初始化项目，在切进对应目录：" class="headerlink" title="我们先来全局安装 Hexo,初始化项目，在切进对应目录："></a>我们先来全局安装 Hexo,初始化项目，在切进对应目录：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br><span class="line">$ hexo init Blog</span><br><span class="line">$ <span class="built_in">cd</span> Blog</span><br></pre></td></tr></table></figure><h2 id="使用Hexo"><a href="#使用Hexo" class="headerlink" title="使用Hexo"></a><strong>使用Hexo</strong></h2><h4 id="创建一篇文章-hexo-n-quot-First-Blog-quot-，对应会在-x2F-sources-x2F-posts-x2F-文件下面生成一个First-Blog-md-文件，在里面编辑好博文"><a href="#创建一篇文章-hexo-n-quot-First-Blog-quot-，对应会在-x2F-sources-x2F-posts-x2F-文件下面生成一个First-Blog-md-文件，在里面编辑好博文" class="headerlink" title="创建一篇文章 hexo n &quot;First Blog&quot;，对应会在&#x2F;sources&#x2F;_posts&#x2F;文件下面生成一个First-Blog.md 文件，在里面编辑好博文"></a>创建一篇文章<code> hexo n &quot;First Blog&quot;</code>，对应会在&#x2F;sources&#x2F;_posts&#x2F;文件下面生成一个<code>First-Blog.md</code> 文件，在里面编辑好博文</h4><h4 id="修改根目录-config-yml配置文件"><a href="#修改根目录-config-yml配置文件" class="headerlink" title="修改根目录_config.yml配置文件"></a><a href="">修改根目录_config.yml配置文件</a></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: https://github.com/13725102796/13725102796.github.io </span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h4 id="执行-清除缓存并重新生成静态资源并本地运行"><a href="#执行-清除缓存并重新生成静态资源并本地运行" class="headerlink" title="执行 清除缓存并重新生成静态资源并本地运行"></a>执行 清除缓存并重新生成静态资源并本地运行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><h4 id="发布到Github上-，需要安装一个发布github的插件，再发布"><a href="#发布到Github上-，需要安装一个发布github的插件，再发布" class="headerlink" title="发布到Github上 ，需要安装一个发布github的插件，再发布"></a>发布到Github上 ，需要安装一个发布github的插件，再发布</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><h4 id="通过https-13725102796-github-io-即可访问"><a href="#通过https-13725102796-github-io-即可访问" class="headerlink" title="通过https://13725102796.github.io 即可访问"></a>通过<a href="https://13725102796.github.io/">https://13725102796.github.io</a> 即可访问</h4><h2 id="命令简写"><a href="#命令简写" class="headerlink" title="命令简写"></a><strong>命令简写</strong></h2><h4 id="新建一篇文章-hexo-n-quot-我的博客-quot-x3D-x3D-hexo-new-quot-我的博客-quot"><a href="#新建一篇文章-hexo-n-quot-我的博客-quot-x3D-x3D-hexo-new-quot-我的博客-quot" class="headerlink" title="新建一篇文章 hexo n &quot;我的博客&quot; &#x3D;&#x3D; hexo new &quot;我的博客&quot;"></a>新建一篇文章 <code>hexo n &quot;我的博客&quot;</code> &#x3D;&#x3D; <code>hexo new &quot;我的博客&quot;</code></h4><h4 id="生成静态资源文件-hexo-g-x3D-x3D-hexo-generate"><a href="#生成静态资源文件-hexo-g-x3D-x3D-hexo-generate" class="headerlink" title="生成静态资源文件 hexo g &#x3D;&#x3D; hexo generate "></a>生成静态资源文件 <code>hexo g</code> &#x3D;&#x3D; <code>hexo generate </code></h4><h4 id="启动本地服务预览-hexo-s-x3D-x3D-hexo-server"><a href="#启动本地服务预览-hexo-s-x3D-x3D-hexo-server" class="headerlink" title="启动本地服务预览 hexo s &#x3D;&#x3D; hexo server "></a>启动本地服务预览 <code>hexo s</code> &#x3D;&#x3D; <code>hexo server </code></h4><h4 id="部署到线上-hexo-d-x3D-x3D-hexo-deploy"><a href="#部署到线上-hexo-d-x3D-x3D-hexo-deploy" class="headerlink" title="部署到线上 hexo d &#x3D;&#x3D; hexo deploy "></a>部署到线上 <code>hexo d</code> &#x3D;&#x3D; <code>hexo deploy </code></h4>]]></content>
      
      
      
        <tags>
            
            <tag> Next Hexo Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/04/09/hello-world/"/>
      <url>/2018/04/09/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Next Hexo Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
